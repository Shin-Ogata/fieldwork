{"version":3,"names":["dist","parse","compile","path","options","data","TokenData","compileTokens","encode","encodeURIComponent","loose","validate","strict","flags","toFlags","stringify","toStringify","delimiter","sources","toRegExpSource","encoders","tokens","map","token","index","fn","tokenToFunction","encodeValue","NOOP_VALUE","repeated","modifier","optional","prefix","suffix","separator","value","TypeError","name","Array","isArray","length","join","validRe","RegExp","test","JSON","encoder","match","decode","decodeURIComponent","keys","re","tokensToRegexp","decoders","key","split","input","m","exec","params","Object","create","i","undefined","decoder","pathToRegexp","regexp","assign","DEFAULT_DELIMITER","ID_CHAR","DEBUG_URL","SIMPLE_TOKENS","Iter","constructor","this","peek","tryConsume","type","consume","nextType","text","result","str","encodePath","it","lexer","chars","push","pos","count","pattern","String","next","asterisk","escape","open","replace","looseReplacer","escaped","sensitive","trailing","start","end","defaultPattern","backtrack","safe","pre","post","checkPattern","err","message","safePattern","mod","sep","path2regexp"],"sources":["cdp:///@cdp/extension-path2regexp/path-to-regexp/src/index.ts","cdp:///@cdp/extension-path2regexp/index.ts"],"sourcesContent":["const DEFAULT_DELIMITER = \"/\";\nconst NOOP_VALUE = (value: string) => value;\nconst ID_CHAR = /^\\p{XID_Continue}$/u;\nconst DEBUG_URL = \"https://git.new/pathToRegexpError\";\n\n/**\n * Encode a string into another string.\n */\nexport type Encode = (value: string) => string;\n\n/**\n * Decode a string into another string.\n */\nexport type Decode = (value: string) => string;\n\nexport interface ParseOptions {\n  /**\n   * The default delimiter for segments. (default: `'/'`)\n   */\n  delimiter?: string;\n  /**\n   * A function for encoding input strings.\n   */\n  encodePath?: Encode;\n}\n\nexport interface PathToRegexpOptions extends ParseOptions {\n  /**\n   * Regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * Allow the delimiter to be arbitrarily repeated. (default: `true`)\n   */\n  loose?: boolean;\n  /**\n   * Verify patterns are valid and safe to use. (default: `false`)\n   */\n  strict?: boolean;\n  /**\n   * Match from the beginning of the string. (default: `true`)\n   */\n  start?: boolean;\n  /**\n   * Match to the end of the string. (default: `true`)\n   */\n  end?: boolean;\n  /**\n   * Allow optional trailing delimiter to match. (default: `true`)\n   */\n  trailing?: boolean;\n}\n\nexport interface MatchOptions extends PathToRegexpOptions {\n  /**\n   * Function for decoding strings for params, or `false` to disable entirely. (default: `decodeURIComponent`)\n   */\n  decode?: Decode | false;\n}\n\nexport interface CompileOptions extends ParseOptions {\n  /**\n   * Regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * Allow the delimiter to be arbitrarily repeated. (default: `true`)\n   */\n  loose?: boolean;\n  /**\n   * Verify patterns are valid and safe to use. (default: `false`)\n   */\n  strict?: boolean;\n  /**\n   * Verifies the function is producing a valid path. (default: `true`)\n   */\n  validate?: boolean;\n  /**\n   * Function for encoding input strings for output into the path, or `false` to disable entirely. (default: `encodeURIComponent`)\n   */\n  encode?: Encode | false;\n}\n\ntype TokenType =\n  | \"{\"\n  | \"}\"\n  | \";\"\n  | \"*\"\n  | \"+\"\n  | \"?\"\n  | \"NAME\"\n  | \"PATTERN\"\n  | \"CHAR\"\n  | \"ESCAPED\"\n  | \"END\"\n  // Reserved for use.\n  | \"!\"\n  | \"@\"\n  | \",\";\n\n/**\n * Tokenizer results.\n */\ninterface LexToken {\n  type: TokenType;\n  index: number;\n  value: string;\n}\n\nconst SIMPLE_TOKENS: Record<string, TokenType> = {\n  \"!\": \"!\",\n  \"@\": \"@\",\n  \";\": \";\",\n  \",\": \",\",\n  \"*\": \"*\",\n  \"+\": \"+\",\n  \"?\": \"?\",\n  \"{\": \"{\",\n  \"}\": \"}\",\n};\n\n/**\n * Tokenize input string.\n */\nfunction lexer(str: string) {\n  const chars = [...str];\n  const tokens: LexToken[] = [];\n  let i = 0;\n\n  while (i < chars.length) {\n    const value = chars[i];\n    const type = SIMPLE_TOKENS[value];\n\n    if (type) {\n      tokens.push({ type, index: i++, value });\n      continue;\n    }\n\n    if (value === \"\\\\\") {\n      tokens.push({ type: \"ESCAPED\", index: i++, value: chars[i++] });\n      continue;\n    }\n\n    if (value === \":\") {\n      let name = \"\";\n\n      while (ID_CHAR.test(chars[++i])) {\n        name += chars[i];\n      }\n\n      if (!name) {\n        throw new TypeError(`Missing parameter name at ${i}`);\n      }\n\n      tokens.push({ type: \"NAME\", index: i, value: name });\n      continue;\n    }\n\n    if (value === \"(\") {\n      const pos = i++;\n      let count = 1;\n      let pattern = \"\";\n\n      if (chars[i] === \"?\") {\n        throw new TypeError(`Pattern cannot start with \"?\" at ${i}`);\n      }\n\n      while (i < chars.length) {\n        if (chars[i] === \"\\\\\") {\n          pattern += chars[i++] + chars[i++];\n          continue;\n        }\n\n        if (chars[i] === \")\") {\n          count--;\n          if (count === 0) {\n            i++;\n            break;\n          }\n        } else if (chars[i] === \"(\") {\n          count++;\n          if (chars[i + 1] !== \"?\") {\n            throw new TypeError(`Capturing groups are not allowed at ${i}`);\n          }\n        }\n\n        pattern += chars[i++];\n      }\n\n      if (count) throw new TypeError(`Unbalanced pattern at ${pos}`);\n      if (!pattern) throw new TypeError(`Missing pattern at ${pos}`);\n\n      tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n      continue;\n    }\n\n    tokens.push({ type: \"CHAR\", index: i, value: chars[i++] });\n  }\n\n  tokens.push({ type: \"END\", index: i, value: \"\" });\n\n  return new Iter(tokens);\n}\n\nclass Iter {\n  index = 0;\n\n  constructor(private tokens: LexToken[]) {}\n\n  peek(): LexToken {\n    return this.tokens[this.index];\n  }\n\n  tryConsume(type: LexToken[\"type\"]): string | undefined {\n    const token = this.peek();\n    if (token.type !== type) return;\n    this.index++;\n    return token.value;\n  }\n\n  consume(type: LexToken[\"type\"]): string {\n    const value = this.tryConsume(type);\n    if (value !== undefined) return value;\n    const { type: nextType, index } = this.peek();\n    throw new TypeError(\n      `Unexpected ${nextType} at ${index}, expected ${type}: ${DEBUG_URL}`,\n    );\n  }\n\n  text(): string {\n    let result = \"\";\n    let value: string | undefined;\n    while ((value = this.tryConsume(\"CHAR\") || this.tryConsume(\"ESCAPED\"))) {\n      result += value;\n    }\n    return result;\n  }\n\n  modifier(): string | undefined {\n    return this.tryConsume(\"?\") || this.tryConsume(\"*\") || this.tryConsume(\"+\");\n  }\n}\n\n/**\n * Tokenized path instance. Can we passed around instead of string.\n */\nexport class TokenData {\n  constructor(\n    public readonly tokens: Token[],\n    public readonly delimiter: string,\n  ) {}\n}\n\n/**\n * Parse a string for the raw tokens.\n */\nexport function parse(str: string, options: ParseOptions = {}): TokenData {\n  const { encodePath = NOOP_VALUE, delimiter = encodePath(DEFAULT_DELIMITER) } =\n    options;\n  const tokens: Token[] = [];\n  const it = lexer(str);\n  let key = 0;\n\n  do {\n    const path = it.text();\n    if (path) tokens.push(encodePath(path));\n\n    const name = it.tryConsume(\"NAME\");\n    const pattern = it.tryConsume(\"PATTERN\");\n\n    if (name || pattern) {\n      tokens.push({\n        name: name || String(key++),\n        pattern,\n      });\n\n      const next = it.peek();\n      if (next.type === \"*\") {\n        throw new TypeError(\n          `Unexpected * at ${next.index}, you probably want \\`/*\\` or \\`{/:foo}*\\`: ${DEBUG_URL}`,\n        );\n      }\n\n      continue;\n    }\n\n    const asterisk = it.tryConsume(\"*\");\n    if (asterisk) {\n      tokens.push({\n        name: String(key++),\n        pattern: `(?:(?!${escape(delimiter)}).)*`,\n        modifier: \"*\",\n        separator: delimiter,\n      });\n      continue;\n    }\n\n    const open = it.tryConsume(\"{\");\n    if (open) {\n      const prefix = it.text();\n      const name = it.tryConsume(\"NAME\");\n      const pattern = it.tryConsume(\"PATTERN\");\n      const suffix = it.text();\n      const separator = it.tryConsume(\";\") && it.text();\n\n      it.consume(\"}\");\n\n      const modifier = it.modifier();\n\n      tokens.push({\n        name: name || (pattern ? String(key++) : \"\"),\n        prefix: encodePath(prefix),\n        suffix: encodePath(suffix),\n        pattern,\n        modifier,\n        separator,\n      });\n      continue;\n    }\n\n    it.consume(\"END\");\n    break;\n  } while (true);\n\n  return new TokenData(tokens, delimiter);\n}\n\n/**\n * Compile a string to a template function for the path.\n */\nexport function compile<P extends ParamData = ParamData>(\n  path: Path,\n  options: CompileOptions = {},\n) {\n  const data = path instanceof TokenData ? path : parse(path, options);\n  return compileTokens<P>(data, options);\n}\n\nexport type ParamData = Partial<Record<string, string | string[]>>;\nexport type PathFunction<P extends ParamData> = (data?: P) => string;\n\n/**\n * Convert a single token into a path building function.\n */\nfunction tokenToFunction(\n  token: Token,\n  encode: Encode | false,\n): (data: ParamData) => string {\n  if (typeof token === \"string\") {\n    return () => token;\n  }\n\n  const encodeValue = encode || NOOP_VALUE;\n  const repeated = token.modifier === \"+\" || token.modifier === \"*\";\n  const optional = token.modifier === \"?\" || token.modifier === \"*\";\n  const { prefix = \"\", suffix = \"\", separator = suffix + prefix } = token;\n\n  if (encode && repeated) {\n    const stringify = (value: string, index: number) => {\n      if (typeof value !== \"string\") {\n        throw new TypeError(`Expected \"${token.name}/${index}\" to be a string`);\n      }\n      return encodeValue(value);\n    };\n\n    const compile = (value: unknown) => {\n      if (!Array.isArray(value)) {\n        throw new TypeError(`Expected \"${token.name}\" to be an array`);\n      }\n\n      if (value.length === 0) return \"\";\n\n      return prefix + value.map(stringify).join(separator) + suffix;\n    };\n\n    if (optional) {\n      return (data): string => {\n        const value = data[token.name];\n        if (value == null) return \"\";\n        return value.length ? compile(value) : \"\";\n      };\n    }\n\n    return (data): string => {\n      const value = data[token.name];\n      return compile(value);\n    };\n  }\n\n  const stringify = (value: unknown) => {\n    if (typeof value !== \"string\") {\n      throw new TypeError(`Expected \"${token.name}\" to be a string`);\n    }\n    return prefix + encodeValue(value) + suffix;\n  };\n\n  if (optional) {\n    return (data): string => {\n      const value = data[token.name];\n      if (value == null) return \"\";\n      return stringify(value);\n    };\n  }\n\n  return (data): string => {\n    const value = data[token.name];\n    return stringify(value);\n  };\n}\n\n/**\n * Transform tokens into a path building function.\n */\nfunction compileTokens<P extends ParamData>(\n  data: TokenData,\n  options: CompileOptions,\n): PathFunction<P> {\n  const {\n    encode = encodeURIComponent,\n    loose = true,\n    validate = true,\n    strict = false,\n  } = options;\n  const flags = toFlags(options);\n  const stringify = toStringify(loose, data.delimiter);\n  const sources = toRegExpSource(data, stringify, [], flags, strict);\n\n  // Compile all the tokens into regexps.\n  const encoders: Array<(data: ParamData) => string> = data.tokens.map(\n    (token, index) => {\n      const fn = tokenToFunction(token, encode);\n      if (!validate || typeof token === \"string\") return fn;\n\n      const validRe = new RegExp(`^${sources[index]}$`, flags);\n\n      return (data) => {\n        const value = fn(data);\n        if (!validRe.test(value)) {\n          throw new TypeError(\n            `Invalid value for \"${token.name}\": ${JSON.stringify(value)}`,\n          );\n        }\n        return value;\n      };\n    },\n  );\n\n  return function path(data: Record<string, any> = {}) {\n    let path = \"\";\n    for (const encoder of encoders) path += encoder(data);\n    return path;\n  };\n}\n\n/**\n * A match result contains data about the path match.\n */\nexport interface MatchResult<P extends ParamData> {\n  path: string;\n  index: number;\n  params: P;\n}\n\n/**\n * A match is either `false` (no match) or a match result.\n */\nexport type Match<P extends ParamData> = false | MatchResult<P>;\n\n/**\n * The match function takes a string and returns whether it matched the path.\n */\nexport type MatchFunction<P extends ParamData> = (path: string) => Match<P>;\n\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nexport function match<P extends ParamData>(\n  path: Path,\n  options: MatchOptions = {},\n): MatchFunction<P> {\n  const { decode = decodeURIComponent, loose = true } = options;\n  const data = path instanceof TokenData ? path : parse(path, options);\n  const stringify = toStringify(loose, data.delimiter);\n  const keys: Key[] = [];\n  const re = tokensToRegexp(data, keys, options);\n\n  const decoders = keys.map((key) => {\n    if (decode && (key.modifier === \"+\" || key.modifier === \"*\")) {\n      const { prefix = \"\", suffix = \"\", separator = suffix + prefix } = key;\n      const re = new RegExp(stringify(separator), \"g\");\n      return (value: string) => value.split(re).map(decode);\n    }\n\n    return decode || NOOP_VALUE;\n  });\n\n  return function match(input: string) {\n    const m = re.exec(input);\n    if (!m) return false;\n\n    const { 0: path, index } = m;\n    const params = Object.create(null);\n\n    for (let i = 1; i < m.length; i++) {\n      if (m[i] === undefined) continue;\n\n      const key = keys[i - 1];\n      const decoder = decoders[i - 1];\n      params[key.name] = decoder(m[i]);\n    }\n\n    return { path, index, params };\n  };\n}\n\n/**\n * Escape a regular expression string.\n */\nfunction escape(str: string) {\n  return str.replace(/([.+*?^${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n\n/**\n * Escape and repeat loose characters for regular expressions.\n */\nfunction looseReplacer(value: string, loose: string) {\n  const escaped = escape(value);\n  return loose ? `(?:${escaped})+(?!${escaped})` : escaped;\n}\n\n/**\n * Encode all non-delimiter characters using the encode function.\n */\nfunction toStringify(loose: boolean, delimiter: string) {\n  if (!loose) return escape;\n\n  const re = new RegExp(`(?:(?!${escape(delimiter)}).)+|(.)`, \"g\");\n  return (value: string) => value.replace(re, looseReplacer);\n}\n\n/**\n * Get the flags for a regexp from the options.\n */\nfunction toFlags(options: { sensitive?: boolean }) {\n  return options.sensitive ? \"\" : \"i\";\n}\n\n/**\n * A key is a capture group in the regex.\n */\nexport interface Key {\n  name: string;\n  prefix?: string;\n  suffix?: string;\n  pattern?: string;\n  modifier?: string;\n  separator?: string;\n}\n\n/**\n * A token is a string (nothing special) or key metadata (capture group).\n */\nexport type Token = string | Key;\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nfunction tokensToRegexp(\n  data: TokenData,\n  keys: Key[],\n  options: PathToRegexpOptions,\n): RegExp {\n  const {\n    trailing = true,\n    loose = true,\n    start = true,\n    end = true,\n    strict = false,\n  } = options;\n  const flags = toFlags(options);\n  const stringify = toStringify(loose, data.delimiter);\n  const sources = toRegExpSource(data, stringify, keys, flags, strict);\n  let pattern = start ? \"^\" : \"\";\n  pattern += sources.join(\"\");\n  if (trailing) pattern += `(?:${stringify(data.delimiter)})?`;\n  pattern += end ? \"$\" : `(?=${escape(data.delimiter)}|$)`;\n\n  return new RegExp(pattern, flags);\n}\n\n/**\n * Convert a token into a regexp string (re-used for path validation).\n */\nfunction toRegExpSource(\n  data: TokenData,\n  stringify: Encode,\n  keys: Key[],\n  flags: string,\n  strict: boolean,\n): string[] {\n  const defaultPattern = `(?:(?!${escape(data.delimiter)}).)+?`;\n  let backtrack = \"\";\n  let safe = true;\n\n  return data.tokens.map((token, index) => {\n    if (typeof token === \"string\") {\n      backtrack = token;\n      return stringify(token);\n    }\n\n    const {\n      prefix = \"\",\n      suffix = \"\",\n      separator = suffix + prefix,\n      modifier = \"\",\n    } = token;\n\n    const pre = stringify(prefix);\n    const post = stringify(suffix);\n\n    if (token.name) {\n      const pattern = token.pattern ? `(?:${token.pattern})` : defaultPattern;\n      const re = checkPattern(pattern, token.name, flags);\n\n      safe ||= safePattern(re, prefix || backtrack);\n      if (!safe) {\n        throw new TypeError(\n          `Ambiguous pattern for \"${token.name}\": ${DEBUG_URL}`,\n        );\n      }\n      safe = !strict || safePattern(re, suffix);\n      backtrack = \"\";\n\n      keys.push(token);\n\n      if (modifier === \"+\" || modifier === \"*\") {\n        const mod = modifier === \"*\" ? \"?\" : \"\";\n        const sep = stringify(separator);\n\n        if (!sep) {\n          throw new TypeError(\n            `Missing separator for \"${token.name}\": ${DEBUG_URL}`,\n          );\n        }\n\n        safe ||= !strict || safePattern(re, separator);\n        if (!safe) {\n          throw new TypeError(\n            `Ambiguous pattern for \"${token.name}\" separator: ${DEBUG_URL}`,\n          );\n        }\n        safe = !strict;\n\n        return `(?:${pre}(${pattern}(?:${sep}${pattern})*)${post})${mod}`;\n      }\n\n      return `(?:${pre}(${pattern})${post})${modifier}`;\n    }\n\n    return `(?:${pre}${post})${modifier}`;\n  });\n}\n\nfunction checkPattern(pattern: string, name: string, flags: string) {\n  try {\n    return new RegExp(`^${pattern}$`, flags);\n  } catch (err: any) {\n    throw new TypeError(`Invalid pattern for \"${name}\": ${err.message}`);\n  }\n}\n\nfunction safePattern(re: RegExp, value: string) {\n  return value ? !re.test(value) : false;\n}\n\n/**\n * Repeated and simple input types.\n */\nexport type Path = string | TokenData;\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nexport function pathToRegexp(path: Path, options: PathToRegexpOptions = {}) {\n  const data = path instanceof TokenData ? path : parse(path, options);\n  const keys: Key[] = [];\n  const regexp = tokensToRegexp(data, keys, options);\n  return Object.assign(regexp, { keys });\n}\n","/* eslint-disable\n    @typescript-eslint/no-namespace,\n */\n\nimport {\n    Encode as p2rEncode,\n    Decode as p2rDecode,\n    ParseOptions as p2rParseOptions,\n    PathToRegexpOptions as p2rPathToRegexpOptions,\n    MatchOptions as p2rMatchOptions,\n    CompileOptions as p2rCompileOptions,\n    TokenData as p2rTokenData,\n    ParamData as p2rParamData,\n    PathFunction as p2rPathFunction,\n    MatchResult as p2rMatchResult,\n    Match as p2rMatch,\n    MatchFunction as p2rMatchFunction,\n    Key as p2rKey,\n    Token as p2rToken,\n    Path as p2rPath,\n    parse,\n    compile,\n    match,\n    pathToRegexp,\n} from 'path-to-regexp';\n\ndeclare namespace path2regexp {\n    export type Encode = p2rEncode;\n    export type Decode = p2rDecode;\n    export type ParseOptions = p2rParseOptions;\n    export type PathToRegexpOptions = p2rPathToRegexpOptions;\n    export type MatchOptions = p2rMatchOptions;\n    export type CompileOptions = p2rCompileOptions;\n    export type TokenData = p2rTokenData;\n    export type ParamData = p2rParamData;\n    export type PathFunction<P extends ParamData> = p2rPathFunction<P>;\n    export type MatchResult<P extends ParamData> = p2rMatchResult<P>;\n    export type Match<P extends ParamData> = p2rMatch<P>;\n    export type MatchFunction<P extends ParamData> = p2rMatchFunction<P>;\n    export type Key = p2rKey;\n    export type Token = p2rToken;\n    export type Path = p2rPath;\n}\n\nconst path2regexp = {\n    parse,\n    compile,\n    match,\n    pathToRegexp,\n};\n\nexport { path2regexp };\n"],"mappings":"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","ignoreList":[]}