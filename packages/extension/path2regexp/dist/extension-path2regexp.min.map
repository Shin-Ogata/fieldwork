{"version":3,"names":["parse","str","options","tokens","lexer","i","length","char","push","type","index","value","count","pattern","j","TypeError","concat","name","code","charCodeAt","_a","prefixes","defaultPattern","escapeString","delimiter","result","key","path","tryConsume","mustConsume","undefined","nextType","consumeText","prefix","indexOf","suffix","modifier","open","name_1","pattern_1","tokensToFunction","reFlags","flags","encode","x","_b","validate","matches","map","token","RegExp","data","optional","repeat","Array","isArray","segment","test","typeOfMessage","String","regexpToFunction","re","keys","decode","pathname","m","exec","params","Object","create","split","replace","sensitive","tokensToRegexp","strict","start","_c","end","_d","_e","_f","endsWith","endsWithRe","delimiterRe","route","_i","tokens_1","mod","endToken","isEndDelimited","pathToRegexp","regexpToRegexp","groupsRegex","execResult","source","arrayToRegexp","paths","parts","join","stringToRegexp","path2regexp","compile","match"],"sources":["cdp:///@cdp/extension-path2regexp/path-to-regexp/src/index.ts","cdp:///@cdp/extension-path2regexp/index.ts"],"sourcesContent":["/**\n * Tokenizer results.\n */\ninterface LexToken {\n  type:\n    | \"OPEN\"\n    | \"CLOSE\"\n    | \"PATTERN\"\n    | \"NAME\"\n    | \"CHAR\"\n    | \"ESCAPED_CHAR\"\n    | \"MODIFIER\"\n    | \"END\";\n  index: number;\n  value: string;\n}\n\n/**\n * Tokenize input string.\n */\nfunction lexer(str: string): LexToken[] {\n  const tokens: LexToken[] = [];\n  let i = 0;\n\n  while (i < str.length) {\n    const char = str[i];\n\n    if (char === \"*\" || char === \"+\" || char === \"?\") {\n      tokens.push({ type: \"MODIFIER\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"\\\\\") {\n      tokens.push({ type: \"ESCAPED_CHAR\", index: i++, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"{\") {\n      tokens.push({ type: \"OPEN\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \"}\") {\n      tokens.push({ type: \"CLOSE\", index: i, value: str[i++] });\n      continue;\n    }\n\n    if (char === \":\") {\n      let name = \"\";\n      let j = i + 1;\n\n      while (j < str.length) {\n        const code = str.charCodeAt(j);\n\n        if (\n          // `0-9`\n          (code >= 48 && code <= 57) ||\n          // `A-Z`\n          (code >= 65 && code <= 90) ||\n          // `a-z`\n          (code >= 97 && code <= 122) ||\n          // `_`\n          code === 95\n        ) {\n          name += str[j++];\n          continue;\n        }\n\n        break;\n      }\n\n      if (!name) throw new TypeError(`Missing parameter name at ${i}`);\n\n      tokens.push({ type: \"NAME\", index: i, value: name });\n      i = j;\n      continue;\n    }\n\n    if (char === \"(\") {\n      let count = 1;\n      let pattern = \"\";\n      let j = i + 1;\n\n      if (str[j] === \"?\") {\n        throw new TypeError(`Pattern cannot start with \"?\" at ${j}`);\n      }\n\n      while (j < str.length) {\n        if (str[j] === \"\\\\\") {\n          pattern += str[j++] + str[j++];\n          continue;\n        }\n\n        if (str[j] === \")\") {\n          count--;\n          if (count === 0) {\n            j++;\n            break;\n          }\n        } else if (str[j] === \"(\") {\n          count++;\n          if (str[j + 1] !== \"?\") {\n            throw new TypeError(`Capturing groups are not allowed at ${j}`);\n          }\n        }\n\n        pattern += str[j++];\n      }\n\n      if (count) throw new TypeError(`Unbalanced pattern at ${i}`);\n      if (!pattern) throw new TypeError(`Missing pattern at ${i}`);\n\n      tokens.push({ type: \"PATTERN\", index: i, value: pattern });\n      i = j;\n      continue;\n    }\n\n    tokens.push({ type: \"CHAR\", index: i, value: str[i++] });\n  }\n\n  tokens.push({ type: \"END\", index: i, value: \"\" });\n\n  return tokens;\n}\n\nexport interface ParseOptions {\n  /**\n   * Set the default delimiter for repeat parameters. (default: `'/'`)\n   */\n  delimiter?: string;\n  /**\n   * List of characters to automatically consider prefixes when parsing.\n   */\n  prefixes?: string;\n}\n\n/**\n * Parse a string for the raw tokens.\n */\nexport function parse(str: string, options: ParseOptions = {}): Token[] {\n  const tokens = lexer(str);\n  const { prefixes = \"./\" } = options;\n  const defaultPattern = `[^${escapeString(options.delimiter || \"/#?\")}]+?`;\n  const result: Token[] = [];\n  let key = 0;\n  let i = 0;\n  let path = \"\";\n\n  const tryConsume = (type: LexToken[\"type\"]): string | undefined => {\n    if (i < tokens.length && tokens[i].type === type) return tokens[i++].value;\n  };\n\n  const mustConsume = (type: LexToken[\"type\"]): string => {\n    const value = tryConsume(type);\n    if (value !== undefined) return value;\n    const { type: nextType, index } = tokens[i];\n    throw new TypeError(`Unexpected ${nextType} at ${index}, expected ${type}`);\n  };\n\n  const consumeText = (): string => {\n    let result = \"\";\n    let value: string | undefined;\n    while ((value = tryConsume(\"CHAR\") || tryConsume(\"ESCAPED_CHAR\"))) {\n      result += value;\n    }\n    return result;\n  };\n\n  while (i < tokens.length) {\n    const char = tryConsume(\"CHAR\");\n    const name = tryConsume(\"NAME\");\n    const pattern = tryConsume(\"PATTERN\");\n\n    if (name || pattern) {\n      let prefix = char || \"\";\n\n      if (prefixes.indexOf(prefix) === -1) {\n        path += prefix;\n        prefix = \"\";\n      }\n\n      if (path) {\n        result.push(path);\n        path = \"\";\n      }\n\n      result.push({\n        name: name || key++,\n        prefix,\n        suffix: \"\",\n        pattern: pattern || defaultPattern,\n        modifier: tryConsume(\"MODIFIER\") || \"\",\n      });\n      continue;\n    }\n\n    const value = char || tryConsume(\"ESCAPED_CHAR\");\n    if (value) {\n      path += value;\n      continue;\n    }\n\n    if (path) {\n      result.push(path);\n      path = \"\";\n    }\n\n    const open = tryConsume(\"OPEN\");\n    if (open) {\n      const prefix = consumeText();\n      const name = tryConsume(\"NAME\") || \"\";\n      const pattern = tryConsume(\"PATTERN\") || \"\";\n      const suffix = consumeText();\n\n      mustConsume(\"CLOSE\");\n\n      result.push({\n        name: name || (pattern ? key++ : \"\"),\n        pattern: name && !pattern ? defaultPattern : pattern,\n        prefix,\n        suffix,\n        modifier: tryConsume(\"MODIFIER\") || \"\",\n      });\n      continue;\n    }\n\n    mustConsume(\"END\");\n  }\n\n  return result;\n}\n\nexport interface TokensToFunctionOptions {\n  /**\n   * When `true` the regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * Function for encoding input strings for output.\n   */\n  encode?: (value: string, token: Key) => string;\n  /**\n   * When `false` the function can produce an invalid (unmatched) path. (default: `true`)\n   */\n  validate?: boolean;\n}\n\n/**\n * Compile a string to a template function for the path.\n */\nexport function compile<P extends object = object>(\n  str: string,\n  options?: ParseOptions & TokensToFunctionOptions,\n) {\n  return tokensToFunction<P>(parse(str, options), options);\n}\n\nexport type PathFunction<P extends object = object> = (data?: P) => string;\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nexport function tokensToFunction<P extends object = object>(\n  tokens: Token[],\n  options: TokensToFunctionOptions = {},\n): PathFunction<P> {\n  const reFlags = flags(options);\n  const { encode = (x: string) => x, validate = true } = options;\n\n  // Compile all the tokens into regexps.\n  const matches = tokens.map((token) => {\n    if (typeof token === \"object\") {\n      return new RegExp(`^(?:${token.pattern})$`, reFlags);\n    }\n  });\n\n  return (data: Record<string, any> | null | undefined) => {\n    let path = \"\";\n\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i];\n\n      if (typeof token === \"string\") {\n        path += token;\n        continue;\n      }\n\n      const value = data ? data[token.name] : undefined;\n      const optional = token.modifier === \"?\" || token.modifier === \"*\";\n      const repeat = token.modifier === \"*\" || token.modifier === \"+\";\n\n      if (Array.isArray(value)) {\n        if (!repeat) {\n          throw new TypeError(\n            `Expected \"${token.name}\" to not repeat, but got an array`,\n          );\n        }\n\n        if (value.length === 0) {\n          if (optional) continue;\n\n          throw new TypeError(`Expected \"${token.name}\" to not be empty`);\n        }\n\n        for (let j = 0; j < value.length; j++) {\n          const segment = encode(value[j], token);\n\n          if (validate && !(matches[i] as RegExp).test(segment)) {\n            throw new TypeError(\n              `Expected all \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`,\n            );\n          }\n\n          path += token.prefix + segment + token.suffix;\n        }\n\n        continue;\n      }\n\n      if (typeof value === \"string\" || typeof value === \"number\") {\n        const segment = encode(String(value), token);\n\n        if (validate && !(matches[i] as RegExp).test(segment)) {\n          throw new TypeError(\n            `Expected \"${token.name}\" to match \"${token.pattern}\", but got \"${segment}\"`,\n          );\n        }\n\n        path += token.prefix + segment + token.suffix;\n        continue;\n      }\n\n      if (optional) continue;\n\n      const typeOfMessage = repeat ? \"an array\" : \"a string\";\n      throw new TypeError(`Expected \"${token.name}\" to be ${typeOfMessage}`);\n    }\n\n    return path;\n  };\n}\n\nexport interface RegexpToFunctionOptions {\n  /**\n   * Function for decoding strings for params.\n   */\n  decode?: (value: string, token: Key) => string;\n}\n\n/**\n * A match result contains data about the path match.\n */\nexport interface MatchResult<P extends object = object> {\n  path: string;\n  index: number;\n  params: P;\n}\n\n/**\n * A match is either `false` (no match) or a match result.\n */\nexport type Match<P extends object = object> = false | MatchResult<P>;\n\n/**\n * The match function takes a string and returns whether it matched the path.\n */\nexport type MatchFunction<P extends object = object> = (\n  path: string,\n) => Match<P>;\n\n/**\n * Create path match function from `path-to-regexp` spec.\n */\nexport function match<P extends object = object>(\n  str: Path,\n  options?: ParseOptions & TokensToRegexpOptions & RegexpToFunctionOptions,\n) {\n  const keys: Key[] = [];\n  const re = pathToRegexp(str, keys, options);\n  return regexpToFunction<P>(re, keys, options);\n}\n\n/**\n * Create a path match function from `path-to-regexp` output.\n */\nexport function regexpToFunction<P extends object = object>(\n  re: RegExp,\n  keys: Key[],\n  options: RegexpToFunctionOptions = {},\n): MatchFunction<P> {\n  const { decode = (x: string) => x } = options;\n\n  return function (pathname: string) {\n    const m = re.exec(pathname);\n    if (!m) return false;\n\n    const { 0: path, index } = m;\n    const params = Object.create(null);\n\n    for (let i = 1; i < m.length; i++) {\n      if (m[i] === undefined) continue;\n\n      const key = keys[i - 1];\n\n      if (key.modifier === \"*\" || key.modifier === \"+\") {\n        params[key.name] = m[i].split(key.prefix + key.suffix).map((value) => {\n          return decode(value, key);\n        });\n      } else {\n        params[key.name] = decode(m[i], key);\n      }\n    }\n\n    return { path, index, params };\n  };\n}\n\n/**\n * Escape a regular expression string.\n */\nfunction escapeString(str: string) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, \"\\\\$1\");\n}\n\n/**\n * Get the flags for a regexp from the options.\n */\nfunction flags(options?: { sensitive?: boolean }) {\n  return options && options.sensitive ? \"\" : \"i\";\n}\n\n/**\n * Metadata about a key.\n */\nexport interface Key {\n  name: string | number;\n  prefix: string;\n  suffix: string;\n  pattern: string;\n  modifier: string;\n}\n\n/**\n * A token is a string (nothing special) or key metadata (capture group).\n */\nexport type Token = string | Key;\n\n/**\n * Pull out keys from a regexp.\n */\nfunction regexpToRegexp(path: RegExp, keys?: Key[]): RegExp {\n  if (!keys) return path;\n\n  const groupsRegex = /\\((?:\\?<(.*?)>)?(?!\\?)/g;\n\n  let index = 0;\n  let execResult = groupsRegex.exec(path.source);\n  while (execResult) {\n    keys.push({\n      // Use parenthesized substring match if available, index otherwise\n      name: execResult[1] || index++,\n      prefix: \"\",\n      suffix: \"\",\n      modifier: \"\",\n      pattern: \"\",\n    });\n    execResult = groupsRegex.exec(path.source);\n  }\n\n  return path;\n}\n\n/**\n * Transform an array into a regexp.\n */\nfunction arrayToRegexp(\n  paths: Array<string | RegExp>,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions,\n): RegExp {\n  const parts = paths.map((path) => pathToRegexp(path, keys, options).source);\n  return new RegExp(`(?:${parts.join(\"|\")})`, flags(options));\n}\n\n/**\n * Create a path regexp from string input.\n */\nfunction stringToRegexp(\n  path: string,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions,\n) {\n  return tokensToRegexp(parse(path, options), keys, options);\n}\n\nexport interface TokensToRegexpOptions {\n  /**\n   * When `true` the regexp will be case sensitive. (default: `false`)\n   */\n  sensitive?: boolean;\n  /**\n   * When `true` the regexp won't allow an optional trailing delimiter to match. (default: `false`)\n   */\n  strict?: boolean;\n  /**\n   * When `true` the regexp will match to the end of the string. (default: `true`)\n   */\n  end?: boolean;\n  /**\n   * When `true` the regexp will match from the beginning of the string. (default: `true`)\n   */\n  start?: boolean;\n  /**\n   * Sets the final character for non-ending optimistic matches. (default: `/`)\n   */\n  delimiter?: string;\n  /**\n   * List of characters that can also be \"end\" characters.\n   */\n  endsWith?: string;\n  /**\n   * Encode path tokens for use in the `RegExp`.\n   */\n  encode?: (value: string) => string;\n}\n\n/**\n * Expose a function for taking tokens and returning a RegExp.\n */\nexport function tokensToRegexp(\n  tokens: Token[],\n  keys?: Key[],\n  options: TokensToRegexpOptions = {},\n) {\n  const {\n    strict = false,\n    start = true,\n    end = true,\n    encode = (x: string) => x,\n    delimiter = \"/#?\",\n    endsWith = \"\",\n  } = options;\n  const endsWithRe = `[${escapeString(endsWith)}]|$`;\n  const delimiterRe = `[${escapeString(delimiter)}]`;\n  let route = start ? \"^\" : \"\";\n\n  // Iterate over the tokens and create our regexp string.\n  for (const token of tokens) {\n    if (typeof token === \"string\") {\n      route += escapeString(encode(token));\n    } else {\n      const prefix = escapeString(encode(token.prefix));\n      const suffix = escapeString(encode(token.suffix));\n\n      if (token.pattern) {\n        if (keys) keys.push(token);\n\n        if (prefix || suffix) {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            const mod = token.modifier === \"*\" ? \"?\" : \"\";\n            route += `(?:${prefix}((?:${token.pattern})(?:${suffix}${prefix}(?:${token.pattern}))*)${suffix})${mod}`;\n          } else {\n            route += `(?:${prefix}(${token.pattern})${suffix})${token.modifier}`;\n          }\n        } else {\n          if (token.modifier === \"+\" || token.modifier === \"*\") {\n            route += `((?:${token.pattern})${token.modifier})`;\n          } else {\n            route += `(${token.pattern})${token.modifier}`;\n          }\n        }\n      } else {\n        route += `(?:${prefix}${suffix})${token.modifier}`;\n      }\n    }\n  }\n\n  if (end) {\n    if (!strict) route += `${delimiterRe}?`;\n\n    route += !options.endsWith ? \"$\" : `(?=${endsWithRe})`;\n  } else {\n    const endToken = tokens[tokens.length - 1];\n    const isEndDelimited =\n      typeof endToken === \"string\"\n        ? delimiterRe.indexOf(endToken[endToken.length - 1]) > -1\n        : endToken === undefined;\n\n    if (!strict) {\n      route += `(?:${delimiterRe}(?=${endsWithRe}))?`;\n    }\n\n    if (!isEndDelimited) {\n      route += `(?=${delimiterRe}|${endsWithRe})`;\n    }\n  }\n\n  return new RegExp(route, flags(options));\n}\n\n/**\n * Supported `path-to-regexp` input types.\n */\nexport type Path = string | RegExp | Array<string | RegExp>;\n\n/**\n * Normalize the given path string, returning a regular expression.\n *\n * An empty array can be passed in for the keys, which will hold the\n * placeholder key descriptions. For example, using `/user/:id`, `keys` will\n * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.\n */\nexport function pathToRegexp(\n  path: Path,\n  keys?: Key[],\n  options?: TokensToRegexpOptions & ParseOptions,\n) {\n  if (path instanceof RegExp) return regexpToRegexp(path, keys);\n  if (Array.isArray(path)) return arrayToRegexp(path, keys, options);\n  return stringToRegexp(path, keys, options);\n}\n","/* eslint-disable\n    @typescript-eslint/no-namespace,\n */\n\nimport {\n    ParseOptions as p2rParseOptions,\n    TokensToFunctionOptions as p2rTokensToFunctionOptions,\n    PathFunction as p2rPathFunction,\n    RegexpToFunctionOptions as p2rRegexpToFunctionOptions,\n    MatchResult as p2rMatchResult,\n    Match as p2rMatch,\n    MatchFunction as p2rMatchFunction,\n    Key as p2rKey,\n    Token as p2rToken,\n    TokensToRegexpOptions as p2rTokensToRegexpOptions,\n    Path as p2rPath,\n    parse,\n    compile,\n    tokensToFunction,\n    match,\n    regexpToFunction,\n    tokensToRegexp,\n    pathToRegexp,\n} from 'path-to-regexp';\n\ndeclare namespace path2regexp {\n    export type ParseOptions = p2rParseOptions;\n    export type TokensToFunctionOptions = p2rTokensToFunctionOptions;\n    export type PathFunction = p2rPathFunction;\n    export type RegexpToFunctionOptions = p2rRegexpToFunctionOptions;\n    export type MatchResult = p2rMatchResult;\n    export type Match = p2rMatch;\n    export type MatchFunction = p2rMatchFunction;\n    export type Key = p2rKey;\n    export type Token = p2rToken;\n    export type TokensToRegexpOptions = p2rTokensToRegexpOptions;\n    export type Path = p2rPath;\n    export type parse = typeof parse;\n    export type compile = typeof compile;\n    export type tokensToFunction = typeof tokensToFunction;\n    export type match = typeof match;\n    export type regexpToFunction = typeof regexpToFunction;\n    export type tokensToRegexp = typeof tokensToRegexp;\n    export type pathToRegexp = typeof pathToRegexp;\n}\n\nconst path2regexp = {\n    parse,\n    compile,\n    tokensToFunction,\n    match,\n    regexpToFunction,\n    tokensToRegexp,\n    pathToRegexp,\n};\n\nexport { path2regexp };\n"],"mappings":"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","ignoreList":[]}