/*!
 * @cdp/extension-path2regexp 0.9.19
 *   extension for conversion path to regexp library
 */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):(e="undefined"!=typeof globalThis?globalThis:e||self,t((e.CDP=e.CDP||{},e.CDP.Exension=e.CDP.Exension||{})))}(this,(function(e){"use strict";var t,n={};var r=function o(){if(t)return n;t=1,Object.defineProperty(n,"__esModule",{value:!0}),n.TokenData=void 0,n.parse=d,n.compile=function e(t,n={}){const{encode:r=encodeURIComponent,delimiter:o=i}=n,s=t instanceof y?t:d(t,n),u=m(s.tokens,o,r);return function e(t={}){const[e,...n]=u(t);if(n.length)throw new TypeError(`Missing parameters: ${n.join(", ")}`);return e}},n.match=function r(e,t={}){const{decode:n=decodeURIComponent,delimiter:r=i}=t,{regexp:o,keys:u}=h(e,t),p=u.map((e=>!1===n?s:"param"===e.type?n:e=>e.split(r).map(n)));return function e(t){const n=o.exec(t);if(!n)return!1;const r=n[0],i=Object.create(null);for(let e=1;e<n.length;e++){if(void 0===n[e])continue;const t=u[e-1],r=p[e-1];i[t.name]=r(n[e])}return{path:r,params:i}}},n.pathToRegexp=h,n.stringify=function o(e){return e.tokens.map((function e(t,n,r){if("text"===t.type)return function o(e){return e.replace(/[{}()\[\]+?!:*]/g,"\\$&")}(t.value);if("group"===t.type)return`{${t.tokens.map(e).join("")}}`;const i=function s(e){const[t,...n]=e;return!!u.test(t)&&n.every((e=>p.test(e)))}(t.name)&&function c(e){return"text"!==(null==e?void 0:e.type)||!p.test(e.value[0])}(r[n+1]),a=i?t.name:JSON.stringify(t.name);if("param"===t.type)return`:${a}`;if("wildcard"===t.type)return`*${a}`;throw new TypeError(`Unexpected token: ${t}`)})).join("")};const i="/",s=e=>e,u=/^[$_\p{ID_Start}]$/u,p=/^[$\u200c\u200d\p{ID_Continue}]$/u,c="https://git.new/pathToRegexpError",a={"{":"{","}":"}","(":"(",")":")","[":"[","]":"]","+":"+","?":"?","!":"!"};function f(e){return e.replace(/[.+*?^${}()[\]|/\\]/g,"\\$&")}class l{constructor(e){this.tokens=e}peek(){if(!this._peek){const e=this.tokens.next();this._peek=e.value}return this._peek}tryConsume(e){const t=this.peek();if(t.type===e)return this._peek=void 0,t.value}consume(e){const t=this.tryConsume(e);if(void 0!==t)return t;const{type:n,index:r}=this.peek();throw new TypeError(`Unexpected ${n} at ${r}, expected ${e}: ${c}`)}text(){let e,t="";for(;e=this.tryConsume("CHAR")||this.tryConsume("ESCAPED");)t+=e;return t}}class y{constructor(e){this.tokens=e}}function d(e,t={}){const{encodePath:n=s}=t,r=new l(function*o(e){const t=[...e];let n=0;function r(){let e="";if(u.test(t[++n]))for(e+=t[n];p.test(t[++n]);)e+=t[n];else if('"'===t[n]){let r=n;for(;n<t.length;){if('"'===t[++n]){n++,r=0;break}e+="\\"===t[n]?t[++n]:t[n]}if(r)throw new TypeError(`Unterminated quote at ${r}: ${c}`)}if(!e)throw new TypeError(`Missing parameter name at ${n}: ${c}`);return e}for(;n<t.length;){const e=t[n],o=a[e];if(o)yield{type:o,index:n++,value:e};else if("\\"===e)yield{type:"ESCAPED",index:n++,value:t[n++]};else if(":"===e){const e=r();yield{type:"PARAM",index:n,value:e}}else if("*"===e){const e=r();yield{type:"WILDCARD",index:n,value:e}}else yield{type:"CHAR",index:n,value:t[n++]}}return{type:"END",index:n,value:""}}(e));const i=function e(t){const o=[];for(;;){const i=r.text();i&&o.push({type:"text",value:n(i)});const s=r.tryConsume("PARAM");if(s){o.push({type:"param",name:s});continue}const u=r.tryConsume("WILDCARD");if(u){o.push({type:"wildcard",name:u});continue}const p=r.tryConsume("{");if(!p)return r.consume(t),o;o.push({type:"group",tokens:e("}")})}}("END");return new y(i)}function m(e,t,n){const r=e.map((e=>function r(e,t,n){if("text"===e.type)return()=>[e.value];if("group"===e.type){const r=m(e.tokens,t,n);return e=>{const[t,...n]=r(e);return n.length?[""]:[t]}}const r=n||s;if("wildcard"===e.type&&!1!==n)return n=>{const o=n[e.name];if(null==o)return["",e.name];if(!Array.isArray(o)||0===o.length)throw new TypeError(`Expected "${e.name}" to be a non-empty array`);return[o.map(((t,n)=>{if("string"!=typeof t)throw new TypeError(`Expected "${e.name}/${n}" to be a string`);return r(t)})).join(t)]};return t=>{const n=t[e.name];if(null==n)return["",e.name];if("string"!=typeof n)throw new TypeError(`Expected "${e.name}" to be a string`);return[r(n)]}}(e,t,n)));return e=>{const t=[""];for(const n of r){const[r,...o]=n(e);t[0]+=r,t.push(...o)}return t}}function h(e,t={}){const{delimiter:n=i,end:r=!0,sensitive:o=!1,trailing:s=!0}=t,u=[],p=[],c=o?"":"i",a=Array.isArray(e)?e:[e],l=a.map((e=>e instanceof y?e:d(e,t)));for(const{tokens:e}of l)for(const t of g(e,0,[])){const e=$(t,n,u);p.push(e)}let m=`^(?:${p.join("|")})`;s&&(m+=`(?:${f(n)}$)?`),m+=r?"$":`(?=${f(n)}|$)`;const h=new RegExp(m,c);return{regexp:h,keys:u}}function*g(e,t,n){if(t===e.length)return yield n;const r=e[t];if("group"===r.type){const o=n.slice();for(const n of g(r.tokens,0,o))yield*g(e,t+1,n)}else n.push(r);yield*g(e,t+1,n)}function $(e,t,n){let r="",o="",i=!0;for(let s=0;s<e.length;s++){const u=e[s];if("text"!==u.type)if("param"!==u.type&&"wildcard"!==u.type);else{if(!i&&!o)throw new TypeError(`Missing text after "${u.name}": ${c}`);"param"===u.type?r+=`(${x(t,i?"":o)}+)`:r+="([\\s\\S]+)",n.push(u),o="",i=!1}else r+=f(u.value),o+=u.value,i||(i=u.value.includes(t))}return r}function x(e,t){return t.length<2?e.length<2?`[^${f(e+t)}]`:`(?:(?!${f(e)})[^${f(t)}])`:e.length<2?`(?:(?!${f(t)})[^${f(e)}])`:`(?:(?!${f(t)}|${f(e)})[\\s\\S])`}return n.TokenData=y,n}();const i={TokenData:r.TokenData,parse:r.parse,compile:r.compile,match:r.match,stringify:r.stringify,pathToRegexp:r.pathToRegexp};e.path2regexp=i,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
//# sourceMappingURL=extension-path2regexp.min.map