/*!
 * @cdp/extension-path2regexp 0.9.20
 *   extension for conversion path to regexp library
 */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):(e="undefined"!=typeof globalThis?globalThis:e||self,t((e.CDP=e.CDP||{},e.CDP.Exension=e.CDP.Exension||{})))}(this,function(e){"use strict";var t,n={};var r=function o(){if(t)return n;t=1,Object.defineProperty(n,"__esModule",{value:!0}),n.PathError=n.TokenData=void 0,n.parse=h,n.compile=function e(t,n={}){const{encode:r=encodeURIComponent,delimiter:o=i}=n,s="object"==typeof t?t:h(t,n),p=d(s.tokens,o,r);return function e(t={}){const[e,...n]=p(t);if(n.length)throw new TypeError(`Missing parameters: ${n.join(", ")}`);return e}},n.match=function r(e,t={}){const{decode:n=decodeURIComponent,delimiter:r=i}=t,{regexp:o,keys:p}=g(e,t),a=p.map(e=>!1===n?s:"param"===e.type?n:e=>e.split(r).map(n));return function e(t){const n=o.exec(t);if(!n)return!1;const r=n[0],i=Object.create(null);for(let e=1;e<n.length;e++){if(void 0===n[e])continue;const t=p[e-1],r=a[e-1];i[t.name]=r(n[e])}return{path:r,params:i}}},n.pathToRegexp=g,n.stringify=function o(e){return v(e.tokens)};const i="/",s=e=>e,p=/^[$_\p{ID_Start}]$/u,a=/^[$\u200c\u200d\p{ID_Continue}]$/u,u={"{":"{","}":"}","(":"(",")":")","[":"[","]":"]","+":"+","?":"?","!":"!"};function c(e){return e.replace(/[{}()\[\]+?!:*\\]/g,"\\$&")}function f(e){return e.replace(/[.+*?^${}()[\]|/\\]/g,"\\$&")}class l{constructor(e,t){this.tokens=e,this.originalPath=t}}n.TokenData=l;class y extends TypeError{constructor(e,t){let n=e;t&&(n+=`: ${t}`),n+="; visit https://git.new/pathToRegexpError for info",super(n),this.originalPath=t}}function h(e,t={}){const{encodePath:n=s}=t,r=[...e],o=[];let i=0,c=0;function f(){let t="";if(p.test(r[i]))do{t+=r[i++]}while(a.test(r[i]));else if('"'===r[i]){let n=i;for(;i++<r.length;){if('"'===r[i]){i++,n=0;break}"\\"===r[i]&&i++,t+=r[i]}if(n)throw new y(`Unterminated quote at index ${n}`,e)}if(!t)throw new y(`Missing parameter name at index ${i}`,e);return t}for(;i<r.length;){const e=r[i],t=u[e];t?o.push({type:t,index:i++,value:e}):"\\"===e?o.push({type:"escape",index:i++,value:r[i++]}):":"===e?o.push({type:"param",index:i++,value:f()}):"*"===e?o.push({type:"wildcard",index:i++,value:f()}):o.push({type:"char",index:i++,value:e})}return o.push({type:"end",index:i,value:""}),new l(function t(r){const i=[];for(;;){const s=o[c++];if(s.type===r)break;if("char"===s.type||"escape"===s.type){let e=s.value,t=o[c];for(;"char"===t.type||"escape"===t.type;)e+=t.value,t=o[++c];i.push({type:"text",value:n(e)});continue}if("param"!==s.type&&"wildcard"!==s.type){if("{"!==s.type)throw new y(`Unexpected ${s.type} at index ${s.index}, expected ${r}`,e);i.push({type:"group",tokens:t("}")})}else i.push({type:s.type,name:s.value})}return i}("end"),e)}function d(e,t,n){const r=e.map(e=>function r(e,t,n){if("text"===e.type)return()=>[e.value];if("group"===e.type){const r=d(e.tokens,t,n);return e=>{const[t,...n]=r(e);return n.length?[""]:[t]}}const r=n||s;if("wildcard"===e.type&&!1!==n)return n=>{const o=n[e.name];if(null==o)return["",e.name];if(!Array.isArray(o)||0===o.length)throw new TypeError(`Expected "${e.name}" to be a non-empty array`);return[o.map((t,n)=>{if("string"!=typeof t)throw new TypeError(`Expected "${e.name}/${n}" to be a string`);return r(t)}).join(t)]};return t=>{const n=t[e.name];if(null==n)return["",e.name];if("string"!=typeof n)throw new TypeError(`Expected "${e.name}" to be a string`);return[r(n)]}}(e,t,n));return e=>{const t=[""];for(const n of r){const[r,...o]=n(e);t[0]+=r,t.push(...o)}return t}}function g(e,t={}){const{delimiter:n=i,end:r=!0,sensitive:o=!1,trailing:s=!0}=t,p=[],a=o?"":"i",u=[];for(const r of m(e,[])){const e="object"==typeof r?r:h(r,t);for(const t of $(e.tokens,0,[]))u.push(x(t,n,p,e.originalPath))}let c=`^(?:${u.join("|")})`;s&&(c+=`(?:${f(n)}$)?`),c+=r?"$":`(?=${f(n)}|$)`;const l=new RegExp(c,a);return{regexp:l,keys:p}}function m(e,t){if(Array.isArray(e))for(const n of e)m(n,t);else t.push(e);return t}function*$(e,t,n){if(t===e.length)return yield n;const r=e[t];if("group"===r.type)for(const o of $(r.tokens,0,n.slice()))yield*$(e,t+1,o);else n.push(r);yield*$(e,t+1,n)}function x(e,t,n,r){let o="",i="",s=!0;for(const p of e)if("text"!==p.type)if("param"!==p.type&&"wildcard"!==p.type);else{if(!s&&!i)throw new y(`Missing text before "${p.name}" ${p.type}`,r);"param"===p.type?o+=`(${w(t,s?"":i)}+)`:o+="([\\s\\S]+)",n.push(p),i="",s=!1}else o+=f(p.value),i+=p.value,s||(s=p.value.includes(t));return o}function w(e,t){return t.length<2?e.length<2?`[^${f(e+t)}]`:`(?:(?!${f(e)})[^${f(t)}])`:e.length<2?`(?:(?!${f(t)})[^${f(e)}])`:`(?:(?!${f(t)}|${f(e)})[\\s\\S])`}function v(e){let t="",n=0;function r(t){const r=function o(e){const[t,...n]=e;return p.test(t)&&n.every(e=>a.test(e))}(t)&&function i(e){return!e||"text"!==e.type||!a.test(e.value[0])}(e[n]);return r?t:JSON.stringify(t)}for(;n<e.length;){const o=e[n++];if("text"!==o.type)if("group"!==o.type)if("param"!==o.type){if("wildcard"!==o.type)throw new TypeError(`Unknown token type: ${o.type}`);t+=`*${r(o.name)}`}else t+=`:${r(o.name)}`;else t+=`{${v(o.tokens)}}`;else t+=c(o.value)}return t}return n.PathError=y,n}();const i={TokenData:r.TokenData,PathError:r.PathError,parse:r.parse,compile:r.compile,match:r.match,stringify:r.stringify,pathToRegexp:r.pathToRegexp};e.path2regexp=i,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})});
//# sourceMappingURL=extension-path2regexp.min.map