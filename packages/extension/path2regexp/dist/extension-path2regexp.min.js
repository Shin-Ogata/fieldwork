/*!
 * @cdp/extension-path2regexp 0.9.18
 *   extension for conversion path to regexp library
 */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):(e="undefined"!=typeof globalThis?globalThis:e||self,t((e.CDP=e.CDP||{},e.CDP.Exension=e.CDP.Exension||{})))}(this,(function(e){"use strict";var t,n={};var r=function o(){if(t)return n;t=1,Object.defineProperty(n,"__esModule",{value:!0}),n.TokenData=void 0,n.parse=m,n.compile=function e(t,n={}){const r=t instanceof c?t:m(t,n);return function o(e,t){const{encode:n=encodeURIComponent,loose:r=!0,validate:o=!0,strict:i=!1}=t,u=y(t),a=h(r,e.delimiter),p=x(e,a,[],u,i),f=e.tokens.map(((e,t)=>{const r=function i(e,t){if("string"==typeof e)return()=>e;const n=t||s,r="+"===e.modifier||"*"===e.modifier,o="?"===e.modifier||"*"===e.modifier,{prefix:i="",suffix:u="",separator:a=u+i}=e;if(t&&r){const t=(t,r)=>{if("string"!=typeof t)throw new TypeError(`Expected "${e.name}/${r}" to be a string`);return n(t)},r=n=>{if(!Array.isArray(n))throw new TypeError(`Expected "${e.name}" to be an array`);return 0===n.length?"":i+n.map(t).join(a)+u};return o?t=>{const n=t[e.name];return null==n?"":n.length?r(n):""}:t=>{const n=t[e.name];return r(n)}}const p=t=>{if("string"!=typeof t)throw new TypeError(`Expected "${e.name}" to be a string`);return i+n(t)+u};if(o)return t=>{const n=t[e.name];return null==n?"":p(n)};return t=>{const n=t[e.name];return p(n)}}(e,n);if(!o||"string"==typeof e)return r;const a=new RegExp(`^${p[t]}$`,u);return t=>{const n=r(t);if(!a.test(n))throw new TypeError(`Invalid value for "${e.name}": ${JSON.stringify(n)}`);return n}}));return function e(t={}){let e="";for(const n of f)e+=n(t);return e}}(r,n)},n.match=function r(e,t={}){const{decode:n=decodeURIComponent,loose:r=!0}=t,o=e instanceof c?e:m(e,t),i=h(r,o.delimiter),u=[],a=$(o,u,t),p=u.map((e=>{if(n&&("+"===e.modifier||"*"===e.modifier)){const{prefix:t="",suffix:r="",separator:o=r+t}=e,s=new RegExp(i(o),"g");return e=>e.split(s).map(n)}return n||s}));return function e(t){const n=a.exec(t);if(!n)return!1;const{0:r,index:o}=n,i=Object.create(null);for(let e=1;e<n.length;e++){if(void 0===n[e])continue;const t=u[e-1],r=p[e-1];i[t.name]=r(n[e])}return{path:r,index:o,params:i}}},n.pathToRegexp=function o(e,t={}){const n=e instanceof c?e:m(e,t),r=[],o=$(n,r,t);return Object.assign(o,{keys:r})};const i="/",s=e=>e,u=/^\p{XID_Continue}$/u,a="https://git.new/pathToRegexpError",p={"!":"!","@":"@",";":";",",":",","*":"*","+":"+","?":"?","{":"{","}":"}"};class f{constructor(e){this.tokens=e,this.index=0}peek(){return this.tokens[this.index]}tryConsume(e){const t=this.peek();if(t.type===e)return this.index++,t.value}consume(e){const t=this.tryConsume(e);if(void 0!==t)return t;const{type:n,index:r}=this.peek();throw new TypeError(`Unexpected ${n} at ${r}, expected ${e}: ${a}`)}text(){let e,t="";for(;e=this.tryConsume("CHAR")||this.tryConsume("ESCAPED");)t+=e;return t}modifier(){return this.tryConsume("?")||this.tryConsume("*")||this.tryConsume("+")}}class c{constructor(e,t){this.tokens=e,this.delimiter=t}}function m(e,t={}){const{encodePath:n=s,delimiter:r=n(i)}=t,o=[],m=function d(e){const t=[...e],n=[];let r=0;for(;r<t.length;){const e=t[r],o=p[e];if(o)n.push({type:o,index:r++,value:e});else if("\\"!==e)if(":"!==e)if("("!==e)n.push({type:"CHAR",index:r,value:t[r++]});else{const e=r++;let o=1,i="";if("?"===t[r])throw new TypeError(`Pattern cannot start with "?" at ${r}`);for(;r<t.length;)if("\\"!==t[r]){if(")"===t[r]){if(o--,0===o){r++;break}}else if("("===t[r]&&(o++,"?"!==t[r+1]))throw new TypeError(`Capturing groups are not allowed at ${r}`);i+=t[r++]}else i+=t[r++]+t[r++];if(o)throw new TypeError(`Unbalanced pattern at ${e}`);if(!i)throw new TypeError(`Missing pattern at ${e}`);n.push({type:"PATTERN",index:r,value:i})}else{let e="";for(;u.test(t[++r]);)e+=t[r];if(!e)throw new TypeError(`Missing parameter name at ${r}`);n.push({type:"NAME",index:r,value:e})}else n.push({type:"ESCAPED",index:r++,value:t[r++]})}return n.push({type:"END",index:r,value:""}),new f(n)}(e);let h=0;for(;;){{const e=m.text();e&&o.push(n(e));const t=m.tryConsume("NAME"),i=m.tryConsume("PATTERN");if(t||i){o.push({name:t||String(h++),pattern:i});const e=m.peek();if("*"===e.type)throw new TypeError(`Unexpected * at ${e.index}, you probably want \`/*\` or \`{/:foo}*\`: ${a}`);continue}const s=m.tryConsume("*");if(s){o.push({name:String(h++),pattern:`(?:(?!${l(r)}).)*`,modifier:"*",separator:r});continue}const u=m.tryConsume("{");if(!u){m.consume("END");break}{const e=m.text(),t=m.tryConsume("NAME"),r=m.tryConsume("PATTERN"),i=m.text(),s=m.tryConsume(";")&&m.text();m.consume("}");const u=m.modifier();o.push({name:t||(r?String(h++):""),prefix:n(e),suffix:n(i),pattern:r,modifier:u,separator:s})}}1}return new c(o,r)}function l(e){return e.replace(/([.+*?^${}()[\]|/\\])/g,"\\$1")}function d(e,t){const n=l(e);return t?`(?:${n})+(?!${n})`:n}function h(e,t){if(!e)return l;const n=new RegExp(`(?:(?!${l(t)}).)+|(.)`,"g");return e=>e.replace(n,d)}function y(e){return e.sensitive?"":"i"}function $(e,t,n){const{trailing:r=!0,loose:o=!0,start:i=!0,end:s=!0,strict:u=!1}=n,a=y(n),p=h(o,e.delimiter),f=x(e,p,t,a,u);let c=i?"^":"";return c+=f.join(""),r&&(c+=`(?:${p(e.delimiter)})?`),c+=s?"$":`(?=${l(e.delimiter)}|$)`,new RegExp(c,a)}function x(e,t,n,r,o){const i=`(?:(?!${l(e.delimiter)}).)+?`;let s="",u=!0;return e.tokens.map(((e,p)=>{if("string"==typeof e)return s=e,t(e);const{prefix:f="",suffix:c="",separator:m=c+f,modifier:l=""}=e,d=t(f),h=t(c);if(e.name){const p=e.pattern?`(?:${e.pattern})`:i,y=function $(e,t,n){try{return new RegExp(`^${e}$`,n)}catch(e){throw new TypeError(`Invalid pattern for "${t}": ${e.message}`)}}(p,e.name,r);if(u||(u=g(y,f||s)),!u)throw new TypeError(`Ambiguous pattern for "${e.name}": ${a}`);if(u=!o||g(y,c),s="",n.push(e),"+"===l||"*"===l){const n="*"===l?"?":"",r=t(m);if(!r)throw new TypeError(`Missing separator for "${e.name}": ${a}`);if(u||(u=!o||g(y,m)),!u)throw new TypeError(`Ambiguous pattern for "${e.name}" separator: ${a}`);return u=!o,`(?:${d}(${p}(?:${r}${p})*)${h})${n}`}return`(?:${d}(${p})${h})${l}`}return`(?:${d}${h})${l}`}))}function g(e,t){return!!t&&!e.test(t)}return n.TokenData=c,n}();const i={parse:r.parse,compile:r.compile,match:r.match,pathToRegexp:r.pathToRegexp};e.path2regexp=i,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
//# sourceMappingURL=extension-path2regexp.min.map