/*!
 * @cdp/extension-path2regexp 0.9.18
 *   extension for conversion path to regexp library
 */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):(e="undefined"!=typeof globalThis?globalThis:e||self,t((e.CDP=e.CDP||{},e.CDP.Exension=e.CDP.Exension||{})))}(this,(function(e){"use strict";var t={};Object.defineProperty(t,"__esModule",{value:!0});var n=t.pathToRegexp=t.match=t.compile=t.parse=t.TokenData=void 0;const r="/",o=e=>e,i=/^\p{XID_Continue}$/u,s={"!":"!","@":"@",";":";",",":",","*":"*","+":"+","?":"?","{":"{","}":"}"};class u{constructor(e){this.tokens=e,this.index=0}peek(){return this.tokens[this.index]}tryConsume(e){const t=this.peek();if(t.type===e)return this.index++,t.value}consume(e){const t=this.tryConsume(e);if(void 0!==t)return t;const{type:n,index:r}=this.peek();throw new TypeError(`Unexpected ${n} at ${r}, expected ${e}: https://git.new/pathToRegexpError`)}text(){let e,t="";for(;e=this.tryConsume("CHAR")||this.tryConsume("ESCAPED");)t+=e;return t}modifier(){return this.tryConsume("?")||this.tryConsume("*")||this.tryConsume("+")||""}}class a{constructor(e,t){this.tokens=e,this.delimiter=t}}function p(e,t={}){const{delimiter:n=r,encodePath:p=o}=t,f=[],c=function m(e){const t=[...e],n=[];let r=0;for(;r<t.length;){const e=t[r],o=s[e];if(o)n.push({type:o,index:r++,value:e});else if("\\"!==e)if(":"!==e)if("("!==e)n.push({type:"CHAR",index:r,value:t[r++]});else{const e=r++;let o=1,i="";if("?"===t[r])throw new TypeError(`Pattern cannot start with "?" at ${r}`);for(;r<t.length;)if("\\"!==t[r]){if(")"===t[r]){if(o--,0===o){r++;break}}else if("("===t[r]&&(o++,"?"!==t[r+1]))throw new TypeError(`Capturing groups are not allowed at ${r}`);i+=t[r++]}else i+=t[r++]+t[r++];if(o)throw new TypeError(`Unbalanced pattern at ${e}`);if(!i)throw new TypeError(`Missing pattern at ${e}`);n.push({type:"PATTERN",index:r,value:i})}else{let e="";for(;i.test(t[++r]);)e+=t[r];if(!e)throw new TypeError(`Missing parameter name at ${r}`);n.push({type:"NAME",index:r,value:e})}else n.push({type:"ESCAPED",index:r++,value:t[r++]})}return n.push({type:"END",index:r,value:""}),new u(n)}(e);let l=0;for(;;){{const e=c.text();e&&f.push(p(e));const t=c.tryConsume("NAME"),r=c.tryConsume("PATTERN");if(t||r){f.push({name:t||String(l++),pattern:r});const e=c.peek();if("*"===e.type)throw new TypeError(`Unexpected * at ${e.index}, you probably want \`/*\` or \`{/:foo}*\`: https://git.new/pathToRegexpError`);continue}const o=c.tryConsume("*");if(o){f.push({name:String(l++),pattern:`[^${h(n)}]*`,modifier:"*",separator:n});continue}const i=c.tryConsume("{");if(!i){c.consume("END");break}{const e=c.text(),t=c.tryConsume("NAME"),n=c.tryConsume("PATTERN"),r=c.text(),o=c.tryConsume(";")?c.text():e+r;c.consume("}");const i=c.modifier();f.push({name:t||(n?String(l++):""),prefix:p(e),suffix:p(r),pattern:n,modifier:i,separator:o})}}1}return new a(f,n)}t.TokenData=a;var f=t.parse=p;var c=t.compile=function m(e,t={}){const n=e instanceof a?e:p(e,t);return function r(e,t){const{encode:n=encodeURIComponent,loose:r=!0,validate:i=!0}=t,s=g(t),u=x(r,e.delimiter),a=E(u,e.delimiter),p=e.tokens.map((e=>{const t=function r(e,t){if("string"==typeof e)return()=>e;const n=t||o,r="+"===e.modifier||"*"===e.modifier,i="?"===e.modifier||"*"===e.modifier,{prefix:s="",suffix:u="",separator:a=""}=e;if(t&&r){const t=(t,r)=>{if("string"!=typeof t)throw new TypeError(`Expected "${e.name}/${r}" to be a string`);return n(t)},r=n=>{if(!Array.isArray(n))throw new TypeError(`Expected "${e.name}" to be an array`);return 0===n.length?"":s+n.map(t).join(a)+u};return i?t=>{const n=t[e.name];return null==n?"":n.length?r(n):""}:t=>{const n=t[e.name];return r(n)}}const p=t=>{if("string"!=typeof t)throw new TypeError(`Expected "${e.name}" to be a string`);return s+n(t)+u};if(i)return t=>{const n=t[e.name];return null==n?"":p(n)};return t=>{const n=t[e.name];return p(n)}}(e,n);if(!i||"string"==typeof e)return t;const u=a(e),p=new RegExp(`^${u}$`,s);return n=>{const r=t(n);if(!p.test(r))throw new TypeError(`Invalid value for "${e.name}": ${JSON.stringify(r)}`);return r}}));return function e(t={}){let e="";for(const n of p)e+=n(t);return e}}(n,t)};var l=t.match=function d(e,t={}){const{decode:n=decodeURIComponent,loose:r=!0}=t,i=e instanceof a?e:p(e,t),s=x(r,i.delimiter),u=[],f=$(i,u,t),c=u.map((e=>{if(n&&("+"===e.modifier||"*"===e.modifier)){const t=new RegExp(s(e.separator||""),"g");return e=>e.split(t).map(n)}return n||o}));return function e(t){const n=f.exec(t);if(!n)return!1;const{0:r,index:o}=n,i=Object.create(null);for(let e=1;e<n.length;e++){if(void 0===n[e])continue;const t=u[e-1],r=c[e-1];i[t.name]=r(n[e])}return{path:r,index:o,params:i}}};function h(e){return e.replace(/([.+*?=^!:${}()[\]|/\\])/g,"\\$1")}function y(e,t){return t?`${h(e)}+`:h(e)}function x(e,t){if(!e)return h;const n=new RegExp(`[^${h(t)}]+|(.)`,"g");return e=>e.replace(n,y)}function g(e){return e.sensitive?"":"i"}function $(e,t,n){const{trailing:r=!0,start:o=!0,end:i=!0,loose:s=!0}=n,u=x(s,e.delimiter),a=E(u,e.delimiter);let p=o?"^":"";for(const n of e.tokens)"string"==typeof n?p+=u(n):(n.name&&t.push(n),p+=a(n));return r&&(p+=`(?:${u(e.delimiter)})?`),p+=i?"$":`(?=${h(e.delimiter)}|$)`,new RegExp(p,g(n))}function E(e,t){const n=`[^${h(t)}]+?`;return t=>{const r=t.prefix?e(t.prefix):"",o=t.suffix?e(t.suffix):"",i=t.modifier||"";if(t.name){const s=t.pattern||n;if("+"===t.modifier||"*"===t.modifier){const n="*"===t.modifier?"?":"",i=t.separator?e(t.separator):"";return`(?:${r}((?:${s})(?:${i}(?:${s}))*)${o})${n}`}return`(?:${r}(${s})${o})${i}`}return`(?:${r}${o})${i}`}}n=t.pathToRegexp=function w(e,t={}){const n=e instanceof a?e:p(e,t),r=[],o=$(n,r,t);return Object.assign(o,{keys:r})};const T={parse:f,compile:c,match:l,pathToRegexp:n};e.path2regexp=T,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
//# sourceMappingURL=extension-path2regexp.min.map