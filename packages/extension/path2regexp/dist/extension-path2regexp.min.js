/*!
 * @cdp/extension-path2regexp 0.9.18
 *   extension for conversion path to regexp library
 */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):(e="undefined"!=typeof globalThis?globalThis:e||self,t((e.CDP=e.CDP||{},e.CDP.Exension=e.CDP.Exension||{})))}(this,(function(e){"use strict";var t={};Object.defineProperty(t,"__esModule",{value:!0}),t.TokenData=void 0;var n=t.parse=y,r=t.compile=function o(e,t={}){const n=e instanceof h?e:y(e,t);return function r(e,t){const{encode:n=encodeURIComponent,loose:r=!0,validate:o=!0,strict:i=!1}=t,s=w(t),u=g(r,e.delimiter),a=T(e,u,[],s,i),p=e.tokens.map(((e,t)=>{const r=function i(e,t){if("string"==typeof e)return()=>e;const n=t||f,r="+"===e.modifier||"*"===e.modifier,o="?"===e.modifier||"*"===e.modifier,{prefix:i="",suffix:s="",separator:u=s+i}=e;if(t&&r){const t=(t,r)=>{if("string"!=typeof t)throw new TypeError(`Expected "${e.name}/${r}" to be a string`);return n(t)},r=n=>{if(!Array.isArray(n))throw new TypeError(`Expected "${e.name}" to be an array`);return 0===n.length?"":i+n.map(t).join(u)+s};return o?t=>{const n=t[e.name];return null==n?"":n.length?r(n):""}:t=>{const n=t[e.name];return r(n)}}const a=t=>{if("string"!=typeof t)throw new TypeError(`Expected "${e.name}" to be a string`);return i+n(t)+s};if(o)return t=>{const n=t[e.name];return null==n?"":a(n)};return t=>{const n=t[e.name];return a(n)}}(e,n);if(!o||"string"==typeof e)return r;const u=new RegExp(`^${a[t]}$`,s);return t=>{const n=r(t);if(!u.test(n))throw new TypeError(`Invalid value for "${e.name}": ${JSON.stringify(n)}`);return n}}));return function e(t={}){let e="";for(const n of p)e+=n(t);return e}}(n,t)},i=t.match=function s(e,t={}){const{decode:n=decodeURIComponent,loose:r=!0}=t,o=e instanceof h?e:y(e,t),i=g(r,o.delimiter),s=[],u=E(o,s,t),a=s.map((e=>{if(n&&("+"===e.modifier||"*"===e.modifier)){const{prefix:t="",suffix:r="",separator:o=r+t}=e,s=new RegExp(i(o),"g");return e=>e.split(s).map(n)}return n||f}));return function e(t){const n=u.exec(t);if(!n)return!1;const{0:r,index:o}=n,i=Object.create(null);for(let e=1;e<n.length;e++){if(void 0===n[e])continue;const t=s[e-1],r=a[e-1];i[t.name]=r(n[e])}return{path:r,index:o,params:i}}},u=t.pathToRegexp=function a(e,t={}){const n=e instanceof h?e:y(e,t),r=[],o=E(n,r,t);return Object.assign(o,{keys:r})};const p="/",f=e=>e,c=/^\p{XID_Continue}$/u,m="https://git.new/pathToRegexpError",l={"!":"!","@":"@",";":";",",":",","*":"*","+":"+","?":"?","{":"{","}":"}"};class d{constructor(e){this.tokens=e,this.index=0}peek(){return this.tokens[this.index]}tryConsume(e){const t=this.peek();if(t.type===e)return this.index++,t.value}consume(e){const t=this.tryConsume(e);if(void 0!==t)return t;const{type:n,index:r}=this.peek();throw new TypeError(`Unexpected ${n} at ${r}, expected ${e}: ${m}`)}text(){let e,t="";for(;e=this.tryConsume("CHAR")||this.tryConsume("ESCAPED");)t+=e;return t}modifier(){return this.tryConsume("?")||this.tryConsume("*")||this.tryConsume("+")}}class h{constructor(e,t){this.tokens=e,this.delimiter=t}}function y(e,t={}){const{encodePath:n=f,delimiter:r=n(p)}=t,o=[],i=function s(e){const t=[...e],n=[];let r=0;for(;r<t.length;){const e=t[r],o=l[e];if(o)n.push({type:o,index:r++,value:e});else if("\\"!==e)if(":"!==e)if("("!==e)n.push({type:"CHAR",index:r,value:t[r++]});else{const e=r++;let o=1,i="";if("?"===t[r])throw new TypeError(`Pattern cannot start with "?" at ${r}`);for(;r<t.length;)if("\\"!==t[r]){if(")"===t[r]){if(o--,0===o){r++;break}}else if("("===t[r]&&(o++,"?"!==t[r+1]))throw new TypeError(`Capturing groups are not allowed at ${r}`);i+=t[r++]}else i+=t[r++]+t[r++];if(o)throw new TypeError(`Unbalanced pattern at ${e}`);if(!i)throw new TypeError(`Missing pattern at ${e}`);n.push({type:"PATTERN",index:r,value:i})}else{let e="";for(;c.test(t[++r]);)e+=t[r];if(!e)throw new TypeError(`Missing parameter name at ${r}`);n.push({type:"NAME",index:r,value:e})}else n.push({type:"ESCAPED",index:r++,value:t[r++]})}return n.push({type:"END",index:r,value:""}),new d(n)}(e);let u=0;for(;;){{const e=i.text();e&&o.push(n(e));const t=i.tryConsume("NAME"),s=i.tryConsume("PATTERN");if(t||s){o.push({name:t||String(u++),pattern:s});const e=i.peek();if("*"===e.type)throw new TypeError(`Unexpected * at ${e.index}, you probably want \`/*\` or \`{/:foo}*\`: ${m}`);continue}const a=i.tryConsume("*");if(a){o.push({name:String(u++),pattern:`(?:(?!${$(r)}).)*`,modifier:"*",separator:r});continue}const p=i.tryConsume("{");if(!p){i.consume("END");break}{const e=i.text(),t=i.tryConsume("NAME"),r=i.tryConsume("PATTERN"),s=i.text(),a=i.tryConsume(";")&&i.text();i.consume("}");const p=i.modifier();o.push({name:t||(r?String(u++):""),prefix:n(e),suffix:n(s),pattern:r,modifier:p,separator:a})}}1}return new h(o,r)}function $(e){return e.replace(/([.+*?^${}()[\]|/\\])/g,"\\$1")}function x(e,t){const n=$(e);return t?`(?:${n})+(?!${n})`:n}function g(e,t){if(!e)return $;const n=new RegExp(`(?:(?!${$(t)}).)+|(.)`,"g");return e=>e.replace(n,x)}function w(e){return e.sensitive?"":"i"}function E(e,t,n){const{trailing:r=!0,loose:o=!0,start:i=!0,end:s=!0,strict:u=!1}=n,a=w(n),p=g(o,e.delimiter),f=T(e,p,t,a,u);let c=i?"^":"";return c+=f.join(""),r&&(c+=`(?:${p(e.delimiter)})?`),c+=s?"$":`(?=${$(e.delimiter)}|$)`,new RegExp(c,a)}function T(e,t,n,r,o){const i=`(?:(?!${$(e.delimiter)}).)+?`;let s="",u=!0;return e.tokens.map(((e,a)=>{if("string"==typeof e)return s=e,t(e);const{prefix:p="",suffix:f="",separator:c=f+p,modifier:l=""}=e,d=t(p),h=t(f);if(e.name){const a=e.pattern?`(?:${e.pattern})`:i,y=function $(e,t,n){try{return new RegExp(`^${e}$`,n)}catch(e){throw new TypeError(`Invalid pattern for "${t}": ${e.message}`)}}(a,e.name,r);if(u||(u=C(y,p||s)),!u)throw new TypeError(`Ambiguous pattern for "${e.name}": ${m}`);if(u=!o||C(y,f),s="",n.push(e),"+"===l||"*"===l){const n="*"===l?"?":"",r=t(c);if(!r)throw new TypeError(`Missing separator for "${e.name}": ${m}`);if(u||(u=!o||C(y,c)),!u)throw new TypeError(`Ambiguous pattern for "${e.name}" separator: ${m}`);return u=!o,`(?:${d}(${a}(?:${r}${a})*)${h})${n}`}return`(?:${d}(${a})${h})${l}`}return`(?:${d}${h})${l}`}))}function C(e,t){return!!t&&!e.test(t)}t.TokenData=h;const v={parse:n,compile:r,match:i,pathToRegexp:u};e.path2regexp=v,Object.defineProperty(e,Symbol.toStringTag,{value:"Module"})}));
//# sourceMappingURL=extension-path2regexp.min.map