/*!
 * @cdp/lib-core 0.9.18
 *   Generated by 'cdp-task bundle dts' task.
 *   - built with TypeScript 5.4.3
 *   - includes:
 *     - @cdp/core-utils
 *     - @cdp/core-template
 *     - @cdp/result
 *     - @cdp/events
 *     - @cdp/promise
 *     - @cdp/observable
 *     - @cdp/core-storage
 */
/**
 * @en Primitive type of JavaScript.
 * @ja JavaScript のプリミティブ型
 */
export type Primitive = string | number | boolean | symbol | bigint | null | undefined;
/**
 * @en The general null type.
 * @ja 空を示す型定義
 */
export type Nullish = void | null | undefined;
/**
 * @en The type of object or {@link Nullish}.
 * @ja {@link Nullish} になりえるオブジェクト型定義
 */
export type Nullable<T extends object> = T | Nullish;
/**
 * @en Avoid the `Function`types.
 * @ja 汎用関数型
 */
export type UnknownFunction = (...args: unknown[]) => unknown;
/**
 * @en Avoid the `Object` and `{}` types, as they mean 'any non-nullish value'.
 * @ja 汎用オブジェクト型. `Object` および `{}` タイプは「nullでない値」を意味するため代価として使用
 */
export type UnknownObject = Record<string | number | symbol, unknown>;
/**
 * @en JavaScript type set interface.
 * @ja JavaScript の型の集合
 */
export interface TypeList {
    string: string;
    number: number;
    boolean: boolean;
    symbol: symbol;
    bigint: bigint;
    undefined: void | undefined;
    object: object | null;
    function(...args: unknown[]): unknown;
}
/**
 * @en The key list of {@link TypeList}.
 * @ja {@link TypeList} キー一覧
 */
export type TypeKeys = keyof TypeList;
/**
 * @en Type base definition.
 * @ja 型の規定定義
 */
export interface Type<T extends object> extends Function {
    readonly prototype: T;
}
/**
 * @en Type of constructor.
 * @ja コンストラクタ型
 */
export interface Constructor<T extends object> extends Type<T> {
    new (...args: any[]): T;
}
/**
 * @en Type of class.
 * @ja クラス型
 */
export type Class<T extends object = object> = Constructor<T>;
/**
 * @en Ensure for function parameters to tuple.
 * @ja 関数パラメータとして tuple を保証
 */
export type Arguments<T> = T extends any[] ? T : [
    T
];
/**
 * @en Rmove `readonly` attributes from input type.
 * @ja `readonly` 属性を解除
 */
export type Writable<T> = {
    -readonly [K in keyof T]: T[K];
};
/**
 * @en Convert to subscript accessible type.
 * @ja 添え字アクセス可能な型に変換
 */
export type Accessible<T, S = unknown> = T & Record<string | number | symbol, S>;
/**
 * @en Extract functional property names.
 * @ja 関数プロパティ名の抽出
 */
export type FunctionPropertyNames<T> = {
    [K in keyof T]: T[K] extends Function ? K : never;
}[keyof T] & string;
/**
 * @en Extract functional properties.
 * @ja 関数プロパティの抽出
 */
export type FunctionProperties<T> = Pick<T, FunctionPropertyNames<T>>;
/**
 * @en Extract non-functional property names.
 * @ja 非関数プロパティ名の抽出
 */
export type NonFunctionPropertyNames<T> = {
    [K in keyof T]: T[K] extends Function ? never : K;
}[keyof T] & string;
/**
 * @en Extract non-functional properties.
 * @ja 非関数プロパティの抽出
 */
export type NonFunctionProperties<T> = Pick<T, NonFunctionPropertyNames<T>>;
/**
 * @en Extract non-functional types.
 * @ja 非関数型の抽出
 */
export type NonFunction<T> = T extends Function ? never : T;
/**
 * @en Extract object key list. (ensure only 'string')
 * @ja オブジェクトのキー一覧を抽出 ('string' 型のみを保証)
 */
export type Keys<T extends object> = keyof Omit<T, number | symbol>;
/**
 * @en Extract object type list.
 * @ja オブジェクトの型一覧を抽出
 */
export type Types<T extends object> = T[keyof T];
/**
 * @en Convert object key to type.
 * @ja オブジェクトキーから型へ変換
 */
export type KeyToType<O extends object, K extends keyof O> = K extends keyof O ? O[K] : never;
/**
 * @en Convert object type to key.
 * @ja オブジェクト型からキーへ変換
 */
export type TypeToKey<O extends object, T extends Types<O>> = {
    [K in keyof O]: O[K] extends T ? K : never;
}[keyof O];
/**
 * @en The {@link PlainObject} type is a JavaScript object containing zero or more key-value pairs. <br>
 *     'Plain' means it from other kinds of JavaScript objects. ex: null, user-defined arrays, and host objects such as `document`.
 * @ja 0 以上の key-value ペアを持つ {@link PlainObject} 定義 <br>
 *     'Plain' とは他の種類の JavaScript オブジェクトを含まないオブジェクトを意味する. 例:  null, ユーザー定義配列, または `document` のような組み込みオブジェクト
 */
export type PlainObject<T = {} | null | undefined> = Record<string, T>;
/**
 * @en Object can be guaranteed definition. Be careful not to abuse it because it does not force the cast.
 *   - Unlike {@link PlainObject}, it can accept Class (built-in object), Array, Function.
 *   - Unlike `object`, you can access unknown properties.
 *   - Unlike `{} / Object`, it can repel {@link Primitive}.
 * @ja Object を保証可能な定義. キャストを強制しないため乱用しないように注意が必要.
 *   - {@link PlainObject} と違い、Class (組み込みオブジェクト), Array, Function を受け付けることができる.
 *   - `object` と違い、未知のプロパティにアクセスすることができる.
 *   - `{} / Object` と違い、{@link Primitive} をはじくことができる.
 */
export type AnyObject = Record<string, any>;
/**
 * @en The data type list by which style compulsion is possible.
 * @ja 型強制可能なデータ型一覧
 */
export type TypedData = string | number | boolean | null | object;
/**
 * @en The data type list of TypedArray.
 * @ja TypedArray 一覧
 */
export type TypedArray = Int8Array | Uint8Array | Uint8ClampedArray | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array;
/**
 * @en TypedArray constructor.
 * @ja TypedArray コンストラクタ定義
 */
export interface TypedArrayConstructor {
    readonly prototype: TypedArray;
    new (seed: number | ArrayLike<number> | ArrayBufferLike): TypedArray;
    new (buffer: ArrayBufferLike, byteOffset?: number, length?: number): TypedArray;
    /**
     * @en The size in bytes of each element in the array.
     * @ja 要素のバイトサイズ
     */
    readonly BYTES_PER_ELEMENT: number;
    /**
     * @en Returns a new array from a set of elements.
     * @ja 要素を設定し新規配列を返却
     *
     * @param items
     *  - `en` A set of elements to include in the new array object.
     *  - `ja` 新たに設定する要素
     */
    of(...items: number[]): TypedArray;
    /**
     * @en Creates an array from an array-like or iterable object.
     * @ja array-like / iteratable オブジェクトから新規配列を作成
     *
     * @param arrayLike
     *  - `en` An array-like or iterable object to convert to an array.
     *  - `ja` array-like もしくは iteratable オブジェクト
     */
    from(arrayLike: ArrayLike<number>): TypedArray;
    /**
     * @en Creates an array from an array-like or iterable object.
     * @ja array-like / iteratable オブジェクトから新規配列を作成
     *
     * @param arrayLike
     *  - `en` An array-like or iterable object to convert to an array.
     *  - `ja` array-like もしくは iteratable オブジェクト
     * @param mapfn
     *  - `en` A mapping function to call on every element of the array.
     *  - `ja` 全要素に適用するプロキシ関数
     * @param thisArg
     *  - `en` Value of 'this' used to invoke the mapfn.
     *  - `ja` mapfn に使用する 'this'
     */
    from<T>(arrayLike: ArrayLike<T>, mapfn: (v: T, k: number) => number, thisArg?: unknown): TypedArray;
}
/**
 * @en Check the value exists.
 * @ja 値が存在するか判定
 *
 * @param x
 *  - `en` evaluated value
 *  - `ja` 評価する値
 */
export declare function exists<T>(x: T | Nullish): x is T;
/**
 * @en Check the value-type is {@link Nullish}.
 * @ja {@link Nullish} 型であるか判定
 *
 * @param x
 *  - `en` evaluated value
 *  - `ja` 評価する値
 */
export declare function isNullish(x: unknown): x is Nullish;
/**
 * @en Check the value-type is String.
 * @ja String 型であるか判定
 *
 * @param x
 *  - `en` evaluated value
 *  - `ja` 評価する値
 */
export declare function isString(x: unknown): x is string;
/**
 * @en Check the value-type is Number.
 * @ja Number 型であるか判定
 *
 * @param x
 *  - `en` evaluated value
 *  - `ja` 評価する値
 */
export declare function isNumber(x: unknown): x is number;
/**
 * @en Check the value-type is Boolean.
 * @ja Boolean 型であるか判定
 *
 * @param x
 *  - `en` evaluated value
 *  - `ja` 評価する値
 */
export declare function isBoolean(x: unknown): x is boolean;
/**
 * @en Check the value-type is Symble.
 * @ja Symbol 型であるか判定
 *
 * @param x
 *  - `en` evaluated value
 *  - `ja` 評価する値
 */
export declare function isSymbol(x: unknown): x is symbol;
/**
 * @en Check the value-type is BigInt.
 * @ja BigInt 型であるか判定
 *
 * @param x
 *  - `en` evaluated value
 *  - `ja` 評価する値
 */
export declare function isBigInt(x: unknown): x is bigint;
/**
 * @en Check the value-type is primitive type.
 * @ja プリミティブ型であるか判定
 *
 * @param x
 *  - `en` evaluated value
 *  - `ja` 評価する値
 */
export declare function isPrimitive(x: unknown): x is Primitive;
/**
 * @en Check the value-type is Array.
 * @ja Array 型であるか判定
 *
 * @param x
 *  - `en` evaluated value
 *  - `ja` 評価する値
 */
export declare const isArray: (arg: any) => arg is any[];
/**
 * @en Check the value-type is Object.
 * @ja Object 型であるか判定
 *
 * @param x
 *  - `en` evaluated value
 *  - `ja` 評価する値
 */
export declare function isObject(x: unknown): x is object;
/**
 * @en Check the value-type is {@link PlainObject}.
 * @ja {@link PlainObject} 型であるか判定
 *
 * @param x
 *  - `en` evaluated value
 *  - `ja` 評価する値
 */
export declare function isPlainObject(x: unknown): x is PlainObject;
/**
 * @en Check the value-type is empty object.
 * @ja 空オブジェクトであるか判定
 *
 * @param x
 *  - `en` evaluated value
 *  - `ja` 評価する値
 */
export declare function isEmptyObject(x: unknown): x is object;
/**
 * @en Check the value-type is Function.
 * @ja Function 型であるか判定
 *
 * @param x
 *  - `en` evaluated value
 *  - `ja` 評価する値
 */
export declare function isFunction(x: unknown): x is TypeList['function'];
/**
 * @en Check the value can be convert to a number.
 * @ja 数値に変換可能か判定
 *
 * @param x
 *  - `en` evaluated value
 *  - `ja` 評価する値
 */
export declare function isNumeric(x: unknown): x is number;
/**
 * @en Check the value-type is input.
 * @ja 指定した型であるか判定
 *
 * @param type
 *  - `en` evaluated type
 *  - `ja` 評価する型
 * @param x
 *  - `en` evaluated value
 *  - `ja` 評価する値
 */
export declare function typeOf<K extends TypeKeys>(type: K, x: unknown): x is TypeList[K];
/**
 * @en Check the value has iterator.
 * @ja iterator を所有しているか判定
 *
 * @param x
 *  - `en` evaluated value
 *  - `ja` 評価する値
 */
export declare function isIterable<T>(x: Nullable<Iterable<T>>): x is Iterable<T>;
export declare function isIterable(x: unknown): x is Iterable<unknown>;
/**
 * @en Check the value is one of {@link TypedArray}.
 * @ja 指定したインスタンスが {@link TypedArray} の一種であるか判定
 *
 * @param x
 *  - `en` evaluated value
 *  - `ja` 評価する値
 */
export declare function isTypedArray(x: unknown): x is TypedArray;
/**
 * @en Check the value instance of input.
 * @ja 指定したインスタンスであるか判定
 *
 * @param ctor
 *  - `en` evaluated constructor
 *  - `ja` 評価するコンストラクタ
 * @param x
 *  - `en` evaluated value
 *  - `ja` 評価する値
 */
export declare function instanceOf<T extends object>(ctor: Nullable<Type<T>>, x: unknown): x is T;
/**
 * @en Check the value instance of input constructor (except sub class).
 * @ja 指定コンストラクタのインスタンスであるか判定 (派生クラスは含めない)
 *
 * @param ctor
 *  - `en` evaluated constructor
 *  - `ja` 評価するコンストラクタ
 * @param x
 *  - `en` evaluated value
 *  - `ja` 評価する値
 */
export declare function ownInstanceOf<T extends object>(ctor: Nullable<Type<T>>, x: unknown): x is T;
/**
 * @en Get the value's class name.
 * @ja クラス名を取得
 *
 * @param x
 *  - `en` evaluated value
 *  - `ja` 評価する値
 */
export declare function className(x: any): string;
/**
 * @en Check input values are same value-type.
 * @ja 入力が同一型であるか判定
 *
 * @param lhs
 *  - `en` evaluated value
 *  - `ja` 評価する値
 * @param rhs
 *  - `en` evaluated value
 *  - `ja` 評価する値
 */
export declare function sameType(lhs: unknown, rhs: unknown): boolean;
/**
 * @en Check input values are same class.
 * @ja 入力が同一クラスであるか判定
 *
 * @param lhs
 *  - `en` evaluated value
 *  - `ja` 評価する値
 * @param rhs
 *  - `en` evaluated value
 *  - `ja` 評価する値
 */
export declare function sameClass(lhs: unknown, rhs: unknown): boolean;
/**
 * @en Common Symble for framework.
 * @ja フレームワークが共通で使用する Symble
 */
export declare const $cdp: unique symbol;
/**
 * @en Safe `global` accessor.
 * @ja `global` アクセッサ
 *
 * @returns
 *  - `en` `global` object of the runtime environment
 *  - `ja` 環境に応じた `global` オブジェクト
 */
export declare function getGlobal(): typeof globalThis;
/**
 * @en Ensure named object as parent's property.
 * @ja 親オブジェクトを指定して, 名前に指定したオブジェクトの存在を保証
 *
 * @param parent
 *  - `en` parent object. If null given, `globalThis` is assigned.
 *  - `ja` 親オブジェクト. null の場合は `globalThis` が使用される
 * @param names
 *  - `en` object name chain for ensure instance.
 *  - `ja` 保証するオブジェクトの名前
 */
export declare function ensureObject<T extends object = UnknownObject>(parent: object | null, ...names: string[]): T;
/**
 * @en Global namespace accessor.
 * @ja グローバルネームスペースアクセッサ
 */
export declare function getGlobalNamespace<T extends object = UnknownObject>(namespace: string): T;
/**
 * @en Global config accessor.
 * @ja グローバルコンフィグアクセッサ
 *
 * @returns default: `CDP.Config`
 */
export declare function getConfig<T extends object = UnknownObject>(namespace?: string, configName?: string): T;
/**
 * @en Type verifier interface definition. <br>
 *     If invalid value received, the method throws `TypeError`.
 * @ja 型検証のインターフェイス定義 <br>
 *     違反した場合は `TypeError` を発生
 *
 *
 */
export interface Verifier {
    /**
     * @en Verification for the input value is not {@link Nullish}.
     * @ja {@link Nullish} でないことを検証
     *
     * @param notNullish.x
     *  - `en` evaluated value
     *  - `ja` 評価する値
     * @param notNullish.message
     *  - `en` custom error message
     *  - `ja` カスタムエラーメッセージ
     */
    notNullish: (x: unknown, message?: string | null) => void | never;
    /**
     * @en Verification for the input is {@link TypeKeys}.
     * @ja 指定した {@link TypeKeys} であるか検証
     *
     * @param typeOf.type
     *  - `en` one of {@link TypeKeys}
     *  - `ja` {@link TypeKeys} を指定
     * @param typeOf.x
     *  - `en` evaluated value
     *  - `ja` 評価する値
     * @param typeOf.message
     *  - `en` custom error message
     *  - `ja` カスタムエラーメッセージ
     */
    typeOf: (type: TypeKeys, x: unknown, message?: string | null) => void | never;
    /**
     * @en Verification for the input value is `Array`.
     * @ja `Array` であるか検証
     *
     * @param array.x
     *  - `en` evaluated value
     *  - `ja` 評価する値
     * @param array.message
     *  - `en` custom error message
     *  - `ja` カスタムエラーメッセージ
     */
    array: (x: unknown, message?: string | null) => void | never;
    /**
     * @en Verification for the input value is `Iterable`.
     * @ja `Iterable` であるか検証
     *
     * @param iterable.x
     *  - `en` evaluated value
     *  - `ja` 評価する値
     * @param iterable.message
     *  - `en` custom error message
     *  - `ja` カスタムエラーメッセージ
     */
    iterable: (x: unknown, message?: string | null) => void | never;
    /**
     * @en Verification for the input instance is equal comparative target constructor.
     * @ja 指定コンストラクタのインスタンスであるか検証
     *
     * @param instanceOf.ctor
     *  - `en` comparative target constructor
     *  - `ja` 比較対象のコンストラクタ
     * @param instanceOf.x
     *  - `en` evaluated value
     *  - `ja` 評価する値
     * @param instanceOf.message
     *  - `en` custom error message
     *  - `ja` カスタムエラーメッセージ
     */
    instanceOf: (ctor: Function, x: unknown, message?: string | null) => void | never;
    /**
     * @en Verification for the input instance has `strictly` comparative target constructor.
     * @ja 指定コンストラクタの厳密一致したインスタンスであるか検証
     *
     * @param ownInstanceOf.ctor
     *  - `en` comparative target constructor
     *  - `ja` 比較対象のコンストラクタ
     * @param ownInstanceOf.x
     *  - `en` evaluated value
     *  - `ja` 評価する値
     * @param ownInstanceOf.message
     *  - `en` custom error message
     *  - `ja` カスタムエラーメッセージ
     */
    ownInstanceOf: (ctor: Function, x: unknown, message?: string | null) => void | never;
    /**
     * @en Verification for the input instance has not `strictly` equal comparative target constructor.
     * @ja 指定コンストラクタを持つインスタンスでないことを検証
     *
     * @param notOwnInstanceOf.ctor
     *  - `en` comparative target constructor
     *  - `ja` 比較対象のコンストラクタ
     * @param notOwnInstanceOf.x
     *  - `en` evaluated value
     *  - `ja` 評価する値
     * @param notOwnInstanceOf.message
     *  - `en` custom error message
     *  - `ja` カスタムエラーメッセージ
     */
    notOwnInstanceOf: (ctor: Function, x: unknown, message?: string | null) => void | never;
    /**
     * @en Verification for the input value has specified property.
     * @ja 指定プロパティを持っているか検証
     *
     * @param hasProperty.prop
     *  - `en` specified property
     *  - `ja` 対象のプロパティ
     * @param hasProperty.x
     *  - `en` evaluated value
     *  - `ja` 評価する値
     * @param hasProperty.message
     *  - `en` custom error message
     *  - `ja` カスタムエラーメッセージ
     */
    hasProperty: (x: unknown, prop: PropertyKey, message?: string | null) => void | never;
    /**
     * @en Verification for the input value has own specified property.
     * @ja 指定プロパティを入力値自身持っているか検証
     *
     * @param hasOwnProperty.prop
     *  - `en` specified property
     *  - `ja` 対象のプロパティ
     * @param hasOwnProperty.x
     *  - `en` evaluated value
     *  - `ja` 評価する値
     * @param hasOwnProperty.message
     *  - `en` custom error message
     *  - `ja` カスタムエラーメッセージ
     */
    hasOwnProperty: (x: unknown, prop: PropertyKey, message?: string | null) => void | never;
}
/**
 * @en List of method for type verify.
 * @ja 型検証が提供するメソッド一覧
 */
export type VerifyMethod = keyof Verifier;
/**
 * @en Verify method.
 * @ja 検証メソッド
 *
 * @param method
 *  - `en` method name which using
 *  - `ja` 使用するメソッド名
 * @param args
 *  - `en` arguments which corresponds to the method name
 *  - `ja` メソッド名に対応する引数
 */
export declare function verify<TMethod extends VerifyMethod>(method: TMethod, ...args: Parameters<Verifier[TMethod]>): void | never;
/**
 * @en Set by specifying key and value for the object. (prototype pollution countermeasure)
 * @ja オブジェクトに key, value を指定して設定 (プロトタイプ汚染対策)
 */
export declare function assignValue(target: UnknownObject, key: string | number | symbol, value: unknown): void;
/**
 * @en Performs a deep comparison between two values to determine if they are equivalent.
 * @ja 2値の詳細比較をし, 等しいかどうか判定
 */
export declare function deepEqual(lhs: unknown, rhs: unknown): boolean;
/**
 * @en Recursively merges own and inherited enumerable string keyed properties of source objects into the destination object.
 * @ja オブジェクトの再帰的マージを実行
 */
export declare function deepMerge<T, S1, S2, S3, S4, S5, S6, S7, S8, S9>(target: T, ...sources: [
    S1,
    S2?,
    S3?,
    S4?,
    S5?,
    S6?,
    S7?,
    S8?,
    S9?,
    ...unknown[]
]): T & S1 & S2 & S3 & S4 & S5 & S6 & S7 & S8 & S9;
export declare function deepMerge<X>(target: unknown, ...sources: unknown[]): X;
/**
 * @en Create deep copy instance of source object.
 * @ja ディープコピーオブジェクトの生成
 *
 * @see https://developer.mozilla.org/en-US/docs/Web/API/structuredClone
 */
export declare function deepCopy<T>(src: T): T;
/**
 * @en Mixin class's base interface.
 * @ja Mixin クラスの基底インターフェイス定義
 */
export declare class MixinClass {
    /**
     * @en call mixin source class's `super()`. <br>
     *     This method should be called from constructor.
     * @ja Mixin クラスの基底インターフェイス定義 <br>
     *     コンストラクタから呼ぶことを想定
     *
     * @param srcClass
     *  - `en` construction target class name. ex) from S1 available
     *  - `ja` コンストラクトするクラス名を指定 ex) S1 から指定可能
     * @param args
     *  - `en` construction parameters
     *  - `ja` コンストラクトに使用する引数
     */
    protected super<T extends Class>(srcClass: T, ...args: ConstructorParameters<T>): this;
    /**
     * @en Check the input class is mixined (excluding own class).
     * @ja 指定クラスが Mixin されているか確認 (自身のクラスは含まれない)
     *
     * @param mixedClass
     *  - `en` set target class constructor
     *  - `ja` 対象クラスのコンストラクタを指定
     */
    isMixedWith<T extends object>(mixedClass: Constructor<T>): boolean;
}
/**
 * @en Mixed sub class constructor definitions.
 * @ja 合成したサブクラスのコンストラクタ定義
 */
export interface MixinConstructor<B extends Class, U extends object> extends Type<U> {
    /**
     * @en constructor
     * @ja コンストラクタ
     *
     * @param args
     *  - `en` base class arguments
     *  - `ja` 基底クラスに指定した引数
     * @returns
     *  - `en` union type of classes when calling {@link mixins}()
     *  - `ja` {@link mixins}() に渡したクラスの集合
     */
    new (...args: ConstructorParameters<B>): U;
}
/**
 * @en Definition of {@link setMixClassAttribute} function's arguments.
 * @ja {@link setMixClassAttribute} の取りうる引数定義
 */
export interface MixClassAttribute {
    /**
     * @en Suppress providing constructor-trap for the mixin source class. In this case, `isMixedWith`, `instanceof` also becomes invalid. (for improving performance)
     * @ja Mixin Source クラスに対して, コンストラクタトラップを抑止. これを指定した場合, `isMixedWith`, `instanceof` も無効になる. (パフォーマンス改善)
     */
    protoExtendsOnly: void;
    /**
     * @en Setup [Symbol.hasInstance] property. <br>
     *     The class designated as a source of {@link mixins}() has [Symbol.hasInstance] property implicitly. <br>
     *     It's used to avoid becoming the behavior `instanceof` doesn't intend when the class is extended from the mixined class the other place.
     * @ja [Symbol.hasInstance] プロパティ設定<br>
     *     {@link mixins}() のソースに指定されたクラスは [Symbol.hasInstance] を暗黙的に備えるため<br>
     *     そのクラスが他で継承されている場合 `instanceof` が意図しない振る舞いとなるのを避けるために使用する.
     */
    instanceOf: ((inst: object) => boolean) | Nullish;
}
/**
 * @en Set the Mixin class attribute.
 * @ja Mixin クラスに対して属性を設定
 *
 * @example <br>
 *
 * ```ts
 * // 'protoExtendOnly'
 * class Base { constructor(a, b) {} };
 * class MixA { };
 * setMixClassAttribute(MixA, 'protoExtendsOnly');  // for improving construction performance
 * class MixB { constructor(c, d) {} };
 *
 * class MixinClass extends mixins(Base, MixA, MixB) {
 *     constructor(a, b, c, d){
 *         // calling `Base` constructor
 *         super(a, b);
 *
 *         // calling Mixin class's constructor
 *         this.super(MixA);        // no affect
 *         this.super(MixB, c, d);
 *     }
 * }
 *
 * const mixed = new MixinClass();
 * console.log(mixed instanceof MixA);    // false
 * console.log(mixed.isMixedWith(MixA));  // false
 *
 * // 'instanceOf'
 * class Base {};
 * class Source {};
 * class MixinClass extends mixins(Base, Source) {};
 *
 * class Other extends Source {};
 *
 * const other = new Other();
 * const mixed = new MixinClass();
 * console.log(other instanceof Source);        // true
 * console.log(other instanceof Other);         // true
 * console.log(mixed instanceof MixinClass);    // true
 * console.log(mixed instanceof Base);          // true
 * console.log(mixed instanceof Source);        // true
 * console.log(mixed instanceof Other);         // true ???
 *
 * setMixClassAttribute(Other, 'instanceOf'); // or setMixClassAttribute(Other, 'instanceOf', null);
 * console.log(other instanceof Source);        // true
 * console.log(other instanceof Other);         // true
 * console.log(mixed instanceof Other);         // false !
 *
 * // [Best Practice] If you declare the derived-class from mixin, you should call the function for avoiding `instanceof` limitation.
 * class DerivedClass extends MixinClass {}
 * setMixClassAttribute(DerivedClass, 'instanceOf');
 * ```
 *
 * @param target
 *  - `en` set target constructor
 *  - `ja` 設定対象のコンストラクタ
 * @param attr
 *  - `en`:
 *    - `protoExtendsOnly`: Suppress providing constructor-trap for the mixin source class. (for improving performance)
 *    - `instanceOf`      : function by using [Symbol.hasInstance] <br>
 *                          Default behaviour is `{ return target.prototype.isPrototypeOf(instance) }`
 *                          If set `null`, delete [Symbol.hasInstance] property.
 *  - `ja`:
 *    - `protoExtendsOnly`: Mixin Source クラスに対して, コンストラクタトラップを抑止 (パフォーマンス改善)
 *    - `instanceOf`      : [Symbol.hasInstance] が使用する関数を指定 <br>
 *                          既定では `{ return target.prototype.isPrototypeOf(instance) }` が使用される
 *                         `null` 指定をすると [Symbol.hasInstance] プロパティを削除する
 */
export declare function setMixClassAttribute<T extends object, U extends keyof MixClassAttribute>(target: Constructor<T>, attr: U, method?: MixClassAttribute[U]): void;
/**
 * @en Mixin function for multiple inheritance. <br>
 *     Resolving type support for maximum 10 classes.
 * @ja 多重継承のための Mixin <br>
 *     最大 10 クラスの型解決をサポート
 *
 * @example <br>
 *
 * ```ts
 * class Base { constructor(a, b) {} };
 * class MixA { constructor(a, b) {} };
 * class MixB { constructor(c, d) {} };
 *
 * class MixinClass extends mixins(Base, MixA, MixB) {
 *     constructor(a, b, c, d){
 *         // calling `Base` constructor
 *         super(a, b);
 *
 *         // calling Mixin class's constructor
 *         this.super(MixA, a, b);
 *         this.super(MixB, c, d);
 *     }
 * }
 * ```
 *
 * @param base
 *  - `en` primary base class. super(args) is this class's one.
 *  - `ja` 基底クラスコンストラクタ. 同名プロパティ, メソッドは最優先される. super(args) はこのクラスのものが指定可能.
 * @param sources
 *  - `en` multiple extends class
 *  - `ja` 拡張クラスコンストラクタ
 * @returns
 *  - `en` mixined class constructor
 *  - `ja` 合成されたクラスコンストラクタ
 */
export declare function mixins<B extends Class, S1 extends object, S2 extends object, S3 extends object, S4 extends object, S5 extends object, S6 extends object, S7 extends object, S8 extends object, S9 extends object>(base: B, ...sources: [
    Constructor<S1>,
    Constructor<S2>?,
    Constructor<S3>?,
    Constructor<S4>?,
    Constructor<S5>?,
    Constructor<S6>?,
    Constructor<S7>?,
    Constructor<S8>?,
    Constructor<S9>?,
    ...any[]
]): MixinConstructor<B, MixinClass & InstanceType<B> & S1 & S2 & S3 & S4 & S5 & S6 & S7 & S8 & S9>;
/**
 * @en Execute shuffle of an array elements.
 * @ja 配列要素のシャッフル
 *
 * @param array
 *  - `en` source array
 *  - `ja` 入力配列
 * @param destructive
 *  - `en` true: destructive / false: non-destructive (default)
 *  - `ja` true: 破壊的 / false: 非破壊的 (既定)
 */
export declare function shuffle<T>(array: T[], destructive?: boolean): T[];
/**
 * @en Execute stable sort by merge-sort algorithm.
 * @ja `merge-sort` による安定ソート
 *
 * @param array
 *  - `en` source array
 *  - `ja` 入力配列
 * @param comparator
 *  - `en` sort comparator function
 *  - `ja` ソート関数を指定
 * @param destructive
 *  - `en` true: destructive / false: non-destructive (default)
 *  - `ja` true: 破壊的 / false: 非破壊的 (既定)
 */
export declare function sort<T>(array: T[], comparator: (lhs: T, rhs: T) => number, destructive?: boolean): T[];
/**
 * @en Make unique array.
 * @ja 重複要素のない配列の作成
 *
 * @param array
 *  - `en` source array
 *  - `ja` 入力配列
 */
export declare function unique<T>(array: T[]): T[];
/**
 * @en Make union array.
 * @ja 配列の和集合を返却
 *
 * @param arrays
 *  - `en` source arrays
 *  - `ja` 入力配列群
 */
export declare function union<T>(...arrays: T[][]): T[];
/**
 * @en Get the model at the given index. If negative value is given, the target will be found from the last index.
 * @ja インデックス指定によるモデルへのアクセス. 負値の場合は末尾検索を実行
 *
 * @param array
 *  - `en` source array
 *  - `ja` 入力配列
 * @param index
 *  - `en` A zero-based integer indicating which element to retrieve. <br> If negative index is counted from the end of the matched set.
 *  - `ja` 0 base のインデックスを指定 <br> 負値が指定された場合, 末尾からのインデックスとして解釈される
 */
export declare function at<T>(array: T[], index: number): T | never;
/**
 * @en Make index array.
 * @ja インデックス配列の作成
 *
 * @param array
 *  - `en` source array
 *  - `ja` 入力配列
 * @param excludes
 *  - `en` exclude index in return value.
 *  - `ja` 戻り値配列に含めないインデックスを指定
 */
export declare function indices<T>(array: T[], ...excludes: number[]): number[];
/**
 * @en {@link groupBy}() options definition.
 * @ja {@link groupBy}() に指定するオプション定義
 */
export interface GroupByOptions<T extends object, TKEYS extends keyof T, TSUMKEYS extends keyof T, TGROUPKEY extends string> {
    /**
     * @en `GROUP BY` keys.
     * @ja `GROUP BY` に指定するキー
     */
    keys: Extract<TKEYS, string>[];
    /**
     * @en Aggregatable keys.
     * @ja 集計可能なキー一覧
     */
    sumKeys?: Extract<TSUMKEYS, string>[];
    /**
     * @en Grouped item access key. default: 'items',
     * @ja グルーピングされた要素へのアクセスキー. 既定: 'items'
     */
    groupKey?: TGROUPKEY;
}
/**
 * @en Return type of {@link groupBy}().
 * @ja {@link groupBy}() が返却する型
 */
export type GroupByReturnValue<T extends object, TKEYS extends keyof T, TSUMKEYS extends keyof T = never, TGROUPKEY extends string = 'items'> = Readonly<Record<TKEYS, unknown> & Record<TSUMKEYS, unknown> & Record<TGROUPKEY, T[]>>;
/**
 * @en Execute `GROUP BY` for array elements.
 * @ja 配列の要素の `GROUP BY` 集合を抽出
 *
 * @param array
 *  - `en` source array
 *  - `ja` 入力配列
 * @param options
 *  - `en` `GROUP BY` options
 *  - `ja` `GROUP BY` オプション
 */
export declare function groupBy<T extends object, TKEYS extends keyof T, TSUMKEYS extends keyof T = never, TGROUPKEY extends string = 'items'>(array: T[], options: GroupByOptions<T, TKEYS, TSUMKEYS, TGROUPKEY>): GroupByReturnValue<T, TKEYS, TSUMKEYS, TGROUPKEY>[];
/**
 * @en Computes the list of values that are the intersection of all the arrays. Each value in the result is present in each of the arrays.
 * @ja 配列の積集合を返却. 返却された配列の要素はすべての入力された配列に含まれる
 *
 * @example <br>
 *
 * ```ts
 * console.log(intersection([1, 2, 3], [101, 2, 1, 10], [2, 1]));
 * // => [1, 2]
 * ```
 *
 * @param arrays
 *  - `en` source array
 *  - `ja` 入力配列
 */
export declare function intersection<T>(...arrays: T[][]): T[];
/**
 * @en Returns the values from array that are not present in the other arrays.
 * @ja 配列からほかの配列に含まれないものを返却
 *
 * @example <br>
 *
 * ```ts
 * console.log(difference([1, 2, 3, 4, 5], [5, 2, 10]));
 * // => [1, 3, 4]
 * ```
 *
 * @param array
 *  - `en` source array
 *  - `ja` 入力配列
 * @param others
 *  - `en` exclude element in return value.
 *  - `ja` 戻り値配列に含めない要素を指定
 */
export declare function difference<T>(array: T[], ...others: T[][]): T[];
/**
 * @en Returns a copy of the array with all instances of the values removed.
 * @ja 配列から指定要素を取り除いたものを返却
 *
 * @example <br>
 *
 * ```ts
 * console.log(without([1, 2, 1, 0, 3, 1, 4], 0, 1));
 * // => [2, 3, 4]
 * ```
 *
 * @param array
 *  - `en` source array
 *  - `ja` 入力配列
 * @param values
 *  - `en` exclude element in return value.
 *  - `ja` 戻り値配列に含めない要素を指定
 */
export declare function without<T>(array: T[], ...values: T[]): T[];
/**
 * @en Produce a random sample from the list.
 * @ja ランダムにサンプル値を返却
 *
 * @example <br>
 *
 * ```ts
 * console.log(sample([1, 2, 3, 4, 5, 6], 3));
 * // => [1, 6, 2]
 * ```
 *
 * @param array
 *  - `en` source array
 *  - `ja` 入力配列
 * @param count
 *  - `en` number of sampling count.
 *  - `ja` 返却するサンプル数を指定
 */
export declare function sample<T>(array: T[], count: number): T[];
/**
 * @en Produce a random sample from the list.
 * @ja ランダムにサンプル値を返却
 *
 * @example <br>
 *
 * ```ts
 * console.log(sample([1, 2, 3, 4, 5, 6]));
 * // => 4
 * ```
 *
 * @param array
 *  - `en` source array
 *  - `ja` 入力配列
 */
export declare function sample<T>(array: T[]): T;
/**
 * @en Returns a result of permutation from the list.
 * @ja 配列から順列結果を返却
 *
 * @example <br>
 *
 * ```ts
 * const arr = permutation(['a', 'b', 'c'], 2);
 * console.log(JSON.stringify(arr));
 * // => [['a','b'],['a','c'],['b','a'],['b','c'],['c','a'],['c','b']]
 * ```
 *
 * @param array
 *  - `en` source array
 *  - `ja` 入力配列
 * @param count
 *  - `en` number of pick up.
 *  - `ja` 選択数
 */
export declare function permutation<T>(array: T[], count: number): T[][];
/**
 * @en Returns a result of combination from the list.
 * @ja 配列から組み合わせ結果を返却
 *
 * @example <br>
 *
 * ```ts
 * const arr = combination(['a', 'b', 'c'], 2);
 * console.log(JSON.stringify(arr));
 * // => [['a','b'],['a','c'],['b','c']]
 * ```
 *
 * @param array
 *  - `en` source array
 *  - `ja` 入力配列
 * @param count
 *  - `en` number of pick up.
 *  - `ja` 選択数
 */
export declare function combination<T>(array: T[], count: number): T[][];
/**
 * @en Substitution method of `Array.prototype.map()` which also accepts asynchronous callback.
 * @ja 非同期コールバックを指定可能な `Array.prototype.map()` の代替メソッド
 *
 * @param array
 *  - `en` Array to iterate over.
 *  - `ja` 入力配列
 * @param callback
 *  - `en` Function to apply each item in `array`.
 *  - `ja` イテレーション適用関数
 * @param thisArg
 *  - `en` Value to use as *this* when executing the `callback`.
 *  - `ja` `callback` 実行コンテキスト
 * @returns
 *  - `en` Returns a Promise with the resultant *Array* as value.
 *  - `ja` イテレーション結果配列を格納した Promise オブジェクト
 */
export declare function map<T, U>(this: unknown, array: T[], callback: (value: T, index: number, array: T[]) => U | Promise<U>, thisArg?: unknown): Promise<U[]>;
/**
 * @en Substitution method of `Array.prototype.filter()` which also accepts asynchronous callback.
 * @ja 非同期コールバックを指定可能な `Array.prototype.filter()` の代替メソッド
 *
 * @param array
 *  - `en` Array to iterate over.
 *  - `ja` 入力配列
 * @param callback
 *  - `en` Function to apply each item in `array`.
 *  - `ja` イテレーション適用関数
 * @param thisArg
 *  - `en` Value to use as *this* when executing the `callback`.
 *  - `ja` `callback` 実行コンテキスト
 * @returns
 *  - `en` Returns a Promise with the resultant *Array* as value.
 *  - `ja` イテレーション結果配列を格納した Promise オブジェクト
 */
export declare function filter<T>(this: unknown, array: T[], callback: (value: T, index: number, array: T[]) => boolean | Promise<boolean>, thisArg?: unknown): Promise<T[]>;
/**
 * @en Substitution method of `Array.prototype.find()` which also accepts asynchronous callback.
 * @ja 非同期コールバックを指定可能な `Array.prototype.find()` の代替メソッド
 *
 * @param array
 *  - `en` Array to iterate over.
 *  - `ja` 入力配列
 * @param callback
 *  - `en` Function to apply each item in `array`.
 *  - `ja` イテレーション適用関数
 * @param thisArg
 *  - `en` Value to use as *this* when executing the `callback`.
 *  - `ja` `callback` 実行コンテキスト
 * @returns
 *  - `en` Returns a Promise with the resultant value.
 *  - `ja` イテレーション結果を格納した Promise オブジェクト
 */
export declare function find<T>(this: unknown, array: T[], callback: (value: T, index: number, array: T[]) => boolean | Promise<boolean>, thisArg?: unknown): Promise<T | undefined>;
/**
 * @en Substitution method of `Array.prototype.findIndex()` which also accepts asynchronous callback.
 * @ja 非同期コールバックを指定可能な `Array.prototype.findIndex()` の代替メソッド
 *
 * @param array
 *  - `en` Array to iterate over.
 *  - `ja` 入力配列
 * @param callback
 *  - `en` Function to apply each item in `array`.
 *  - `ja` イテレーション適用関数
 * @param thisArg
 *  - `en` Value to use as *this* when executing the `callback`.
 *  - `ja` `callback` 実行コンテキスト
 * @returns
 *  - `en` Returns a Promise with the resultant index value.
 *  - `ja` インデックスを格納した Promise オブジェクト
 */
export declare function findIndex<T>(this: unknown, array: T[], callback: (value: T, index: number, array: T[]) => boolean | Promise<boolean>, thisArg?: unknown): Promise<number>;
/**
 * @en Substitution method of `Array.prototype.some()` which also accepts asynchronous callback.
 * @ja 非同期コールバックを指定可能な `Array.prototype.some()` の代替メソッド
 *
 * @param array
 *  - `en` Array to iterate over.
 *  - `ja` 入力配列
 * @param callback
 *  - `en` Function to apply each item in `array`.
 *  - `ja` イテレーション適用関数
 * @param thisArg
 *  - `en` Value to use as *this* when executing the `callback`.
 *  - `ja` `callback` 実行コンテキスト
 * @returns
 *  - `en` Returns a Promise with the resultant boolean value.
 *  - `ja` 真偽値を格納した Promise オブジェクト
 */
export declare function some<T>(this: unknown, array: T[], callback: (value: T, index: number, array: T[]) => unknown, thisArg?: unknown): Promise<boolean>;
/**
 * @en Substitution method of `Array.prototype.every()` which also accepts asynchronous callback.
 * @ja 非同期コールバックを指定可能な `Array.prototype.every()` の代替メソッド
 *
 * @param array
 *  - `en` Array to iterate over.
 *  - `ja` 入力配列
 * @param callback
 *  - `en` Function to apply each item in `array`.
 *  - `ja` イテレーション適用関数
 * @param thisArg
 *  - `en` Value to use as *this* when executing the `callback`.
 *  - `ja` `callback` 実行コンテキスト
 * @returns
 *  - `en` Returns a Promise with the resultant boolean value.
 *  - `ja` 真偽値を格納した Promise オブジェクト
 */
export declare function every<T>(this: unknown, array: T[], callback: (value: T, index: number, array: T[]) => unknown, thisArg?: unknown): Promise<boolean>;
/**
 * @en Substitution method of `Array.prototype.reduce()` which also accepts asynchronous callback.
 * @ja 非同期コールバックを指定可能な `Array.prototype.reduce()` の代替メソッド
 *
 * @param array
 *  - `en` Array to iterate over.
 *  - `ja` 入力配列
 * @param callback
 *  - `en` Function to apply each item in `array`.
 *  - `ja` イテレーション適用関数
 * @param initialValue
 *  - `en` Used as first argument to the first call of `callback`.
 *  - `ja` `callback` に渡される初期値
 * @returns
 *  - `en` Returns a Promise with the resultant *Array* as value.
 *  - `ja` イテレーション結果配列を格納した Promise オブジェクト
 */
export declare function reduce<T, U>(array: T[], callback: (accumulator: U, currentValue: T, currentIndex: number, array: T[]) => U | Promise<U>, initialValue?: U): Promise<U>;
/**
 * @en Check whether input source has a property.
 * @ja 入力元がプロパティを持っているか判定
 *
 * @param src
 */
export declare function has(src: unknown, propName: string): boolean;
/**
 * @en Get shallow copy of `target` which has only `pickKeys`.
 * @ja `pickKeys` で指定されたプロパティのみを持つ `target` の Shallow Copy を取得
 *
 * @param target
 *  - `en` copy source object
 *  - `ja` コピー元オブジェクト
 * @param pickKeys
 *  - `en` copy target keys
 *  - `ja` コピー対象のキー一覧
 */
export declare function pick<T extends object, K extends keyof T>(target: T, ...pickKeys: K[]): Writable<Pick<T, K>>;
/**
 * @en Get shallow copy of `target` without `omitKeys`.
 * @ja `omitKeys` で指定されたプロパティ以外のキーを持つ `target` の Shallow Copy を取得
 *
 * @param target
 *  - `en` copy source object
 *  - `ja` コピー元オブジェクト
 * @param omitKeys
 *  - `en` omit target keys
 *  - `ja` 削除対象のキー一覧
 */
export declare function omit<T extends object, K extends keyof T>(target: T, ...omitKeys: K[]): Writable<Omit<T, K>>;
/**
 * @en Invert the keys and values of an object. The values must be serializable.
 * @ja オブジェクトのキーと値を逆転する. すべての値がユニークであることが前提
 *
 * @param target
 *  - `en` target object
 *  - `ja` 対象オブジェクト
 */
export declare function invert<T extends object = UnknownObject>(target: object): T;
/**
 * @en Get shallow copy of difference between `base` and `src`.
 * @ja `base` と `src` の差分プロパティをもつオブジェクトの Shallow Copy を取得
 *
 * @param base
 *  - `en` base object
 *  - `ja` 基準となるオブジェクト
 * @param src
 *  - `en` source object
 *  - `ja` コピー元オブジェクト
 */
export declare function diff<T extends object>(base: T, src: Partial<T>): Partial<T>;
/**
 * @en Get shallow copy of `base` without `dropValue`.
 * @ja `dropValue` で指定されたプロパティ値以外のキーを持つ `target` の Shallow Copy を取得
 *
 * @param base
 *  - `en` base object
 *  - `ja` 基準となるオブジェクト
 * @param dropValues
 *  - `en` target value. default: `undefined`.
 *  - `ja` 対象の値. 既定値: `undefined`
 */
export declare function drop<T extends object>(base: T, ...dropValues: unknown[]): Partial<T>;
/**
 * @en If the value of the named property is a function then invoke it; otherwise, return it.
 * @ja object の property がメソッドならその実行結果を, プロパティならその値を返却
 *
 * @param target
 * - `en` Object to maybe invoke function `property` on.
 * - `ja` 評価するオブジェクト
 * @param property
 * - `en` The function by name to invoke on `object`.
 * - `ja` 評価するプロパティ名
 * @param fallback
 * - `en` The value to be returned in case `property` doesn't exist or is undefined.
 * - `ja` 存在しなかった場合の fallback 値
 */
export declare function result<T = any>(target: object | Nullish, property: string | string[], fallback?: T): T;
/**
 * @en Date unit definitions.
 * @ja 日時オブジェクトの単位定義
 */
export type DateUnit = 'year' | 'month' | 'day' | 'hour' | 'min' | 'sec' | 'msec';
/**
 * @en Calculate from the date which becomes a cardinal point before a N date time or after a N date time (by {@link DateUnit}).
 * @ja 基点となる日付から、N日後、N日前を算出
 *
 * @param base
 *  - `en` base date time.
 *  - `ja` 基準日
 * @param add
 *  - `en` relative date time.
 *  - `ja` 加算日. マイナス指定でn日前も設定可能
 * @param unit {@link DateUnit}
 */
export declare function computeDate(base: Date, add: number, unit?: DateUnit): Date;
/**
 * @en Get safe accessible object.
 * @ja 安全にアクセス可能なオブジェクトの取得
 *
 * @example <br>
 *
 * ```ts
 * const safeWindow = safe(globalThis.window);
 * console.log(null != safeWindow.document);    // true
 * const div = safeWindow.document.createElement('div');
 * console.log(null != div);    // true
 * ```
 *
 * @param target
 *  - `en` A reference of an object with a possibility which exists.
 *  - `ja` 存在しうるオブジェクトの参照
 * @returns
 *  - `en` Reality or stub instance.
 *  - `ja` 実体またはスタブインスタンス
 */
export declare function safe<T>(target: T): T;
/**
 * @en Type of handle for timer functions.
 * @ja タイマー関数に使用するハンドル型
 */
export interface TimerHandle {
}
/**
 * @en Type of timer start functions.
 * @ja タイマー開始関数の型
 */
export type TimerStartFunction = (handler: UnknownFunction, timeout?: number, ...args: unknown[]) => TimerHandle;
/**
 * @en Type of timer stop functions.
 * @ja タイマー停止関数の型
 */
export type TimerStopFunction = (handle: TimerHandle) => void;
export declare const setTimeout: TimerStartFunction;
export declare const clearTimeout: TimerStopFunction;
export declare const setInterval: TimerStartFunction;
export declare const clearInterval: TimerStopFunction;
/**
 * @en Increment reference count for status identifier.
 * @ja 状態変数の参照カウントのインクリメント
 *
 * @param status
 *  - `en` state identifier
 *  - `ja` 状態識別子
 * @returns
 *  - `en` reference count value
 *  - `ja` 参照カウントの値
 */
export declare function statusAddRef(status: string | symbol): number;
/**
 * @en Decrement reference count for status identifier.
 * @ja 状態変数の参照カウントのデクリメント
 *
 * @param status
 *  - `en` state identifier
 *  - `ja` 状態識別子
 * @returns
 *  - `en` reference count value
 *  - `ja` 参照カウントの値
 */
export declare function statusRelease(status: string | symbol): number;
/**
 * @en State variable management scope
 * @ja 状態変数管理スコープ
 *
 * @param status
 *  - `en` state identifier
 *  - `ja` 状態識別子
 * @param executor
 *  - `en` seed function.
 *  - `ja` 対象の関数
 * @returns
 *  - `en` retval of seed function.
 *  - `ja` 対象の関数の戻り値
 */
export declare function statusScope<T>(status: string | symbol, executor: () => T | Promise<T>): Promise<T>;
/**
 * @en Check if it's in the specified state.
 * @ja 指定した状態中であるか確認
 *
 * @param status
 *  - `en` state identifier
 *  - `ja` 状態識別子
 * @return {Boolean} true: 状態内 / false: 状態外
 * @returns
 *  - `en` `true`: within the status / `false`: out of the status
 *  - `ja` `true`: 状態内 / `false`: 状態外
 */
export declare function isStatusIn(status: string | symbol): boolean;
/**
 * @en Ensure asynchronous execution.
 * @ja 非同期実行を保証
 *
 * @example <br>
 *
 * ```ts
 * void post(() => exec(arg));
 * ```
 *
 * @param executor
 *  - `en` implement as function scope.
 *  - `ja` 関数スコープとして実装
*/
export declare function post<T>(executor: () => T): Promise<T>;
/**
 * @en Generic No-Operation.
 * @ja 汎用 No-Operation
 */
export declare function noop(...args: unknown[]): any;
/**
 * @en Wait for the designation elapse.
 * @ja 指定時間処理を待機
 *
 * @param elapse
 *  - `en` wait elapse [msec].
 *  - `ja` 待機時間 [msec]
 */
export declare function sleep(elapse: number): Promise<void>;
/**
 * @en Option interface for {@link debounce}().
 * @ja {@link debounce}() に指定するオプションインターフェイス
 */
export interface DebounceOptions {
    /**
     * @en the maximum time `func` is allowed to be delayed before it's invoked.
     * @ja コールバックの呼び出しを待つ最大時間
     */
    maxWait?: number;
    /**
     * @en Specify `true` if you want to call the callback leading edge of the waiting time. (default: false)
     * @ja 待ち時間に対してコールバックを先呼び実行する場合は `true` を指定. (default: false)
     */
    leading?: boolean;
    /**
     * @en Specify `true` if you want to call the callback trailing edge of the waiting time. (default: true)
     * @ja 待ち時間に対してコールバックを後呼び実行する場合は `true` を指定. (default: true)
     */
    trailing?: boolean;
}
export type DebouncedFunction<T extends UnknownFunction> = T & {
    cancel(): void;
    flush(): ReturnType<T>;
    pending(): boolean;
};
/**
 * @en Returns a function, that, as long as it continues to be invoked, will not be triggered.
 * @ja 呼び出されてから wait [msec] 経過するまで実行しない関数を返却
 *
 * @param executor
 *  - `en` seed function.
 *  - `ja` 対象の関数
 * @param wait
 *  - `en` wait elapse [msec].
 *  - `ja` 待機時間 [msec]
 * @param options
 *  - `en` specify {@link DebounceOptions} object or `true` to fire the callback immediately.
 *  - `ja` {@link DebounceOptions} object もしくは即時にコールバックを発火するときは `true` を指定.
 */
export declare function debounce<T extends UnknownFunction>(executor: T, wait: number, options?: DebounceOptions | boolean): DebouncedFunction<T>;
/**
 * @en Option interface for {@link throttle}().
 * @ja {@link throttle}() に指定するオプションインターフェイス
 */
export interface ThrottleOptions {
    /**
     * @en Specify `true` if you want to call the callback leading edge of the waiting time. (default: true)
     * @ja 待ち時間に対してコールバックを先呼び実行する場合は `true` を指定. (default: true)
     */
    leading?: boolean;
    /**
     * @en Specify `true` if you want to call the callback trailing edge of the waiting time. (default: true)
     * @ja 待ち時間に対してコールバックを後呼び実行する場合は `true` を指定. (default: true)
     */
    trailing?: boolean;
}
/**
 * @en Returns a function, that, when invoked, will only be triggered at most once during a given time.
 * @ja 関数の実行を wait [msec] に1回に制限
 *
 * @example <br>
 *
 * ```ts
 * const throttled = throttle(upatePosition, 100);
 * $(window).scroll(throttled);
 * ```
 *
 * @param executor
 *  - `en` seed function.
 *  - `ja` 対象の関数
 * @param elapse
 *  - `en` wait elapse [msec].
 *  - `ja` 待機時間 [msec]
 * @param options
 */
export declare function throttle<T extends UnknownFunction>(executor: T, elapse: number, options?: ThrottleOptions): DebouncedFunction<T>;
/**
 * @en Returns a function that will be executed at most one time, no matter how often you call it.
 * @ja 1度しか実行されない関数を返却. 2回目以降は最初のコールのキャッシュを返却
 *
 * @param executor
 *  - `en` seed function.
 *  - `ja` 対象の関数
 */
export declare function once<T extends UnknownFunction>(executor: T): T;
/**
 * @en Return a deferred executable function object.
 * @ja 遅延実行可能な関数オブジェクトを返却
 *
 * @example <br>
 *
 * ```ts
 * const schedule = scheduler();
 * schedule(() => task1());
 * schedule(() => task2());
 * ```
 */
export declare function scheduler(): (exec: () => void) => void;
/**
 * @en Create escape function from map.
 * @ja 文字置換関数を作成
 *
 * @param map
 *  - `en` key: target char, value: replace char
 *  - `ja` key: 置換対象, value: 置換文字
 * @returns
 *  - `en` espace function
 *  - `ja` エスケープ関数
 */
export declare function createEscaper(map: Record<string, string>): (src: Primitive) => string;
/**
 * @en Escape HTML string.
 * @ja HTML で使用する文字を制御文字に置換
 *
 * @brief <br>
 *
 * ```ts
 * const mapHtmlEscape = {
 *     '<' : '&lt;',
 *     '>' : '&gt;',
 *     '&' : '&amp;',
 *     '″': '&quot;',
 *     `'` : '&#39;',
 *     '`' : '&#x60;'
 * };
 * ```
 */
export declare const escapeHTML: (src: Primitive) => string;
/**
 * @en Unescape HTML string.
 * @ja HTML で使用する制御文字を復元
 */
export declare const unescapeHTML: (src: Primitive) => string;
/**
 * @en Convert to the style compulsion value from input string.
 * @ja 入力文字列を型強制した値に変換
 *
 * @param data
 *  - `en` input string
 *  - `ja` 変換対象の文字列
 */
export declare function toTypedData(data: string | undefined): TypedData | undefined;
/**
 * @en Convert to string from {@link TypedData}.
 * @ja {@link TypedData} を文字列に変換
 *
 * @param data
 *  - `en` input string
 *  - `ja` 変換対象の文字列
 */
export declare function fromTypedData(data: TypedData | undefined): string | undefined;
/**
 * @en Convert to `Web API` stocked type. <br>
 *     Ensure not to return `undefined` value.
 * @ja `Web API` 格納形式に変換 <br>
 *     `undefined` を返却しないことを保証
 */
export declare function dropUndefined<T>(value: T | null | undefined, nullishSerialize?: boolean): T | 'null' | 'undefined' | null;
/**
 * @en Deserialize from `Web API` stocked type. <br>
 *     Convert from 'null' or 'undefined' string to original type.
 * @ja 'null' or 'undefined' をもとの型に戻す
 */
export declare function restoreNullish<T>(value: T | 'null' | 'undefined'): T | null | undefined;
/**
 * @en Get local unique id. <br>
 *     'local unique' means guarantees unique during in script life cycle only.
 * @ja ローカルユニーク ID の取得 <br>
 *     スクリプトライフサイクル中の同一性を保証する.
 *
 * @param prefix
 *  - `en` ID prefix
 *  - `ja` ID に付与する Prefix
 * @param zeroPad
 *  - `en` 0 padding order
 *  - `ja` 0 詰めする桁数を指定
 */
export declare function luid(prefix?: string, zeroPad?: number): string;
/**
 * @en Returns a random integer between `0` and `max`, inclusive.
 * @ja `0` - `max` のランダムの整数値を生成
 *
 * @param max
 *  - `en` The maximum random number.
 *  - `ja` 整数の最大値
 */
export declare function randomInt(max: number): number;
/**
 * @en Returns a random integer between `min` and `max`, inclusive.
 * @ja `min` - `max` のランダムの整数値を生成
 *
 * @param min
 *  - `en` The maximum random number.
 *  - `ja` 整数の最大値
 * @param max
 *  - `en` The maximum random number.
 *  - `ja` 整数の最大値
 */
export declare function randomInt(min: number, max: number): number;
/**
 * @en Presume whether it's a canceled error.
 * @ja キャンセルされたエラーであるか推定
 *
 * @param error
 *  - `en` an error object handled in `catch` block.
 *  - `ja` `catch` 節などで補足したエラーを指定
 */
export declare function isCancelLikeError(error: unknown): boolean;
/**
 * @en Converts first letter of the string to uppercase.
 * @ja 最初の文字を大文字に変換
 *
 *
 * @example <br>
 *
 * ```ts
 * capitalize('foo Bar');
 * // => 'Foo Bar'
 *
 * capitalize('FOO Bar', true);
 * // => 'Foo bar'
 * ```
 *
 * @param src
 *  - `en` source string
 *  - `ja` 変換元文字列
 * @param lowercaseRest
 *  - `en` If `true` is passed, the rest of the string will be converted to lower case
 *  - `ja` `true` を指定した場合, 2文字目以降も小文字化
 */
export declare function capitalize(src: string, lowercaseRest?: boolean): string;
/**
 * @en Converts first letter of the string to lowercase.
 * @ja 最初の文字を小文字化
 *
 * @example <br>
 *
 * ```ts
 * decapitalize('Foo Bar');
 * // => 'foo Bar'
 * ```
 *
 * @param src
 *  - `en` source string
 *  - `ja` 変換元文字列
 */
export declare function decapitalize(src: string): string;
/**
 * @en Converts underscored or dasherized string to a camelized one. <br>
 *     Begins with a lower case letter unless it starts with an underscore, dash or an upper case letter.
 * @ja `_`, `-` 区切り文字列をキャメルケース化 <br>
 *     `-` または大文字スタートであれば, 大文字スタートが既定値
 *
 * @example <br>
 *
 * ```ts
 * camelize('moz-transform');
 * // => 'mozTransform'
 *
 * camelize('-moz-transform');
 * // => 'MozTransform'
 *
 * camelize('_moz_transform');
 * // => 'MozTransform'
 *
 * camelize('Moz-transform');
 * // => 'MozTransform'
 *
 * camelize('-moz-transform', true);
 * // => 'mozTransform'
 * ```
 *
 * @param src
 *  - `en` source string
 *  - `ja` 変換元文字列
 * @param lower
 *  - `en` If `true` is passed, force converts to lower camel case in starts with the special case.
 *  - `ja` 強制的に小文字スタートする場合には `true` を指定
 */
export declare function camelize(src: string, lower?: boolean): string;
/**
 * @en Converts string to camelized class name. First letter is always upper case.
 * @ja 先頭大文字のキャメルケースに変換
 *
 * @example <br>
 *
 * ```ts
 * classify('some_class_name');
 * // => 'SomeClassName'
 * ```
 *
 * @param src
 *  - `en` source string
 *  - `ja` 変換元文字列
 */
export declare function classify(src: string): string;
/**
 * @en Converts a camelized or dasherized string into an underscored one.
 * @ja キャメルケース or `-` つなぎ文字列を `_` つなぎに変換
 *
 * @example <br>
 *
 * ```ts
 * underscored('MozTransform');
 * // => 'moz_transform'
 * ```
 *
 * @param src
 *  - `en` source string
 *  - `ja` 変換元文字列
 */
export declare function underscored(src: string): string;
/**
 * @en Converts a underscored or camelized string into an dasherized one.
 * @ja キャメルケース or `_` つなぎ文字列を `-` つなぎに変換
 *
 * @example <br>
 *
 * ```ts
 * dasherize('MozTransform');
 * // => '-moz-transform'
 * ```
 *
 * @param src
 *  - `en` source string
 *  - `ja` 変換元文字列
 */
export declare function dasherize(src: string): string;
/**
 * @en All event handle base interface definition.
 * @ja すべてのイベントをハンドル可能なの Event 基底インターフェイス
 */
export interface EventAll {
    '*': any[];
}
/**
 * @en Represents a disposable resource, such as the execution of an {@link Subscribable}.
 * @ja {@link Subscribable} オブジェクトが返す購読情報コンテキストオブジェクト
 */
export interface Subscription {
    /**
     * @en Status for receiving event
     * @ja 購読可否ステータス
     */
    readonly enable: boolean;
    /**
     * @en Disposes the resources held by the subscription
     * @ja 購読停止
     */
    unsubscribe(): void;
}
/**
 * @en Event supplyer interface definitions <br>
 *     If the client listener returns `true`, the class stops delegation event to the next.
 * @ja イベント供給を行うインターフェイス定義 <br>
 *     クライアントリスナーが `true` を返却するとき, 本クラスは次のイベント呼び出しを中止する.
 */
export interface Subscribable<Event extends object = any> {
    /** type resolver */
    readonly [$cdp]?: Event;
    /**
     * @en Check whether this object has clients.
     * @ja クライアントが存在するか判定
     *
     * @param channel
     *  - `en` event channel key. (string | symbol)
     *  - `ja` イベントチャネルキー (string | symbol)
     * @param listener
     *  - `en` callback function of the `channel` corresponding.
     *  - `ja` `channel` に対応したコールバック関数
     */
    hasListener<Channel extends keyof Event>(channel?: Channel, listener?: (...args: Arguments<Event[Channel]>) => unknown): boolean;
    /**
     * @en Returns registered channel keys.
     * @ja 登録されているチャネルキーを返却
     */
    channels(): (keyof Event)[];
    /**
     * @en Unsubscribe event(s).
     * @ja イベント購読解除
     *
     * @param channel
     *  - `en` target event channel key. (string | symbol)
     *         When not set this parameter, everything is released.
     *  - `ja` 対象のイベントチャネルキー (string | symbol)
     *         指定しない場合はすべて解除
     * @param listener
     *  - `en` callback function of the `channel` corresponding.
     *         When not set this parameter, all same `channel` listeners are released.
     *  - `ja` `channel` に対応したコールバック関数
     *         指定しない場合は同一 `channel` すべてを解除
     */
    off<Channel extends keyof Event>(channel?: Channel | Channel[], listener?: (...args: Arguments<Event[Channel]>) => unknown): void;
    /**
     * @en Subscrive event(s).
     * @ja イベント購読設定
     *
     * @param channel
     *  - `en` target event channel key. (string | symbol)
     *  - `ja` 対象のイベントチャネルキー (string | symbol)
     * @param listener
     *  - `en` callback function of the `channel` corresponding.
     *  - `ja` `channel` に対応したコールバック関数
     */
    on<Channel extends keyof Event>(channel: Channel | Channel[], listener: (...args: Arguments<Event[Channel]>) => unknown): Subscription;
    /**
     * @en Subscrive event(s) but it causes the bound callback to only fire once before being removed.
     * @ja 一度だけハンドリング可能なイベント購読設定
     *
     * @param channel
     *  - `en` target event channel key. (string | symbol)
     *  - `ja` 対象のイベントチャネルキー (string | symbol)
     * @param listener
     *  - `en` callback function of the `channel` corresponding.
     *  - `ja` `channel` に対応したコールバック関数
     */
    once<Channel extends keyof Event>(channel: Channel | Channel[], listener: (...args: Arguments<Event[Channel]>) => unknown): Subscription;
}
/**
 * @en Extract event schema from {@link Subscribable} type.
 * @ja {@link Subscribable} 型からイベントスキーマ定義の抽出
 */
export type EventSchema<T extends Subscribable> = T extends Subscribable<infer R> ? R : never;
/**
 * @en Common interface for notification restraint.
 * @ja 通知抑止に使用する共通インターフェイス
 */
export interface Silenceable {
    /** true: restraint notification / false: fire notification (default) */
    silent?: boolean;
}
/**
 * @en Eventing framework class with ensuring type-safe for TypeScript. <br>
 *     The client of this class can implement original Pub-Sub (Observer) design pattern.
 * @ja 型安全を保障するイベント登録・発行クラス <br>
 *     クライアントは本クラスを派生して独自の Pub-Sub (Observer) パターンを実装可能
 *
 * @example <br>
 *
 * ```ts
 * import { EventPublisher } from '@cdp/runtime';
 *
 * // declare event interface
 * interface SampleEvent {
 *   hoge: [number, string];        // callback function's args type tuple
 *   foo: [void];                   // no args
 *   hoo: void;                     // no args (same the upon)
 *   bar: [Error];                  // any class is available.
 *   baz: Error | Number;           // if only one argument, `[]` is not required.
 * }
 *
 * // declare client class
 * class SamplePublisher extends EventPublisher<SampleEvent> {
 *   :
 *   someMethod(): void {
 *     this.publish('hoge', 100, 'test');       // OK. standard usage.
 *     this.publish('hoge', 100, true);         // NG. argument of type 'true' is not assignable
 *                                              //     to parameter of type 'string | undefined'.
 *     this.publish('hoge', 100);               // OK. all args to be optional automatically.
 *     this.publish('foo');                     // OK. standard usage.
 *     this.publish('foo', 100);                // NG. argument of type '100' is not assignable
 *                                              //     to parameter of type 'void | undefined'.
 *   }
 * }
 *
 * const sample = new SamplePublisher();
 *
 * sample.on('hoge', (a: number, b: string) => { ... });    // OK. standard usage.
 * sample.on('hoge', (a: number, b: boolean) => { ... });   // NG. types of parameters 'b'
 *                                                          //     and 'args_1' are incompatible.
 * sample.on('hoge', (a) => { ... });                       // OK. all args
 *                                                          //     to be optional automatically.
 * sample.on('hoge', (a, b, c) => { ... });                 // NG. expected 1-2 arguments,
 *                                                          //     but got 3.
 * ```
 */
export declare abstract class EventPublisher<Event extends object> implements Subscribable<Event> {
    /** constructor */
    constructor();
    /**
     * @en Notify event to clients.
     * @ja event 発行
     *
     * @param channel
     *  - `en` event channel key. (string | symbol)
     *  - `ja` イベントチャネルキー (string | symbol)
     * @param args
     *  - `en` arguments for callback function of the `channel` corresponding.
     *  - `ja` `channel` に対応したコールバック関数に渡す引数
     */
    protected publish<Channel extends keyof Event>(channel: Channel, ...args: Arguments<Partial<Event[Channel]>>): void;
    /**
     * @en Check whether this object has clients.
     * @ja クライアントが存在するか判定
     *
     * @param channel
     *  - `en` event channel key. (string | symbol)
     *  - `ja` イベントチャネルキー (string | symbol)
     * @param listener
     *  - `en` callback function of the `channel` corresponding.
     *  - `ja` `channel` に対応したコールバック関数
     */
    hasListener<Channel extends keyof Event>(channel?: Channel, listener?: (...args: Arguments<Event[Channel]>) => unknown): boolean;
    /**
     * @en Returns registered channel keys.
     * @ja 登録されているチャネルキーを返却
     */
    channels(): (keyof Event)[];
    /**
     * @en Subscrive event(s).
     * @ja イベント購読設定
     *
     * @param channel
     *  - `en` target event channel key. (string | symbol)
     *  - `ja` 対象のイベントチャネルキー (string | symbol)
     * @param listener
     *  - `en` callback function of the `channel` corresponding.
     *  - `ja` `channel` に対応したコールバック関数
     */
    on<Channel extends keyof Event>(channel: Channel | Channel[], listener: (...args: Arguments<Event[Channel]>) => unknown): Subscription;
    /**
     * @en Subscrive event(s) but it causes the bound callback to only fire once before being removed.
     * @ja 一度だけハンドリング可能なイベント購読設定
     *
     * @param channel
     *  - `en` target event channel key. (string | symbol)
     *  - `ja` 対象のイベントチャネルキー (string | symbol)
     * @param listener
     *  - `en` callback function of the `channel` corresponding.
     *  - `ja` `channel` に対応したコールバック関数
     */
    once<Channel extends keyof Event>(channel: Channel | Channel[], listener: (...args: Arguments<Event[Channel]>) => unknown): Subscription;
    /**
     * @en Unsubscribe event(s).
     * @ja イベント購読解除
     *
     * @param channel
     *  - `en` target event channel key. (string | symbol)
     *         When not set this parameter, everything is released.
     *  - `ja` 対象のイベントチャネルキー (string | symbol)
     *         指定しない場合はすべて解除
     * @param listener
     *  - `en` callback function of the `channel` corresponding.
     *         When not set this parameter, all same `channel` listeners are released.
     *  - `ja` `channel` に対応したコールバック関数
     *         指定しない場合は同一 `channel` すべてを解除
     */
    off<Channel extends keyof Event>(channel?: Channel | Channel[], listener?: (...args: Arguments<Event[Channel]>) => unknown): this;
}
/** re-export */
export type EventArguments<T> = Arguments<T>;
/**
 * @en Eventing framework object able to call `publish()` method from outside.
 * @ja 外部からの `publish()` を可能にしたイベント登録・発行クラス
 *
 * @example <br>
 *
 * ```ts
 * import { EventBroker } from '@cdp/runtime';
 *
 * // declare event interface
 * interface SampleEvent {
 *   hoge: [number, string];        // callback function's args type tuple
 * }
 *
 * const broker = new EventBroker<SampleEvent>();
 * broker.trigger('hoge', 100, 'test');     // OK. standard usage.
 * broker.trigger('hoge', 100, true);       // NG. argument of type 'true' is not assignable
 *                                          //     to parameter of type 'string | undefined'.
 * ```
 */
export interface EventBroker<Event extends object> extends Subscribable<Event> {
    /**
     * @en Notify event to clients.
     * @ja event 発行
     *
     * @param channel
     *  - `en` event channel key. (string | symbol)
     *  - `ja` イベントチャネルキー (string | symbol)
     * @param args
     *  - `en` arguments for callback function of the `channel` corresponding.
     *  - `ja` `channel` に対応したコールバック関数に渡す引数
     */
    trigger<Channel extends keyof Event>(channel: Channel, ...args: Arguments<Partial<Event[Channel]>>): void;
}
/**
 * @en Constructor of {@link EventBroker}
 * @ja {@link EventBroker} のコンストラクタ実体
 */
export declare const EventBroker: {
    readonly prototype: EventBroker<any>;
    new <T extends object>(): EventBroker<T>;
};
/**
 * @en The class to which the safe event register/unregister method is offered for the object which is a short life cycle than subscription target. <br>
 *     The advantage of using this form, instead of `on()`, is that `listenTo()` allows the object to keep track of the events,
 *     and they can be removed all at once later call `stopListening()`.
 * @ja 購読対象よりもライフサイクルが短いオブジェクトに対して, 安全なイベント登録/解除メソッドを提供するクラス <br>
 *     `on()` の代わりに `listenTo()` を使用することで, 後に `stopListening()` を1度呼ぶだけですべてのリスナーを解除できる利点がある.
 *
 * @example <br>
 *
 * ```ts
 * import { EventReceiver, EventBroker } from '@cdp/runtime';
 *
 * // declare event interface
 * interface SampleEvent {
 *   hoge: [number, string];        // callback function's args type tuple
 *   foo: [void];                   // no args
 *   hoo: void;                     // no args (same the upon)
 *   bar: [Error];                  // any class is available.
 *   baz: Error | Number;           // if only one argument, `[]` is not required.
 * }
 *
 * // declare client class
 * class SampleReceiver extends EventReceiver {
 *   constructor(broker: EventBroker<SampleEvent>) {
 *     super();
 *     this.listenTo(broker, 'hoge', (num: number, str: string) => { ... });
 *     this.listenTo(broker, 'bar', (e: Error) => { ... });
 *     this.listenTo(broker, ['foo', 'hoo'], () => { ... });
 *   }
 *
 *   release(): void {
 *     this.stopListening();
 *   }
 * }
 * ```
 *
 * or
 *
 * ```ts
 * const broker   = new EventBroker<SampleEvent>();
 * const receiver = new EventReceiver();
 *
 * receiver.listenTo(broker, 'hoge', (num: number, str: string) => { ... });
 * receiver.listenTo(broker, 'bar', (e: Error) => { ... });
 * receiver.listenTo(broker, ['foo', 'hoo'], () => { ... });
 *
 * receiver.stopListening();
 * ```
 */
export declare class EventReceiver {
    /** constructor */
    constructor();
    /**
     * @en Tell an object to listen to a particular event on an other object.
     * @ja 対象オブジェクトのイベント購読設定
     *
     * @param target
     *  - `en` event listening target object.
     *  - `ja` イベント購読対象のオブジェクト
     * @param channel
     *  - `en` target event channel key. (string | symbol)
     *  - `ja` 対象のイベントチャネルキー (string | symbol)
     * @param listener
     *  - `en` callback function of the `channel` corresponding.
     *  - `ja` `channel` に対応したコールバック関数
     */
    listenTo<T extends Subscribable, Event extends EventSchema<T> = EventSchema<T>, Channel extends keyof Event = keyof Event>(target: T, channel: Channel | Channel[], listener: (...args: Arguments<Event[Channel]>) => unknown): Subscription;
    /**
     * @en Just like listenTo, but causes the bound callback to fire only once before being removed.
     * @ja 対象オブジェクトの一度だけハンドリング可能なイベント購読設定
     *
     * @param target
     *  - `en` event listening target object.
     *  - `ja` イベント購読対象のオブジェクト
     * @param channel
     *  - `en` target event channel key. (string | symbol)
     *  - `ja` 対象のイベントチャネルキー (string | symbol)
     * @param listener
     *  - `en` callback function of the `channel` corresponding.
     *  - `ja` `channel` に対応したコールバック関数
     */
    listenToOnce<T extends Subscribable, Event extends EventSchema<T> = EventSchema<T>, Channel extends keyof Event = keyof Event>(target: T, channel: Channel | Channel[], listener: (...args: Arguments<Event[Channel]>) => unknown): Subscription;
    /**
     * @en Tell an object to stop listening to events.
     * @ja イベント購読解除
     *
     * @param target
     *  - `en` event listening target object.
     *         When not set this parameter, everything is released.
     *  - `ja` イベント購読対象のオブジェクト
     *         指定しない場合はすべてのリスナーを解除
     * @param channel
     *  - `en` target event channel key. (string | symbol)
     *         When not set this parameter, everything is released listeners from `target`.
     *  - `ja` 対象のイベントチャネルキー (string | symbol)
     *         指定しない場合は対象 `target` のリスナーをすべて解除
     * @param listener
     *  - `en` callback function of the `channel` corresponding.
     *         When not set this parameter, all same `channel` listeners are released.
     *  - `ja` `channel` に対応したコールバック関数
     *         指定しない場合は同一 `channel` すべてを解除
     */
    stopListening<T extends Subscribable, Event extends EventSchema<T> = EventSchema<T>, Channel extends keyof Event = keyof Event>(target?: T, channel?: Channel | Channel[], listener?: (...args: Arguments<Event[Channel]>) => unknown): this;
}
/**
 * @en The class which have I/F of {@link EventBroker} and {@link EventReceiver}. <br>
 *     `Events` class of `Backbone.js` equivalence.
 * @ja {@link EventBroker} と {@link EventReceiver} の I/F をあわせ持つクラス <br>
 *     `Backbone.js` の `Events` クラス相当
 *
 * @example <br>
 *
 * ```ts
 * import { EventSource } from '@cdp/runtime';
 *
 * // declare event interface
 * interface TargetEvent {
 *   hoge: [number, string];        // callback function's args type tuple
 *   foo: [void];                   // no args
 *   hoo: void;                     // no args (same the upon)
 *   bar: [Error];                  // any class is available.
 *   baz: Error | Number;           // if only one argument, `[]` is not required.
 * }
 *
 * interface SampleEvent {
 *   fuga: [number, string];        // callback function's args type tuple
 * }
 *
 * // declare client class
 * class SampleSource extends EventSource<SampleEvent> {
 *   constructor(target: EventSource<TargetEvent>) {
 *     super();
 *     this.listenTo(broker, 'hoge', (num: number, str: string) => { ... });
 *     this.listenTo(broker, 'bar', (e: Error) => { ... });
 *     this.listenTo(broker, ['foo', 'hoo'], () => { ... });
 *   }
 *
 *   release(): void {
 *     this.stopListening();
 *   }
 * }
 *
 * const sample = new SampleSource();
 *
 * sample.on('fuga', (a: number, b: string) => { ... });    // OK. standard usage.
 * sample.trigger('fuga', 100, 'test');                     // OK. standard usage.
 * ```
 */
export type EventSource<T extends object> = EventBroker<T> & EventReceiver;
/**
 * @en Constructor of {@link EventSource}
 * @ja {@link EventSource} のコンストラクタ実体
 */
export declare const EventSource: {
    readonly prototype: EventSource<any>;
    new <T extends object>(): EventSource<T>;
};
/**
 * @en Cancellation source interface.
 * @ja キャンセル管理インターフェイス
 */
export interface CancelTokenSource<T = unknown> {
    /**
     * @en {@link CancelToken} getter.
     * @ja {@link CancelToken} 取得
     */
    readonly token: CancelToken<T>;
    /**
     * @en Execute cancel.
     * @ja キャンセル実行
     *
     * @param reason
     *  - `en` cancellation reason. this arg is transmitted in promise chain.
     *  - `ja` キャンセルの理由を指定. `Promise` チェインに伝達される.
     */
    cancel(reason: T): void;
    /**
     * @en Break up cancellation reception.
     * @ja キャンセル受付を終了
     */
    close(): void;
}
/**
 * @en The token object to which unification processing for asynchronous processing cancellation is offered. <br>
 *     Origin is `CancellationToken` of `.NET Framework`.
 * @ja 非同期処理キャンセルのための統一処理を提供するトークンオブジェクト <br>
 *     オリジナルは `.NET Framework` の `CancellationToken`
 *
 * @see https://docs.microsoft.com/en-us/dotnet/standard/threading/cancellation-in-managed-threads
 *
 * @example <br>
 *
 * ```ts
 * import { CancelToken } from '@cdp/runtime';
 * ```
 *
 * - Basic Usage
 *
 * ```ts
 * const token = new CancelToken((cancel, close) => {
 *   button1.onclick = ev => cancel(new Error('Cancel'));
 *   button2.onclick = ev => close();
 * });
 * ```
 *
 * or
 *
 * ```ts
 * const { cancel, close, token } = CancelToken.source();
 * button1.onclick = ev => cancel(new Error('Cancel'));
 * button2.onclick = ev => close();
 * ```
 *
 * - Use with Promise
 *
 * ```ts
 * const { cancel, close, token } = CancelToken.source();
 * const promise = new Promise((ok, ng) => { ... }, token);
 * promise
 *   .then(...)
 *   .then(...)
 *   .then(...)
 *   .catch(reason => {
 *     // check reason
 *   });
 * ```
 *
 * - Register & Unregister callback(s)
 *
 * ```ts
 * const { cancel, close, token } = CancelToken.source();
 * const subscription = token.register(reason => {
 *   console.log(reason.message);
 * });
 * if (someCase) {
 *   subscription.unsubscribe();
 * }
 * ```
 */
export declare class CancelToken<T = unknown> {
    /**
     * @en Create {@link CancelTokenSource} instance.
     * @ja {@link CancelTokenSource} インスタンスの取得
     *
     * @param linkedTokens
     *  - `en` relating already made {@link CancelToken} instance.
     *        You can attach to the token that to be a cancellation target.
     *  - `ja` すでに作成された {@link CancelToken} 関連付ける場合に指定
     *        渡された token はキャンセル対象として紐づけられる
     */
    static source<T = unknown>(...linkedTokens: CancelToken[]): CancelTokenSource<T>;
    /**
     * constructor
     *
     * @param executor
     *  - `en` executer that has `cancel` and `close` callback.
     *  - `ja` キャンセル/クローズ 実行コールバックを指定
     * @param linkedTokens
     *  - `en` relating already made {@link CancelToken} instance.
     *        You can attach to the token that to be a cancellation target.
     *  - `ja` すでに作成された {@link CancelToken} 関連付ける場合に指定
     *        渡された token はキャンセル対象として紐づけられる
     */
    constructor(executor: (cancel: (reason: T) => void, close: () => void) => void, ...linkedTokens: CancelToken[]);
    /**
     * @en Cancellation reason accessor.
     * @ja キャンセルの原因取得
     */
    get reason(): T | undefined;
    /**
     * @en Enable cancellation state accessor.
     * @ja キャンセル可能か判定
     */
    get cancelable(): boolean;
    /**
     * @en Cancellation requested state accessor.
     * @ja キャンセルを受け付けているか判定
     */
    get requested(): boolean;
    /**
     * @en Cancellation closed state accessor.
     * @ja キャンセル受付を終了しているか判定
     */
    get closed(): boolean;
    /**
     * @en `toString` tag override.
     * @ja `toString` タグのオーバーライド
     */
    protected get [Symbol.toStringTag](): 'CancelToken';
    /**
     * @en Register custom cancellation callback.
     * @ja キャンセル時のカスタム処理の登録
     *
     * @param onCancel
     *  - `en` cancel operation callback
     *  - `ja` キャンセルコールバック
     * @returns
     *  - `en` `Subscription` instance.
     *        You can revoke cancellation to call `unsubscribe` method.
     *  - `ja` `Subscription` インスタンス
     *        `unsubscribe` メソッドを呼ぶことでキャンセルを無効にすることが可能
     */
    register(onCancel: (reason: T) => unknown): Subscription;
}
/**
 * @en `Native Promise` constructor <br>
 *     Can be used as an alias for `Native Promise`.
 * @ja `Native Promise` コンストラクタ <br>
 *     `Native Promise` のエイリアスとして使用可能
 */
export declare const NativePromise: PromiseConstructor;
/**
 * @en Extended `Promise` class which enabled cancellation. <br>
 *     `Native Promise` constructor is overridden by framework default behaviour.
 * @ja キャンセルを可能にした `Promise` 拡張クラス <br>
 *     既定で `Native Promise` をオーバーライドする.
 */
export declare class CancelablePromise<T> extends Promise<T> {
    /**
     * constructor
     *
     * @param executor
     *  - `en` A callback used to initialize the promise. This callback is passed two arguments `resolve` and `reject`.
     *  - `ja` promise の初期化に使用するコールバックを指定. `resolve` と `reject` の2つの引数を持つ
     * @param cancelToken
     *  - `en` {@link CancelToken} instance create from {@link CancelToken.source | CancelToken.source}().
     *  - `ja` {@link CancelToken.source | CancelToken.source}() より作成した {@link CancelToken} インスタンスを指定
     */
    constructor(executor: (resolve: (value?: T | PromiseLike<T>) => void, reject: (reason?: unknown) => void) => void, cancelToken?: CancelToken | null);
}
/**
 * @en Switch the global `Promise` constructor `Native Promise` or {@link CancelablePromise}. <br>
 *     `Native Promise` constructor is overridden by framework default behaviour.
 * @ja グローバル `Promise` コンストラクタを `Native Promise` または {@link CancelablePromise} に切り替え <br>
 *     既定で `Native Promise` をオーバーライドする.
 *
 * @param enable
 *  - `en` `true`: use {@link CancelablePromise} /  `false`: use `Native Promise`
 *  - `ja` `true`: {@link CancelablePromise} を使用 / `false`: `Native Promise` を使用
 */
export declare function extendPromise(enable: boolean): PromiseConstructor;
/**
 * @en Cancelable base option definition.
 * @ja キャンセル可能な基底オプション
 */
export interface Cancelable {
    cancel?: CancelToken;
}
/**
 * @en Wait for promises done. <br>
 *     While control will be returned immediately when `Promise.all()` fails, but this mehtod waits for including failure.
 * @ja `Promise` オブジェクトの終了まで待機 <br>
 *     `Promise.all()` は失敗するとすぐに制御を返すのに対し、失敗も含めて待つ `Promise` オブジェクトを返却
 *
 * @param promises
 *  - `en` Promise instance array
 *  - `ja` Promise インスタンスの配列を指定
 */
export declare function wait(promises: Promise<unknown>[]): Promise<unknown[]>;
/**
 * @en Cancellation checker method. <br>
 *     It's practicable by `async function`.
 * @ja キャンセルチェッカー <br>
 *     `async function` で使用可能
 *
 * @example <br>
 *
 * ```ts
 *  async function someFunc(token: CancelToken): Promise<{}> {
 *    await checkCanceled(token);
 *    return {};
 *  }
 * ```
 *
 * @param token
 *  - `en` {@link CancelToken} reference. (enable `undefined`)
 *  - `ja` {@link CancelToken} を指定 (undefined 可)
 */
export declare function checkCanceled(token: CancelToken | undefined): Promise<void>;
/**
 * @en Check the status of the promise instance. <br>
 *     It's practicable by `async function`.
 * @ja Promise インスタンスの状態を確認 <br>
 *     `async function` で使用可能
 *
 * @example <br>
 *
 * ```ts
 * import { checkStatus } from '@cdp/runtime';
 *
 * let promise: Promise<unknown>; // some promise instance
 * :
 * const status = await checkStatus(promise);
 * console.log(status);
 * // 'pending' or 'fulfilled' or 'rejected'
 * ```
 *
 * @param promise
 *  - `en` Promise instance
 *  - `ja` Promise インスタンスを指定
 */
export declare function checkStatus(promise: Promise<unknown>): Promise<'pending' | 'fulfilled' | 'rejected'>;
/**
 * @en `Deferred` object class that can operate `reject` and` resolve` from the outside.
 * @ja `reject`, ` resolve` を外部より操作可能な `Deferred` オブジェクトクラス
 *
 * @example <br>
 *
 * ```ts
 * const df = new Deferred();
 * df.resolve();
 * df.reject('reason');
 *
 * await df;
 * ```
 */
export declare class Deferred<T = void> extends CancelablePromise<T> {
    readonly resolve: (arg: T | PromiseLike<T>) => void;
    readonly reject: (reason?: unknown) => void;
    /**
     * constructor
     *
     * @param cancelToken
     *  - `en` {@link CancelToken} instance create from {@link CancelToken.source | CancelToken.source}().
     *  - `ja` {@link CancelToken.source | CancelToken.source}() より作成した {@link CancelToken} インスタンスを指定
     */
    constructor(cancelToken?: CancelToken | null);
    /**
     * constructor
     *
     * @param executor
     *  - `en` A callback used to initialize the promise. This callback is passed two arguments `resolve` and `reject`.
     *  - `ja` promise の初期化に使用するコールバックを指定. `resolve` と `reject` の2つの引数を持つ
     * @param cancelToken
     *  - `en` {@link CancelToken} instance create from {@link CancelToken.source | CancelToken.source}().
     *  - `ja` {@link CancelToken.source | CancelToken.source}() より作成した {@link CancelToken} インスタンスを指定
     */
    constructor(executor: (resolve: (value?: T | PromiseLike<T>) => void, reject: (reason?: unknown) => void) => void, cancelToken?: CancelToken | null);
    /**
     * @en Check the status of this instance. <br>
     *     It's practicable by `async function`.
     * @ja Deferred インスタンスの状態を確認 <br>
     *     `async function` で使用可能
     */
    status(): Promise<'pending' | 'fulfilled' | 'rejected'>;
}
/**
 * @en The class manages lumping multiple `Promise` objects. <br>
 *     It's possible to make them cancel more than one `Promise` which handles different {@link CancelToken} by lumping.
 * @ja 複数 `Promise` オブジェクトを一括管理するクラス <br>
 *     異なる {@link CancelToken} を扱う複数の `Promise` を一括でキャンセルさせることが可能
 */
export declare class PromiseManager {
    private readonly _pool;
    /**
     * @en Add a `Promise` object under the management.
     * @ja `Promise` オブジェクトを管理下に追加
     *
     * @param promise
     *  - `en` any `Promise` instance is available.
     *  - `ja` 任意の `Promise` インスタンス
     * @param cancelSource
     *  - `en` {@link CancelTokenSource} instance made by {@link CancelToken.source | CancelToken.source}().
     *  - `ja` {@link CancelToken.source | CancelToken.source}() で生成される {@link CancelTokenSource} インスタンス
     * @returns
     *  - `en` return the same instance of input `promise` instance.
     *  - `ja` 入力した `promise` と同一インスタンスを返却
     */
    add<T>(promise: Promise<T>, cancelSource?: CancelTokenSource): Promise<T>;
    /**
     * @en Released all instances under the management.
     * @ja 管理対象を破棄
     */
    release(): void;
    /**
     * @en Return `promise` array from under the management.
     * @ja 管理対象の Promise を配列で取得
     */
    promises(): Promise<unknown>[];
    /**
     * @en Call `Promise.all()` for under the management. <br>
     *     Wait for all `fulfilled`.
     * @ja 管理対象に対して `Promise.all()` <br>
     *     すべてが `fulfilled` になるまで待機
     */
    all(): Promise<unknown[]>;
    /**
     * @en Call `Promise.race()` for under the management. <br>
     *     Wait for any `settled`.
     * @ja 管理対象に対して `Promise.race()` <br>
     *     いずれかが `settled` になるまで待機
     */
    race(): Promise<unknown>;
    /**
     * @en Call {@link wait}() for under the management. <br>
     *     Wait for all `settled`. (simplified version)
     * @ja 管理対象に対して {@link wait}() <br>
     *     すべてが `settled` になるまで待機 (簡易バージョン)
     */
    wait(): Promise<unknown[]>;
    /**
     * @en Call `Promise.allSettled()` for under the management. <br>
     *     Wait for all `settled`.
     * @ja 管理対象に対して `Promise.allSettled()` <br>
     *     すべてが `settled` になるまで待機
     */
    allSettled(): Promise<PromiseSettledResult<unknown>[]>;
    /**
     * @en Call `Promise.any()` for under the management. <br>
     *     Wait for any `fulfilled`.
     * @ja 管理対象に対して `Promise.any()` <br>
     *     いずれかが `fulfilled` になるまで待機
     */
    any(): Promise<unknown>;
    /**
     * @en Invoke `cancel` message for under the management promises.
     * @ja 管理対象の `Promise` に対してキャンセルを発行
     *
     * @param reason
     *  - `en` arguments for `cancelSource`
     *  - `ja` `cancelSource` に渡される引数
     * @returns
     *  - `en` `Promise` instance which wait by until cancellation completion.
     *  - `ja` キャンセル完了まで待機する `Promise` インスタンス
     */
    abort<T>(reason?: T): Promise<unknown[]>;
}
/**
 * @en Event observation state definition.
 * @ja イベント購読状態定義
 */
export declare const enum ObservableState {
    /** observable ready */
    ACTIVE = 'active',
    /** NOT observed, but property changes are recorded. */
    SUSEPNDED = 'suspended',
    /** NOT observed, and not recording property changes. */
    DISABLED = 'disabled'
}
/**
 * @en Observable common interface.
 * @ja Observable 共通インターフェイス
 */
export interface IObservable {
    /**
     * @en Subscrive event(s).
     * @ja イベント購読設定
     */
    on(...args: unknown[]): Subscription;
    /**
     * @en Unsubscribe event(s).
     * @ja イベント購読解除
     */
    off(...args: unknown[]): void;
    /**
     * @en Suspend or disable the event observation state.
     * @ja イベント購読状態のサスペンド
     *
     * @param noRecord
     *  - `en` `true`: not recording property changes and clear changes. / `false`: property changes are recorded and fired when {@link resume}() callded. (default)
     *  - `ja` `true`: プロパティ変更も記録せず, 現在の記録も破棄 / `false`: プロパティ変更は記録され, {@link resume}() 時に発火する (既定)
     */
    suspend(noRecord?: boolean): this;
    /**
     * @en Resume the event observation state.
     * @ja イベント購読状態のリジューム
     */
    resume(): this;
    /**
     * @en observation state
     * @ja 購読可能状態
     */
    getObservableState(): ObservableState;
}
/**
 * @en Interface able to access to {@link EventBroker} with {@link IObservable}.
 * @ja {@link IObservable} の持つ内部 {@link EventBroker} にアクセス可能なインターフェイス
 */
export interface IObservableEventBrokerAccess<T extends object = any> extends IObservable {
    /**
     * @en Get {@link EventBroker} instance.
     * @ja {@link EventBroker} インスタンスの取得
     */
    getBroker(): EventBroker<T>;
}
/**
 * @en Check the value-type is {@link IObservable}.
 * @ja {@link IObservable} 型であるか判定
 *
 * @param x
 *  - `en` evaluated value
 *  - `ja` 評価する値
 */
export declare function isObservable(x: unknown): x is IObservable;
/**
 * @en Observable key type definition.
 * @ja 購読可能なキーの型定義
 */
export type ObservableKeys<T extends ObservableObject> = NonFunctionPropertyNames<T>;
/**
 * @en The object class which change can be observed.
 * @ja オブジェクトの変更を監視できるオブジェクトクラス
 *
 * @example <br>
 *
 * - Basic Usage
 *
 * ```ts
 * class Example extends ObservableObject {
 *   public a: number = 0;
 *   public b: number = 0;
 *   public get sum(): number {
 *       return this.a + this.b;
 *   }
 * }
 *
 * const observable = new Example();
 *
 * function onNumChange(newValue: number, oldValue: number, key: string) {
 *   console.log(`${key} changed from ${oldValue} to ${newValue}.`);
 * }
 * observable.on(['a', 'b'], onNumChange);
 *
 * // update
 * observable.a = 100;
 * observable.b = 200;
 *
 * // console out from `async` event loop.
 * // => 'a changed from 0 to 100.'
 * // => 'b changed from 0 to 200.'
 *
 * :
 *
 * function onSumChange(newValue: number, oldValue: number) {
 *   console.log(`sum changed from ${oldValue} to ${newVaue}.`);
 * }
 * observable.on('sum', onSumChange);
 *
 * // update
 * observable.a = 100; // nothing reaction because of no change properties.
 * observable.a = 200;
 *
 * // console out from `async` event loop.
 * // => 'sum changed from 300 to 400.'
 * ```
 */
export declare abstract class ObservableObject implements IObservable {
    /**
     * constructor
     *
     * @param state
     *  - `en` initial state. default: {@link ObservableState.ACTIVE | ObservableState.ACTIVE}
     *  - `ja` 初期状態 既定: {@link ObservableState.ACTIVE | ObservableState.ACTIVE}
     */
    constructor(state?: ObservableState);
    /**
     * @en Subscrive property changes.
     * @ja プロパティ変更購読設定 (全プロパティ監視)
     *
     * @param property
     *  - `en` wild cord signature.
     *  - `ja` ワイルドカード
     * @param listener
     *  - `en` callback function of the property change.
     *  - `ja` プロパティ変更通知コールバック関数
     */
    on(property: '@', listener: (context: ObservableObject) => unknown): Subscription;
    /**
     * @en Subscrive property change(s).
     * @ja プロパティ変更購読設定
     *
     * @param property
     *  - `en` target property.
     *  - `ja` 対象のプロパティ
     * @param listener
     *  - `en` callback function of the property change.
     *  - `ja` プロパティ変更通知コールバック関数
     */
    on<K extends ObservableKeys<this>>(property: K | K[], listener: (newValue: this[K], oldValue: this[K], key: K) => unknown): Subscription;
    /**
     * @en Unsubscribe property changes)
     * @ja プロパティ変更購読解除 (全プロパティ監視)
     *
     * @param property
     *  - `en` wild cord signature.
     *  - `ja` ワイルドカード
     * @param listener
     *  - `en` callback function of the property change.
     *  - `ja` プロパティ変更通知コールバック関数
     */
    off(property: '@', listener?: (context: ObservableObject) => any): void;
    /**
     * @en Unsubscribe property change(s).
     * @ja プロパティ変更購読解除
     *
     * @param property
     *  - `en` target property.
     *         When not set this parameter, everything is released.
     *  - `ja` 対象のプロパティ
     *         指定しない場合はすべて解除
     * @param listener
     *  - `en` callback function of the property change.
     *         When not set this parameter, all same `channel` listeners are released.
     *  - `ja` プロパティ変更通知コールバック関数
     *         指定しない場合は同一 `channel` すべてを解除
     */
    off<K extends ObservableKeys<this>>(property?: K | K[], listener?: (newValue: this[K], oldValue: this[K], key: K) => unknown): void;
    /**
     * @en Suspend or disable the event observation state.
     * @ja イベント購読状態のサスペンド
     *
     * @param noRecord
     *  - `en` `true`: not recording property changes and clear changes. / `false`: property changes are recorded and fired when {@link resume}() callded. (default)
     *  - `ja` `true`: プロパティ変更も記録せず, 現在の記録も破棄 / `false`: プロパティ変更は記録され, {@link resume}() 時に発火する (既定)
     */
    suspend(noRecord?: boolean): this;
    /**
     * @en Resume the event observation state.
     * @ja イベント購読状態のリジューム
     */
    resume(): this;
    /**
     * @en observation state
     * @ja 購読可能状態
     */
    getObservableState(): ObservableState;
    /**
     * @en Create {@link ObservableObject} from any object.
     * @ja 任意のオブジェクトから {@link ObservableObject} を生成
     *
     * @example <br>
     *
     * ```ts
     * const observable = ObservableObject.from({ a: 1, b: 1 });
     * function onNumChange(newValue: number, oldValue: number, key: string) {
     *   console.log(`${key} changed from ${oldValue} to ${newValue}.`);
     * }
     * observable.on(['a', 'b'], onNumChange);
     *
     * // update
     * observable.a = 100;
     * observable.b = 200;
     *
     * // console out from `async` event loop.
     * // => 'a changed from 1 to 100.'
     * // => 'b changed from 1 to 200.'
     * ```
     */
    static from<T extends object>(src: T): ObservableObject & T;
    /**
     * @en Force notify property change(s) in spite of active state.
     * @ja アクティブ状態にかかわらず強制的にプロパティ変更通知を発行
     */
    protected notify(...properties: string[]): void;
}
/**
 * @en Array change type information. <br>
 *     The value is suitable for the number of fluctuation of the element.
 * @ja 配列変更通知のタイプ <br>
 *     値は要素の増減数に相当
 *
 */
export declare const enum ArrayChangeType {
    REMOVE = -1,
    UPDATE = 0,
    INSERT = 1
}
/**
 * @en Array change record information.
 * @ja 配列変更情報
 */
export interface ArrayChangeRecord<T> {
    /**
     * @en The change type information.
     * @ja 配列変更情報の識別子
     */
    readonly type: ArrayChangeType;
    /**
     * @en The change type information. <br>
     *     ※ [Attention] The index will be different from the actual location when array size changed because that determines element operation unit.
     * @ja 変更が発生した配列内の位置の index <br>
     *     ※ [注意] オペレーション単位の index となり, 要素が増減する場合は実際の位置と異なることがある
     */
    readonly index: number;
    /**
     * @en New element's value.
     * @ja 要素の新しい値
     */
    readonly newValue?: T;
    /**
     * @en Old element's value.
     * @ja 要素の古い値
     */
    readonly oldValue?: T;
}
/**
 * @en The array class which change can be observed.
 * @ja 変更監視可能な配列クラス
 *
 * @example <br>
 *
 * - Basic Usage
 *
 * ```ts
 * const obsArray = ObservableArray.from(['a', 'b', 'c']);
 *
 * function onChangeArray(records: ArrayChangeRecord[]) {
 *   console.log(records);
 *   //  [
 *   //    { type: 1, index: 3, newValue: 'x', oldValue: undefined },
 *   //    { type: 1, index: 4, newValue: 'y', oldValue: undefined },
 *   //    { type: 1, index: 5, newValue: 'z', oldValue: undefined }
 *   //  ]
 * }
 * obsArray.on(onChangeArray);
 *
 * function addXYZ() {
 *   obsArray.push('x', 'y', 'z');
 * }
 * ```
 */
export declare class ObservableArray<T = unknown> extends Array<T> implements IObservable {
    /** @final constructor */
    private constructor();
    /**
     * @en Subscrive array change(s).
     * @ja 配列変更購読設定
     *
     * @param listener
     *  - `en` callback function of the array change.
     *  - `ja` 配列変更通知コールバック関数
     */
    on(listener: (records: ArrayChangeRecord<T>[]) => unknown): Subscription;
    /**
     * @en Unsubscribe array change(s).
     * @ja 配列変更購読解除
     *
     * @param listener
     *  - `en` callback function of the array change.
     *         When not set this parameter, all same `channel` listeners are released.
     *  - `ja` 配列変更通知コールバック関数
     *         指定しない場合は同一 `channel` すべてを解除
     */
    off(listener?: (records: ArrayChangeRecord<T>[]) => unknown): void;
    /**
     * @en Suspend or disable the event observation state.
     * @ja イベント購読状態のサスペンド
     *
     * @param noRecord
     *  - `en` `true`: not recording property changes and clear changes. / `false`: property changes are recorded and fired when {@link resume}() callded. (default)
     *  - `ja` `true`: プロパティ変更も記録せず, 現在の記録も破棄 / `false`: プロパティ変更は記録され, {@link resume}() 時に発火する (既定)
     */
    suspend(noRecord?: boolean): this;
    /**
     * @en Resume of the event subscription state.
     * @ja イベント購読状態のリジューム
     */
    resume(): this;
    /**
     * @en observation state
     * @ja 購読可能状態
     */
    getObservableState(): ObservableState;
    /**
     * Sorts an array.
     * @param compareFn The name of the function used to determine the order of the elements. If omitted, the elements are sorted in ascending, ASCII character order.
     */
    sort(comparator?: (lhs: T, rhs: T) => number): this;
    /**
     * Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.
     * @param start The zero-based location in the array from which to start removing elements.
     * @param deleteCount The number of elements to remove.
     */
    splice(start: number, deleteCount?: number): ObservableArray<T>;
    /**
     * Removes elements from an array and, if necessary, inserts new elements in their place, returning the deleted elements.
     * @param start The zero-based location in the array from which to start removing elements.
     * @param deleteCount The number of elements to remove.
     * @param items Elements to insert into the array in place of the deleted elements.
     */
    splice(start: number, deleteCount: number, ...items: T[]): ObservableArray<T>;
    /**
     * Removes the first element from an array and returns it.
     */
    shift(): T | undefined;
    /**
     * Inserts new elements at the start of an array.
     * @param items  Elements to insert at the start of the Array.
     */
    unshift(...items: T[]): number;
    /**
     * Calls a defined callback function on each element of an array, and returns an array that contains the results.
     * @param callbackfn A function that accepts up to three arguments. The map method calls the callbackfn function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    map<U>(callbackfn: (value: T, index: number, array: T[]) => U, thisArg?: unknown): ObservableArray<U>;
}
/**
 * Override return type of prototype methods
 */
export interface ObservableArray<T> {
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: T[][]): ObservableArray<T>;
    /**
     * Combines two or more arrays.
     * @param items Additional items to add to the end of array1.
     */
    concat(...items: (T | T[])[]): ObservableArray<T>;
    /**
     * Reverses the elements in an Array.
     */
    reverse(): this;
    /**
     * Returns a section of an array.
     * @param start The beginning of the specified portion of the array.
     * @param end The end of the specified portion of the array.
     */
    slice(start?: number, end?: number): ObservableArray<T>;
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param callbackfn A function that accepts up to three arguments. The filter method calls the callbackfn function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    filter<S extends T>(callbackfn: (value: T, index: number, array: T[]) => value is S, thisArg?: unknown): ObservableArray<S>;
    /**
     * Returns the elements of an array that meet the condition specified in a callback function.
     * @param callbackfn A function that accepts up to three arguments. The filter method calls the callbackfn function one time for each element in the array.
     * @param thisArg An object to which the this keyword can refer in the callbackfn function. If thisArg is omitted, undefined is used as the this value.
     */
    filter(callbackfn: (value: T, index: number, array: T[]) => unknown, thisArg?: unknown): ObservableArray<T>;
}
/**
 * Override return type of static methods
 */
export declare namespace ObservableArray {
    /**
     * Creates an array from an array-like object.
     * @param arrayLike An array-like or iterable object to convert to an array.
     */
    function from<T>(arrayLike: ArrayLike<T> | Iterable<T>): ObservableArray<T>;
    /**
     * Creates an array from an array-like object.
     * @param arrayLike An array-like or iterable object to convert to an array.
     * @param mapfn A mapping function to call on every element of the array.
     * @param thisArg Value of 'this' used to invoke the mapfn.
     */
    function from<T, U>(arrayLike: ArrayLike<T> | Iterable<T>, mapfn: (this: void, v: T, k: number) => U, thisArg?: undefined): ObservableArray<U>;
    function from<X, T, U>(arrayLike: ArrayLike<T> | Iterable<T>, mapfn: (this: X, v: T, k: number) => U, thisArg: X): ObservableArray<U>;
    /**
     * Returns a new array from a set of elements.
     * @param items A set of elements to include in the new array object.
     */
    function of<T>(...items: T[]): ObservableArray<T>;
}
/**
 * @en Judge fail or not.
 * @ja 失敗判定
 *
 * @param code {@link RESULT_CODE}
 * @returns true: fail result / false: success result
 */
export declare function FAILED(code: number): boolean;
/**
 * @en Judge success or not.
 * @ja 成功判定
 *
 * @param code {@link RESULT_CODE}
 * @returns true: success result / false: fail result
 */
export declare function SUCCEEDED(code: number): boolean;
/**
 * @en Convert to {@link RESULT_CODE} `name` string from {@link RESULT_CODE}.
 * @ja {@link RESULT_CODE} を {@link RESULT_CODE} 文字列に変換
 *
 * @param code {@link RESULT_CODE}
 * @param tag  custom tag if needed.
 * @returns name string ex) '[tag][NOT_SUPPORTED]'
 */
export declare function toNameString(code: number, tag?: string): string;
/**
 * @en Convert to help string from {@link RESULT_CODE}.
 * @ja {@link RESULT_CODE} をヘルプストリングに変換
 *
 * @param code {@link RESULT_CODE}
 * @returns registered help string
 */
export declare function toHelpString(code: number): string;
/**
 * @en A result holder class. <br>
 *     Derived native `Error` class.
 * @ja 処理結果伝達クラス <br>
 *     ネイティブ `Error` の派生クラス
 */
export declare class Result extends Error {
    /**
     * constructor
     *
     * @param code
     *  - `en` result code
     *  - `ja` 結果コード
     * @param message
     *  - `en` result info message
     *  - `ja` 結果情報メッセージ
     * @param options
     *  - `en` error construction options
     *  - `ja` エラー構築オプション
     */
    constructor(code?: number, message?: string, options?: ErrorOptions);
    /**
     * @en {@link RESULT_CODE} value.
     * @ja {@link RESULT_CODE} の値
     */
    readonly code: number;
    /**
     * @en Generated time information.
     * @ja 生成された時刻情報
     */
    readonly time: number;
    /**
     * @en Stock low-level error information.
     * @ja 下位のエラー情報を格納
     */
    readonly cause?: unknown;
    /**
     * @en Judge succeeded or not.
     * @ja 成功判定
     */
    get isSucceeded(): boolean;
    /**
     * @en Judge failed or not.
     * @ja 失敗判定
     */
    get isFailed(): boolean;
    /**
     * @en Judge canceled or not.
     * @ja キャンセルエラー判定
     */
    get isCanceled(): boolean;
    /**
     * @en Get formatted {@link RESULT_CODE} name string.
     * @ja フォーマットされた {@link RESULT_CODE} 名文字列を取得
     */
    get codeName(): string;
    /**
     * @en Get {@link RESULT_CODE} help string.
     * @ja {@link RESULT_CODE} のヘルプストリングを取得
     */
    get help(): string;
}
/** Returns `true` if `x` is `Result`, `false` otherwise. */
export declare function isResult(x: unknown): x is Result;
/**
 * @en Convert to {@link Result} object.
 * @ja {@link Result} オブジェクトに変換
 */
export declare function toResult(o: unknown): Result;
/**
 * @en Create {@link Result} helper.
 * @ja {@link Result} オブジェクト構築ヘルパー
 *
 * @param code
 *  - `en` result code
 *  - `ja` 結果コード
 * @param message
 *  - `en` result info message
 *  - `ja` 結果情報メッセージ
 * @param cause
 *  - `en` low-level error information
 *  - `ja` 下位のエラー情報
 */
export declare function makeResult(code: number, message?: string, cause?: unknown): Result;
/**
 * @en Create canceled {@link Result} helper.
 * @ja キャンセル情報格納 {@link Result} オブジェクト構築ヘルパー
 *
 * @param message
 *  - `en` result info message
 *  - `ja` 結果情報メッセージ
 * @param cause
 *  - `en` low-level error information
 *  - `ja` 下位のエラー情報
 */
export declare function makeCanceledResult(message?: string, cause?: unknown): Result;
/**
 * @en Storage data type set interface.
 * @ja Storage に格納可能な型の集合
 */
export interface StorageDataTypeList {
    string: string;
    number: number;
    boolean: boolean;
    object: object;
}
/**
 * @en Storage data object types.
 * @ja Storage に格納可能な型一覧
 */
export type StorageDataTypes = Types<StorageDataTypeList>;
/**
 * @en Storage data object interface.
 * @ja Storage に格納可能な型
 */
export type StorageData = Record<string, StorageDataTypes>;
/**
 * @en The types by which designation is possible in {@link IStorage.setItem | IStorage.setItem}().
 * @ja {@link IStorage.setItem | IStorage.setItem}() に指定可能な型
 */
export type StorageInputDataTypeList<T extends object> = Types<T> | null | undefined;
/**
 * @en {@link IStorage} common option interface.
 * @ja {@link IStorage} 操作に使用する共通のオプションインターフェイス
 */
export type IStorageOptions = Silenceable & Cancelable;
/**
 * @en {@link IStorage} common format option interface.
 * @ja {@link IStorage} フォーマットに関するオプションインターフェイス
 */
export interface IStorageFormatOptions {
    /** JSON space number */
    jsonSpace?: number;
}
/**
 * @en {@link IStorage} data I/O operation option interface.
 * @ja {@link IStorage} データ I/O 操作に使用するオプションインターフェイス
 */
export interface IStorageDataOptions<T extends StorageDataTypeList, K extends Keys<T>> extends IStorageOptions, IStorageFormatOptions {
    /**
     * @en set convert I/O data type.
     * @ja I/O 時に変換するデータ型を指定
     */
    dataType?: K;
}
/**
 * @en {@link IStorage.getItem | IStorage.getItem}() return types.
 * @ja {@link IStorage.getItem | IStorage.getItem}() の戻り値
 */
export type IStorageDataReturnType<T extends StorageDataTypeList, D extends Types<T>> = TypeToKey<T, D> extends never ? never : D | null;
/**
 * @en {@link IStorage} callback function definition.
 * @ja {@link IStorage} コールバック関数
 */
export type IStorageEventCallback<T extends StorageDataTypeList> = (key: string | null, newValue: Types<T> | null, oldValue: Types<T> | null) => void;
/**
 * @en Async Storage interface. This interface provides the similar to Web Storage API but all methods are promisified.
 * @ja 非同期ストレージインターフェイス. Promise 化した Web Storage API の類似メソッドを提供
 */
export interface IStorage<T extends StorageDataTypeList = StorageDataTypeList> {
    /**
     * @en {@link IStorage} kind signature.
     * @ja {@link IStorage} の種別を表す識別子
     */
    readonly kind: string;
    /**
     * @en Returns the current value associated with the given key, or null if the given key does not exist in the list associated with the object.
     * @ja キーに対応する値を取得. 存在しない場合は null を返却
     *
     * @param key
     *  - `en` access key
     *  - `ja` アクセスキー
     * @param options
     *  - `en` I/O options
     *  - `ja` I/O オプション
     * @returns
     *  - `en` Returns the value which corresponds to a key with type change designated in `dataType`.
     *  - `ja` `dataType` で指定された型変換を行って, キーに対応する値を返却
     */
    getItem<D extends Types<T> = Types<T>>(key: string, options?: IStorageDataOptions<T, never>): Promise<IStorageDataReturnType<T, D>>;
    /**
     * @en Returns the current value associated with the given key, or null if the given key does not exist in the list associated with the object.
     * @ja キーに対応する値を取得. 存在しない場合は null を返却
     *
     * @param key
     *  - `en` access key
     *  - `ja` アクセスキー
     * @param options
     *  - `en` I/O options
     *  - `ja` I/O オプション
     * @returns
     *  - `en` Returns the value which corresponds to a key with type change designated in `dataType`.
     *  - `ja` `dataType` で指定された型変換を行って, キーに対応する値を返却
     */
    getItem<K extends Keys<T>>(key: string, options?: IStorageDataOptions<T, K>): Promise<KeyToType<T, K> | null>;
    /**
     * @en Sets the value of the pair identified by key to value, creating a new key/value pair if none existed for key previously.
     * @ja キーを指定して値を設定. 存在しない場合は新規に作成
     *
     * @param key
     *  - `en` access key
     *  - `ja` アクセスキー
     * @param options
     *  - `en` I/O options
     *  - `ja` I/O オプション
     */
    setItem<V extends StorageInputDataTypeList<T>, K extends Keys<T> = Keys<T>>(key: string, value: V, options?: IStorageDataOptions<T, K>): Promise<void>;
    /**
     * @en Removes the key/value pair with the given key from the list associated with the object, if a key/value pair with the given key exists.
     * @ja 指定されたキーに対応する値が存在すれば削除
     *
     * @param options
     *  - `en` cancel options
     *  - `ja` キャンセルオプション
     */
    removeItem(key: string, options?: IStorageOptions): Promise<void>;
    /**
     * @en Empties the list associated with the object of all key/value pairs, if there are any.
     * @ja すべてのキーに対応する値を削除
     *
     * @param options
     *  - `en` cancel options
     *  - `ja` キャンセルオプション
     */
    clear(options?: IStorageOptions): Promise<void>;
    /**
     * @en Returns all entry keys.
     * @ja すべてのキー一覧を返却
     *
     * @param options
     *  - `en` cancel options
     *  - `ja` キャンセルオプション
     */
    keys(options?: Cancelable): Promise<string[]>;
    /**
     * @en Subscrive event(s).
     * @ja イベント購読設定
     *
     * @param listener
     *  - `en` callback function.
     *  - `ja` たコールバック関数
     */
    on(listener: IStorageEventCallback<T>): Subscription;
    /**
     * @en Unsubscribe event(s).
     * @ja イベント購読解除
     *
     * @param listener
     *  - `en` callback function.
     *         When not set this parameter, listeners are released.
     *  - `ja` コールバック関数
     *         指定しない場合はすべてを解除
     */
    off(listener?: IStorageEventCallback<T>): void;
}
/**
 * @en Registry schema common base interface definition.
 * @ja レジストリスキーマの共通ベースインターフェイス
 */
export interface RegistrySchemaBase {
    /**
     * @en Registry wildcard property.
     * @ja レジストリワイルドカードプロパティ
     */
    '*': void;
}
/**
 * @en Registry event definition
 * @ja レジストリイベント
 */
export interface RegistryEvent<T extends object = any, K extends keyof T = keyof T> {
    /**
     * @en Change event.
     * @ja 変更通知
     *
     * @args [key, newValue, oldValue]
     */
    'change': [
        K | null,
        T[K] | null | undefined,
        T[K] | null | undefined
    ];
    /**
     * @en Before save event.
     * @ja 永続化前に発行
     */
    'will-save': void;
}
/**
 * @en Registry read options.
 * @ja レジストリ読み取り用オプション
 */
export interface RegistryReadOptions {
    /**
     * @en When accessing as a registry key below the unique field value, it's designated. ex) 'private'
     * @ja 固有のフィールド値以下のレジストリキーとしてアクセスする場合に指定 ex) 'private'
     */
    field?: string;
}
/**
 * @en Registry write options.
 * @ja レジストリ書き込み用オプション
 */
export interface RegistryWriteOptions extends RegistryReadOptions, IStorageFormatOptions, Silenceable {
    /**
     * @en If `true` set, no call persistence method when a value is updated.
     * @ja 更新時に保存処理を呼び出したくない場合は `true` を指定
     */
    noSave?: boolean;
}
/**
 * @en Registry save options.
 * @ja レジストリ保存用オプション
 */
export type RegistrySaveOptions = IStorageOptions & IStorageFormatOptions;
/** MemoryStorage I/O options */
export type MemoryStorageOptions<K extends Keys<StorageDataTypeList> = Keys<StorageDataTypeList>> = IStorageDataOptions<StorageDataTypeList, K>;
/** MemoryStorage return value */
export type MemoryStorageResult<K extends Keys<StorageDataTypeList>> = KeyToType<StorageDataTypeList, K>;
/** MemoryStorage data type */
export type MemoryStorageDataTypes = Types<StorageDataTypeList>;
/** MemoryStorage return type */
export type MemoryStorageReturnType<D extends MemoryStorageDataTypes> = IStorageDataReturnType<StorageDataTypeList, D>;
/** MemoryStorage input data type */
export type MemoryStorageInputDataTypes = StorageInputDataTypeList<StorageDataTypeList>;
/** MemoryStorage event callback */
export type MemoryStorageEventCallback = IStorageEventCallback<StorageDataTypeList>;
/**
 * @en Memory storage class. This class doesn't support permaneciation data.
 * @ja メモリーストレージクラス. 本クラスはデータの永続化をサポートしない
 */
export declare class MemoryStorage implements IStorage {
    /**
     * @en {@link IStorage} kind signature.
     * @ja {@link IStorage} の種別を表す識別子
     */
    get kind(): string;
    /**
     * @en Returns the current value associated with the given key, or null if the given key does not exist in the list associated with the object.
     * @ja キーに対応する値を取得. 存在しない場合は null を返却
     *
     * @param key
     *  - `en` access key
     *  - `ja` アクセスキー
     * @param options
     *  - `en` I/O options
     *  - `ja` I/O オプション
     * @returns
     *  - `en` Returns the value which corresponds to a key with type change designated in `dataType`.
     *  - `ja` `dataType` で指定された型変換を行って, キーに対応する値を返却
     */
    getItem<D extends MemoryStorageDataTypes = MemoryStorageDataTypes>(key: string, options?: MemoryStorageOptions<never>): Promise<MemoryStorageReturnType<D>>;
    /**
     * @en Returns the current value associated with the given key, or null if the given key does not exist in the list associated with the object.
     * @ja キーに対応する値を取得. 存在しない場合は null を返却
     *
     * @param key
     *  - `en` access key
     *  - `ja` アクセスキー
     * @param options
     *  - `en` I/O options
     *  - `ja` I/O オプション
     * @returns
     *  - `en` Returns the value which corresponds to a key with type change designated in `dataType`.
     *  - `ja` `dataType` で指定された型変換を行って, キーに対応する値を返却
     */
    getItem<K extends Keys<StorageDataTypeList>>(key: string, options?: MemoryStorageOptions<K>): Promise<MemoryStorageResult<K> | null>;
    /**
     * @en Sets the value of the pair identified by key to value, creating a new key/value pair if none existed for key previously.
     * @ja キーを指定して値を設定. 存在しない場合は新規に作成
     *
     * @param key
     *  - `en` access key
     *  - `ja` アクセスキー
     * @param options
     *  - `en` I/O options
     *  - `ja` I/O オプション
     */
    setItem<V extends MemoryStorageInputDataTypes>(key: string, value: V, options?: MemoryStorageOptions<never>): Promise<void>;
    /**
     * @en Removes the key/value pair with the given key from the list associated with the object, if a key/value pair with the given key exists.
     * @ja 指定されたキーに対応する値が存在すれば削除
     *
     * @param options
     *  - `en` storage options
     *  - `ja` ストレージオプション
     */
    removeItem(key: string, options?: IStorageOptions): Promise<void>;
    /**
     * @en Empties the list associated with the object of all key/value pairs, if there are any.
     * @ja すべてのキーに対応する値を削除
     *
     * @param options
     *  - `en` storage options
     *  - `ja` ストレージオプション
     */
    clear(options?: IStorageOptions): Promise<void>;
    /**
     * @en Returns all entry keys.
     * @ja すべてのキー一覧を返却
     *
     * @param options
     *  - `en` cancel options
     *  - `ja` キャンセルオプション
     */
    keys(options?: Cancelable): Promise<string[]>;
    /**
     * @en Subscrive event(s).
     * @ja イベント購読設定
     *
     * @param listener
     *  - `en` callback function.
     *  - `ja` コールバック関数
     */
    on(listener: MemoryStorageEventCallback): Subscription;
    /**
     * @en Unsubscribe event(s).
     * @ja イベント購読解除
     *
     * @param listener
     *  - `en` callback function.
     *         When not set this parameter, listeners are released.
     *  - `ja` コールバック関数
     *         指定しない場合はすべてを解除
     */
    off(listener?: MemoryStorageEventCallback): void;
    /**
     * @en Return a storage-store object.
     * @ja ストレージストアオブジェクトを返却
     */
    get context(): StorageData;
}
export declare const memoryStorage: MemoryStorage;
/**
 * @en Registry management class for synchronous Read/Write accessible from any {@link IStorage} object.
 * @ja 任意の {@link IStorage} オブジェクトから同期 Read/Write アクセス可能なレジストリ管理クラス
 *
 * @example <br>
 *
 * ```ts
 * // 1. define registry schema
 * interface Schema extends RegistrySchemaBase {
 *    'common/mode': 'normal' | 'specified';
 *    'common/value': number;
 *    'trade/local': { unit: '円' | '$'; rate: number; };
 *    'trade/check': boolean;
 *    'extra/user': string;
 * }
 *
 * // 2. prepare IStorage instance
 * // ex
 * import { webStorage } from '@cdp/runtime';
 *
 * // 3. instantiate this class
 * const reg = new Registry<Schema>(webStorage, '@test');
 *
 * // 4. read example
 * const val = reg.read('common/mode'); // 'normal' | 'specified' | null
 *
 * // 5. write example
 * reg.write('common/mode', 'specified');
 * // reg.write('common/mode', 'hoge'); // compile error
 * ```
 */
export declare class Registry<T extends RegistrySchemaBase = any> extends EventPublisher<RegistryEvent<T>> {
    /**
     * constructor
     *
     * @param storage
     *  - `en` Root key for {@link IStorage}.
     *  - `ja` {@link IStorage} に使用するルートキー
     * @param rootKey
     *  - `en` Root key for {@link IStorage}.
     *  - `ja` {@link IStorage} に使用するルートキー
     * @param formatSpace
     *  - `en` for JSON format space.
     *  - `ja` JSON フォーマットスペースを指定
     */
    constructor(storage: IStorage<any>, rootKey: string, formatSpace?: number);
    /**
     * @en Access to root key.
     * @ja ルートキーを取得
     */
    get rootKey(): string;
    /**
     * @en Access to {@link IStorage} object.
     * @ja {@link IStorage} オブジェクトを取得
     */
    get storage(): IStorage<any>;
    /**
     * @en Read persistence data from {@link IStorage}. The data loaded already will be cleared.
     * @ja {@link IStorage} から永続化したデータを読み込み. すでにキャッシュされているデータは破棄される
     */
    load(options?: IStorageOptions): Promise<void>;
    /**
     * @en Persist data to {@link IStorage}.
     * @ja {@link IStorage} にデータを永続化
     */
    save(options?: RegistrySaveOptions): Promise<void>;
    /**
     * @en Read registry value.
     * @ja レジストリ値の読み取り
     *
     * @param key
     *  - `en` target registry key.
     *  - `ja` 対象のレジストリキーを指定
     * @param options
     *  - `en` read options.
     *  - `ja` 読み取りオプションを指定
     */
    read<K extends keyof T>(key: K, options?: RegistryReadOptions): T[K] | null;
    /**
     * @en Write registry value.
     * @ja レジストリ値の書き込み
     *
     * @param key
     *  - `en` target registry key.
     *  - `ja` 対象のレジストリキーを指定
     * @param value
     *  - `en` update value. if `null` set to delete.
     *  - `ja` 更新する値. `null` は削除
     * @param options
     *  - `en` write options.
     *  - `ja` 書き込みオプションを指定
     */
    write<K extends keyof T>(key: K, value: T[K] | null, options?: RegistryWriteOptions): void;
    /**
     * @en Delete registry key.
     * @ja レジストリキーの削除
     *
     * @param key
     *  - `en` target registry key.
     *  - `ja` 対象のレジストリキーを指定
     * @param options
     *  - `en` read options.
     *  - `ja` 書き込みオプションを指定
     */
    delete<K extends keyof T>(key: K, options?: RegistryWriteOptions): void;
    /**
     * @en Clear all registry.
     * @ja レジストリの全削除
     *
     * @param options
     *  - `en` read options.
     *  - `ja` 書き込みオプションを指定
     */
    clear(options?: RegistryWriteOptions): void;
}
/**
 * @en {@link TemplateEngine} token structure.
 * @ja {@link TemplateEngine} token 型
 */
export type TemplateToken = unknown;
/**
 * @en Delimiters definition for {@link TemplateEngine}. ex) ['{{','}}']
 * @ja {@link TemplateEngine} に使用する区切り文字 ex) ['{{','}}']
 */
export type TemplateDelimiters = [
    string,
    string
];
/**
 * @en Scanner interface.
 * @ja スキャナーインターフェイス
 */
export interface TemplateScanner {
    /**
     * Returns current scanning position.
     */
    readonly pos: number;
    /**
     * Returns string  source.
     */
    readonly source: string;
    /**
     * Returns `true` if the tail is empty (end of string).
     */
    readonly eos: boolean;
    /**
     * Tries to match the given regular expression at the current position.
     * Returns the matched text if it can match, the empty string otherwise.
     */
    scan(regexp: RegExp): string;
    /**
     * Skips all text until the given regular expression can be matched. Returns
     * the skipped string, which is the entire tail if no match can be made.
     */
    scanUntil(regexp: RegExp): string;
}
/**
 * @en Context interface.
 * @ja コンテキストインターフェイス
 */
export interface TemplateContext {
    /**
     * View parameter getter.
     */
    readonly view: PlainObject;
    /**
     * Creates a new context using the given view with this context
     * as the parent.
     */
    push(view: PlainObject): TemplateContext;
    /**
     * Returns the value of the given name in this context, traversing
     * up the context hierarchy if the value is absent in this context's view.
     */
    lookup(name: string): unknown;
}
export type TemplateViewParam = PlainObject | TemplateContext;
export type TemplatePartialLookupFunction = (partialName?: string) => string | undefined | null;
export type TemplatePartialParam = PlainObject | TemplatePartialLookupFunction;
/**
 * @en Writer interface.
 * @ja ライターインターフェイス
 */
export interface TemplateWriter {
    /**
     * Parses and caches the given `template` according to the given `tags` or
     * `mustache.tags` if `tags` is omitted,  and returns the array of tokens
     * that is generated from the parse.
     */
    parse(template: string, tags?: TemplateDelimiters): {
        tokens: TemplateToken[];
        cacheKey: string;
    };
    /**
     * High-level method that is used to render the given `template` with
     * the given `view`.
     *
     * The optional `partials` argument may be an object that contains the
     * names and templates of partials that are used in the template. It may
     * also be a function that is used to load partial templates on the fly
     * that takes a single argument: the name of the partial.
     *
     * If the optional `tags` argument is given here it must be an array with two
     * string values: the opening and closing tags used in the template (e.g.
     * [ '<%', '%>' ]). The default is to mustache.tags.
     */
    render(template: string, view: TemplateViewParam, partials?: TemplatePartialParam, tags?: TemplateDelimiters): string;
    /**
     * Low-level method that renders the given array of `tokens` using
     * the given `context` and `partials`.
     *
     * Note: The `originalTemplate` is only ever used to extract the portion
     * of the original template that was contained in a higher-order section.
     * If the template doesn't use higher-order sections, this argument may
     * be omitted.
     */
    renderTokens(tokens: TemplateToken[], view: TemplateViewParam, partials?: TemplatePartialParam, originalTemplate?: string, tags?: TemplateDelimiters): string;
}
export type JSTParam = AnyObject;
/**
 * @en Compiled JavaScript template interface
 * @ja コンパイル済み テンプレート格納インターフェイス
 */
export interface JST {
    /**
     * @en Get compiled template's tokens.
     * @ja コンパイルされたテンプレートトークンの取得
     */
    readonly tokens: TemplateToken[];
    /**
     * @en Cache key
     * @ja キャッシュキー
     */
    readonly cacheKey: string;
    /**
     * @en Cache location information
     * @ja キャッシュロケーション情報
     */
    readonly cacheLocation: string[];
    /**
     * @en Get result string that applied given parameter(s).
     * @ja パラメータを適用した結果を文字列として取得
     *
     * @param view
     *  - `en` template parameters for source.
     *  - `ja` テンプレートパラメータ
     * @param partials
     *  - `en` partial template source information.
     *  - `ja` 部分テンプレート情報
     * @returns
     *  - `en` applied parameters string.
     *  - `ja` パラメータを適用した文字列
     */
    (view?: JSTParam, partials?: JSTParam): string;
}
/**
 * @en Value escaper definition.
 * @ja エスケーパーの定義
 */
export type TemplateEscaper = typeof escapeHTML;
/**
 * @en {@link ITemplateEngine} base type definition.
 * @ja {@link ITemplateEngine} 基底型
 */
export interface ITemplateEngine {
}
/**
 * @en {@link TemplateEngine} internal I/F accssor.
 * @ja {@link TemplateEngine} 内部インターフェイスのアクセッサ
 */
export interface TemplateAccessor extends ITemplateEngine {
    /** Create {@link TemplateScanner} instance */
    createScanner(src: string): TemplateScanner;
    /** Create {@link TemplateContext} instance */
    createContext(view: TemplateViewParam, parentContext?: TemplateContext): TemplateContext;
    /** Create {@link TemplateWriter} instance */
    createWriter(): TemplateWriter;
}
/**
 * @en {@link TemplateEngine} global settng options
 * @ja {@link TemplateEngine} グローバル設定オプション
 */
export interface TemplateGlobalSettings {
    writer?: TemplateWriter;
    tags?: TemplateDelimiters;
    escape?: TemplateEscaper;
}
/**
 * @en {@link TemplateEngine} compile options
 * @ja {@link TemplateEngine} コンパイルオプション
 */
export interface TemplateCompileOptions {
    tags?: TemplateDelimiters;
}
/**
 * @en TemplateEngine utility class.
 * @ja TemplateEngine ユーティリティクラス
 */
export declare class TemplateEngine implements ITemplateEngine {
    /**
     * @en Get {@link JST} from template source.
     * @ja テンプレート文字列から {@link JST} を取得
     *
     * @param template
     *  - `en` template source string
     *  - `ja` テンプレート文字列
     * @param options
     *  - `en` compile options
     *  - `ja` コンパイルオプション
     */
    static compile(template: string, options?: TemplateCompileOptions): JST;
    /**
     * @en Clears all cached templates in the default {@link TemplateWriter}.
     * @ja 既定の {@link TemplateWriter} のすべてのキャッシュを削除
     */
    static clearCache(): void;
    /**
     * @en Change {@link TemplateEngine} global settings.
     * @ja {@link TemplateEngine} グローバル設定の更新
     *
     * @param settings
     *  - `en` new settings
     *  - `ja` 新しい設定値
     * @returns
     *  - `en` old settings
     *  - `ja` 古い設定値
     */
    static setGlobalSettings(setiings: TemplateGlobalSettings): TemplateGlobalSettings;
}
export {
    CancelablePromise as Promise,
};
import './result-code-defs';
import RESULT_CODE = CDP_DECLARE.RESULT_CODE;
import RESULT_CODE_BASE = CDP_DECLARE.RESULT_CODE_BASE;
import RESULT_CODE_RANGE = CDP_DECLARE.RESULT_CODE_RANGE;
import LOCAL_CODE_RANGE_GUIDE = CDP_DECLARE.LOCAL_CODE_RANGE_GUIDE;
import DECLARE_SUCCESS_CODE = CDP_DECLARE.DECLARE_SUCCESS_CODE;
import DECLARE_ERROR_CODE = CDP_DECLARE.DECLARE_ERROR_CODE;
import ASSIGN_RESULT_CODE = CDP_DECLARE.ASSIGN_RESULT_CODE;
export { RESULT_CODE, RESULT_CODE_BASE, RESULT_CODE_RANGE, LOCAL_CODE_RANGE_GUIDE, DECLARE_SUCCESS_CODE, DECLARE_ERROR_CODE, ASSIGN_RESULT_CODE, };
