/*!
 * @cdp/lib-web 0.9.17
 *   Generated by 'cdp-task bundle dts' task.
 *   - built with TypeScript 5.3.3
 *   - includes:
 *     - @cdp/extension-i18n
 *     - @cdp/extension-template
 *     - @cdp/extension-template-bridge
 *     - @cdp/extension-path2regexp
 *     - @cdp/dom
 *     - @cdp/view
 *     - @cdp/environment
 *     - @cdp/web-utils
 *     - @cdp/web-storage
 *     - @cdp/template
 *     - @cdp/i18n
 *     - @cdp/router
 *     - @cdp/data-sync
 *     - @cdp/model
 *     - @cdp/app
 *     - @cdp/collection
 */

declare const i18n: i18n.i18n;
declare namespace i18n {
    export type $MergeBy<T, K> = Omit<T, keyof K> & K;
    export type $Dictionary<T = unknown> = {
        [key: string]: T;
    };
    export type $OmitArrayKeys<Arr> = Arr extends readonly any[] ? Omit<Arr, keyof any[]> : Arr;
    export type $PreservedValue<Value, Fallback> = [
        Value
    ] extends [
        never
    ] ? Fallback : Value;
    export type $SpecialObject = object | Array<string | object>;
    /**
     * This interface can be augmented by users to add types to `i18next` default TypeOptions.
     *
     * Usage:
     * ```ts
     * // i18next.d.ts
     * import 'i18next';
     * export module 'i18next' {
     *   interface CustomTypeOptions {
     *     defaultNS: 'custom';
     *     returnNull: false;
     *     returnObjects: false;
     *     nsSeparator: ':';
     *     keySeparator: '.';
     *     jsonFormat: 'v4';
     *     allowObjectInHTMLChildren: false;
     *     resources: {
     *       custom: {
     *         foo: 'foo';
     *       };
     *     };
     *   }
     * }
     * ```
     */
    export interface CustomTypeOptions {
    }
    /**
     * This interface can be augmented by users to add types to `i18next` default PluginOptions.
     */
    export interface CustomPluginOptions {
    }
    export type TypeOptions = $MergeBy<{
        /**
         * Allows null values as valid translation
         */
        returnNull: false;
        /**
         * Allows objects as valid translation result
         */
        returnObjects: false;
        /**
         * Char to separate keys
         */
        keySeparator: '.';
        /**
         * Char to split namespace from key
         */
        nsSeparator: ':';
        /**
         * Char to split plural from key
         */
        pluralSeparator: '_';
        /**
         * Char to split context from key
         */
        contextSeparator: '_';
        /**
         * Default namespace used if not passed to translation function
         */
        defaultNS: 'translation';
        /**
         * Fallback namespace used if translation not found in given namespace
         * @default false
         */
        fallbackNS: false;
        /**
         * Json Format Version - V4 allows plural suffixes
         */
        jsonFormat: 'v4';
        /**
         * Resources to initialize with
         */
        resources: object;
        /**
         * Flag that allows HTML elements to receive objects. This is only useful for React applications
         * where you pass objects to HTML elements so they can be replaced to their respective interpolation
         * values (mostly with Trans component)
         */
        allowObjectInHTMLChildren: false;
        /**
         * Prefix for interpolation
         */
        interpolationPrefix: '{{';
        /**
         * Suffix for interpolation
         */
        interpolationSuffix: '}}';
    }, CustomTypeOptions>;
    export type PluginOptions<T> = $MergeBy<{
        /**
         * Options for language detection - check documentation of plugin
         * @default undefined
         */
        detection?: object;
        /**
         * Options for backend - check documentation of plugin
         * @default undefined
         */
        backend?: T;
        /**
         * Options for cache layer - check documentation of plugin
         * @default undefined
         */
        cache?: object;
        /**
         * Options for i18n message format - check documentation of plugin
         * @default undefined
         */
        i18nFormat?: object;
    }, CustomPluginOptions>;
    export type FormatFunction = (value: any, format?: string, lng?: string, options?: InterpolationOptions & $Dictionary<any>) => string;
    export interface InterpolationOptions {
        /**
         * Format function see formatting for details
         * @default noop
         */
        format?: FormatFunction;
        /**
         * Used to separate format from interpolation value
         * @default ','
         */
        formatSeparator?: string;
        /**
         * Escape function
         * @default str => str
         */
        escape?(str: string): string;
        /**
         * Always format interpolated values.
         * @default false
         */
        alwaysFormat?: boolean;
        /**
         * Escape passed in values to avoid xss injection
         * @default true
         */
        escapeValue?: boolean;
        /**
         * If true, then value passed into escape function is not casted to string, use with custom escape function that does its own type check
         * @default false
         */
        useRawValueToEscape?: boolean;
        /**
         * Prefix for interpolation
         * @default '{{'
         */
        prefix?: string;
        /**
         * Suffix for interpolation
         * @default '}}'
         */
        suffix?: string;
        /**
         * Escaped prefix for interpolation (regexSafe)
         * @default undefined
         */
        prefixEscaped?: string;
        /**
         * Escaped suffix for interpolation (regexSafe)
         * @default undefined
         */
        suffixEscaped?: string;
        /**
         * Suffix to unescaped mode
         * @default undefined
         */
        unescapeSuffix?: string;
        /**
         * Prefix to unescaped mode
         * @default '-'
         */
        unescapePrefix?: string;
        /**
         * Prefix for nesting
         * @default '$t('
         */
        nestingPrefix?: string;
        /**
         * Suffix for nesting
         * @default ')'
         */
        nestingSuffix?: string;
        /**
         * Escaped prefix for nesting (regexSafe)
         * @default undefined
         */
        nestingPrefixEscaped?: string;
        /**
         * Escaped suffix for nesting (regexSafe)
         * @default undefined
         */
        nestingSuffixEscaped?: string;
        /**
         * Separates options from key
         * @default ','
         */
        nestingOptionsSeparator?: string;
        /**
         * Global variables to use in interpolation replacements
         * @default undefined
         */
        defaultVariables?: {
            [index: string]: any;
        };
        /**
         * After how many interpolation runs to break out before throwing a stack overflow
         * @default 1000
         */
        maxReplaces?: number;
        /**
         * If true, it will skip to interpolate the variables
         * @default true
         */
        skipOnVariables?: boolean;
    }
    export interface FallbackLngObjList {
        [language: string]: readonly string[];
    }
    export type FallbackLng = string | readonly string[] | FallbackLngObjList | ((code: string) => string | readonly string[] | FallbackLngObjList);
    export interface ReactOptions {
        /**
         * Set it to fallback to let passed namespaces to translated hoc act as fallbacks
         * @default 'default'
         */
        nsMode?: 'default' | 'fallback';
        /**
         * Set it to the default parent element created by the Trans component.
         * @default 'div'
         */
        defaultTransParent?: string;
        /**
         * Set which events trigger a re-render, can be set to false or string of events
         * @default 'languageChanged'
         */
        bindI18n?: string | false;
        /**
         * Set which events on store trigger a re-render, can be set to false or string of events
         * @default ''
         */
        bindI18nStore?: string | false;
        /**
         * Set fallback value for Trans components without children
         * @default undefined
         */
        transEmptyNodeValue?: string;
        /**
         * Set it to false if you do not want to use Suspense
         * @default true
         */
        useSuspense?: boolean;
        /**
         * Function to generate an i18nKey from the defaultValue (or Trans children)
         * when no key is provided.
         * By default, the defaultValue (Trans text) itself is used as the key.
         * If you want to require keys for all translations, supply a function
         * that always throws an error.
         * @default undefined
         */
        hashTransKey?(defaultValue: TOptionsBase['defaultValue']): TOptionsBase['defaultValue'];
        /**
         * Convert eg. <br/> found in translations to a react component of type br
         * @default true
         */
        transSupportBasicHtmlNodes?: boolean;
        /**
         * Which nodes not to convert in defaultValue generation in the Trans component.
         * @default ['br', 'strong', 'i', 'p']
         */
        transKeepBasicHtmlNodesFor?: readonly string[];
        /**
         * Wrap text nodes in a user-specified element.
         * @default ''
         */
        transWrapTextNodes?: string;
        /**
         * Optional keyPrefix that will be automatically applied to returned t function in useTranslation for example.
         * @default undefined
         */
        keyPrefix?: string;
        /**
         * Unescape function
         * by default it unescapes some basic html entities
         */
        unescape?(str: string): string;
    }
    export type ResourceKey = string | {
        [key: string]: any;
    };
    export interface ResourceLanguage {
        [namespace: string]: ResourceKey;
    }
    export interface Resource {
        [language: string]: ResourceLanguage;
    }
    export interface InitOptions<T = object> extends PluginOptions<T> {
        /**
         * Logs info level to console output. Helps finding issues with loading not working.
         * @default false
         */
        debug?: boolean;
        /**
         * Resources to initialize with (if not using loading or not appending using addResourceBundle)
         * @default undefined
         */
        resources?: Resource;
        /**
         * Allow initializing with bundled resources while using a backend to load non bundled ones.
         * @default false
         */
        partialBundledLanguages?: boolean;
        /**
         * Language to use (overrides language detection)
         * @default undefined
         */
        lng?: string;
        /**
         * Language to use if translations in user language are not available.
         * @default 'dev'
         */
        fallbackLng?: false | FallbackLng;
        /**
         * Array of allowed languages
         * @default false
         */
        supportedLngs?: false | readonly string[];
        /**
         * If true will pass eg. en-US if finding en in supportedLngs
         * @default false
         */
        nonExplicitSupportedLngs?: boolean;
        /**
         * Language codes to lookup, given set language is
         * 'en-US': 'all' --> ['en-US', 'en', 'dev'],
         * 'currentOnly' --> 'en-US',
         * 'languageOnly' --> 'en'
         * @default 'all'
         */
        load?: 'all' | 'currentOnly' | 'languageOnly';
        /**
         * Array of languages to preload. Important on server-side to assert translations are loaded before rendering views.
         * @default false
         */
        preload?: false | readonly string[];
        /**
         * Language will be lowercased eg. en-US --> en-us
         * @default false
         */
        lowerCaseLng?: boolean;
        /**
         * Language will be lowercased EN --> en while leaving full locales like en-US
         * @default false
         */
        cleanCode?: boolean;
        /**
         * String or array of namespaces to load
         * @default 'translation'
         */
        ns?: string | readonly string[];
        /**
         * Default namespace used if not passed to translation function
         * @default 'translation'
         */
        defaultNS?: string | false | readonly string[];
        /**
         * String or array of namespaces to lookup key if not found in given namespace.
         * @default false
         */
        fallbackNS?: false | string | readonly string[];
        /**
         * Calls save missing key function on backend if key not found.
         * @default false
         */
        saveMissing?: boolean;
        /**
         * Calls save missing key function on backend if key not found also for plural forms.
         * @default false
         */
        saveMissingPlurals?: boolean;
        /**
         * Experimental: enable to update default values using the saveMissing
         * (Works only if defaultValue different from translated value.
         * Only useful on initial development or when keeping code as source of truth not changing values outside of code.
         * Only supported if backend supports it already)
         * @default false
         */
        updateMissing?: boolean;
        /**
         * @default 'fallback'
         */
        saveMissingTo?: 'current' | 'all' | 'fallback';
        /**
         * Used to not fallback to the key as default value, when using saveMissing functionality.
         * i.e. when using with i18next-http-backend this will result in having a key with an empty string value.
         * @default false
         */
        missingKeyNoValueFallbackToKey?: boolean;
        /**
         * Used for custom missing key handling (needs saveMissing set to true!)
         * @default false
         */
        missingKeyHandler?: false | ((lngs: readonly string[], ns: string, key: string, fallbackValue: string, updateMissing: boolean, options: any) => void);
        /**
         * Receives a key that was not found in `t()` and returns a value, that will be returned by `t()`
         * @default noop
         */
        parseMissingKeyHandler?(key: string, defaultValue?: string): any;
        /**
         * Appends namespace to missing key
         * @default false
         */
        appendNamespaceToMissingKey?: boolean;
        /**
         * Gets called in case a interpolation value is undefined. This method will not be called if the value is empty string or null
         * @default noop
         */
        missingInterpolationHandler?: (text: string, value: any, options: InitOptions) => any;
        /**
         * Will use 'plural' as suffix for languages only having 1 plural form, setting it to false will suffix all with numbers
         * @default true
         */
        simplifyPluralSuffix?: boolean;
        /**
         * String or array of postProcessors to apply per default
         * @default false
         */
        postProcess?: false | string | readonly string[];
        /**
         * passthrough the resolved object including 'usedNS', 'usedLang' etc into options object of postprocessors as 'i18nResolved' property
         * @default false
         */
        postProcessPassResolved?: boolean;
        /**
         * Allows null values as valid translation
         * @default false
         */
        returnNull?: boolean;
        /**
         * Allows empty string as valid translation
         * @default true
         */
        returnEmptyString?: boolean;
        /**
         * Allows objects as valid translation result
         * @default false
         */
        returnObjects?: boolean;
        /**
         * Returns an object that includes information about the used language, namespace, key and value
         * @default false
         */
        returnDetails?: boolean;
        /**
         * Gets called if object was passed in as key but returnObjects was set to false
         * @default noop
         */
        returnedObjectHandler?(key: string, value: string, options: any): void;
        /**
         * Char, eg. '\n' that arrays will be joined by
         * @default false
         */
        joinArrays?: false | string;
        /**
         * Sets defaultValue
         * @default args => ({ defaultValue: args[1] })
         */
        overloadTranslationOptionHandler?(args: string[]): TOptions;
        /**
         * @see https://www.i18next.com/translation-function/interpolation
         */
        interpolation?: InterpolationOptions;
        /**
         * Options for react - check documentation of plugin
         * @default undefined
         */
        react?: ReactOptions;
        /**
         * Triggers resource loading in init function inside a setTimeout (default async behaviour).
         * Set it to false if your backend loads resources sync - that way calling i18next.t after
         * init is possible without relaying on the init callback.
         * @default true
         */
        initImmediate?: boolean;
        /**
         * Char to separate keys
         * @default '.'
         */
        keySeparator?: false | string;
        /**
         * Char to split namespace from key
         * @default ':'
         */
        nsSeparator?: false | string;
        /**
         * Char to split plural from key
         * @default '_'
         */
        pluralSeparator?: string;
        /**
         * Char to split context from key
         * @default '_'
         */
        contextSeparator?: string;
        /**
         * Prefixes the namespace to the returned key when using `cimode`
         * @default false
         */
        appendNamespaceToCIMode?: boolean;
        /**
         * Compatibility JSON version
         * @default 'v4'
         */
        compatibilityJSON?: 'v1' | 'v2' | 'v3' | 'v4';
        /**
         * Options for https://github.com/locize/locize-lastused
         * @default undefined
         */
        locizeLastUsed?: {
            /**
             * The id of your locize project
             */
            projectId: string;
            /**
             * An api key if you want to send missing keys
             */
            apiKey?: string;
            /**
             * The reference language of your project
             * @default 'en'
             */
            referenceLng?: string;
            /**
             * Version
             * @default 'latest'
             */
            version?: string;
            /**
             * Debounce interval to send data in milliseconds
             * @default 90000
             */
            debounceSubmit?: number;
            /**
             * Hostnames that are allowed to send last used data.
             * Please keep those to your local system, staging, test servers (not production)
             * @default ['localhost']
             */
            allowedHosts?: readonly string[];
        };
        /**
         * Automatically lookup for a flat key if a nested key is not found an vice-versa
         * @default true
         */
        ignoreJSONStructure?: boolean;
        /**
         * Limit parallelism of calls to backend
         * This is needed to prevent trying to open thousands of
         * sockets or file descriptors, which can cause failures
         * and actually make the entire process take longer.
         * @default 10
         */
        maxParallelReads?: number;
        /**
         * The maximum number of retries to perform.
         * Note that retries are only performed when a request has no response
         * and throws an error.
         * The default value is used if value is set below 0.
         * @default 5
         */
        maxRetries?: number;
        /**
         * Set how long to wait, in milliseconds, between retries of failed requests.
         * This number is compounded by a factor of 2 for subsequent retry.
         * The default value is used if value is set below 1ms.
         * @default 350
         */
        retryTimeout?: number;
    }
    export interface TOptionsBase {
        /**
         * Default value to return if a translation was not found
         */
        defaultValue?: unknown;
        /**
         * Count value used for plurals
         */
        count?: number;
        /**
         * Ordinal flag for ordinal plurals
         */
        ordinal?: boolean;
        /**
         * Used for contexts (eg. male\female)
         */
        context?: any;
        /**
         * Object with vars for interpolation - or put them directly in options
         */
        replace?: any;
        /**
         * Override language to use
         */
        lng?: string;
        /**
         * Override languages to use
         */
        lngs?: readonly string[];
        /**
         * Override language to lookup key if not found see fallbacks for details
         */
        fallbackLng?: FallbackLng;
        /**
         * Override namespaces (string or array)
         */
        ns?: Namespace;
        /**
         * Override char to separate keys
         */
        keySeparator?: false | string;
        /**
         * Override char to split namespace from key
         */
        nsSeparator?: false | string;
        /**
         * Accessing an object not a translation string (can be set globally too)
         */
        returnObjects?: boolean;
        /**
         * Returns an object that includes information about the used language, namespace, key and value
         */
        returnDetails?: boolean;
        /**
         * Char, eg. '\n' that arrays will be joined by (can be set globally too)
         */
        joinArrays?: string;
        /**
         * String or array of postProcessors to apply see interval plurals as a sample
         */
        postProcess?: string | readonly string[];
        /**
         * Override interpolation options
         */
        interpolation?: InterpolationOptions;
    }
    export type TOptions<TInterpolationMap extends object = $Dictionary> = TOptionsBase & TInterpolationMap;
    export type FlatNamespace = $PreservedValue<keyof TypeOptions['resources'], string>;
    export type Namespace<T = FlatNamespace> = T | readonly T[];
    export type DefaultNamespace = TypeOptions['defaultNS'];
    /** @todo consider to replace {} with Record<string, never> */
    /* eslint @typescript-eslint/ban-types: ['error', { types: { '{}': false } }] */
    // Type Options
    export type _ReturnObjects = TypeOptions['returnObjects'];
    export type _ReturnNull = TypeOptions['returnNull'];
    export type _KeySeparator = TypeOptions['keySeparator'];
    export type _NsSeparator = TypeOptions['nsSeparator'];
    export type _PluralSeparator = TypeOptions['pluralSeparator'];
    export type _ContextSeparator = TypeOptions['contextSeparator'];
    export type _FallbackNamespace = TypeOptions['fallbackNS'];
    export type _Resources = TypeOptions['resources'];
    export type _JSONFormat = TypeOptions['jsonFormat'];
    export type _InterpolationPrefix = TypeOptions['interpolationPrefix'];
    export type _InterpolationSuffix = TypeOptions['interpolationSuffix'];
    export type $IsResourcesDefined = [
        keyof _Resources
    ] extends [
        never
    ] ? false : true;
    export type $ValueIfResourcesDefined<Value, Fallback> = $IsResourcesDefined extends true ? Value : Fallback;
    export type $FirstNamespace<Ns extends Namespace> = Ns extends readonly any[] ? Ns[0] : Ns;
    export type Resources = $ValueIfResourcesDefined<_Resources, $Dictionary<string>>;
    export type PluralSuffix = _JSONFormat extends 'v4' ? 'zero' | 'one' | 'two' | 'few' | 'many' | 'other' : number | 'plural';
    export type WithOrWithoutPlural<Key> = _JSONFormat extends 'v4' | 'v3' ? Key extends `${infer KeyWithoutOrdinalPlural}${_PluralSeparator}ordinal${_PluralSeparator}${PluralSuffix}` ? KeyWithoutOrdinalPlural | Key : Key extends `${infer KeyWithoutPlural}${_PluralSeparator}${PluralSuffix}` ? KeyWithoutPlural | Key : Key : Key;
    export type JoinKeys<K1, K2> = `${K1 & string}${_KeySeparator}${K2 & string}`;
    export type AppendNamespace<Ns, Keys> = `${Ns & string}${_NsSeparator}${Keys & string}`;
    /** ****************************************************
     * Build all keys and key prefixes based on Resources *
     ***************************************************** */
    export type KeysBuilderWithReturnObjects<Res, Key = keyof Res> = Key extends keyof Res ? Res[Key] extends $Dictionary | readonly unknown[] ? JoinKeys<Key, WithOrWithoutPlural<keyof $OmitArrayKeys<Res[Key]>>> | JoinKeys<Key, KeysBuilderWithReturnObjects<Res[Key]>> : never : never;
    export type KeysBuilderWithoutReturnObjects<Res, Key = keyof $OmitArrayKeys<Res>> = Key extends keyof Res ? Res[Key] extends $Dictionary | readonly unknown[] ? JoinKeys<Key, KeysBuilderWithoutReturnObjects<Res[Key]>> : Key : never;
    export type KeysBuilder<Res, WithReturnObjects> = $IsResourcesDefined extends true ? WithReturnObjects extends true ? keyof Res | KeysBuilderWithReturnObjects<Res> : KeysBuilderWithoutReturnObjects<Res> : string;
    export type KeysWithReturnObjects = {
        [Ns in FlatNamespace]: WithOrWithoutPlural<KeysBuilder<Resources[Ns], true>>;
    };
    export type KeysWithoutReturnObjects = {
        [Ns in FlatNamespace]: WithOrWithoutPlural<KeysBuilder<Resources[Ns], false>>;
    };
    export type ResourceKeys<WithReturnObjects = _ReturnObjects> = WithReturnObjects extends true ? KeysWithReturnObjects : KeysWithoutReturnObjects;
    /** **********************************************************************
     * Parse t function keys based on the namespace, options and key prefix *
     *********************************************************************** */
    export type KeysByTOptions<TOpt extends TOptions> = TOpt['returnObjects'] extends true ? ResourceKeys<true> : ResourceKeys;
    export type NsByTOptions<Ns extends Namespace, TOpt extends TOptions> = TOpt['ns'] extends Namespace ? TOpt['ns'] : Ns;
    export type ParseKeysByKeyPrefix<Keys, KPrefix> = KPrefix extends string ? Keys extends `${KPrefix}${_KeySeparator}${infer Key}` ? Key : never : Keys;
    export type ParseKeysByNamespaces<Ns extends Namespace, Keys> = Ns extends readonly (infer UnionNsps)[] ? UnionNsps extends keyof Keys ? AppendNamespace<UnionNsps, Keys[UnionNsps]> : never : never;
    export type ParseKeysByFallbackNs<Keys extends $Dictionary> = _FallbackNamespace extends false ? never : _FallbackNamespace extends (infer UnionFallbackNs extends string)[] ? Keys[UnionFallbackNs] : Keys[_FallbackNamespace & string];
    export type FilterKeysByContext<Keys, TOpt extends TOptions> = TOpt['context'] extends string ? Keys extends `${infer Prefix}${_ContextSeparator}${TOpt['context']}${infer Suffix}` ? `${Prefix}${Suffix}` : never : Keys;
    export type ParseKeys<Ns extends Namespace = DefaultNamespace, TOpt extends TOptions = {}, KPrefix = undefined, Keys extends $Dictionary = KeysByTOptions<TOpt>, ActualNS extends Namespace = NsByTOptions<Ns, TOpt>> = $IsResourcesDefined extends true ? FilterKeysByContext<ParseKeysByKeyPrefix<Keys[$FirstNamespace<ActualNS>], KPrefix> | ParseKeysByNamespaces<ActualNS, Keys> | ParseKeysByFallbackNs<Keys>, TOpt> : string;
    /** *******************************************************
     * Parse t function return type and interpolation values *
     ******************************************************** */
    export type ParseInterpolationValues<Ret> = Ret extends `${string}${_InterpolationPrefix}${infer Value}${_InterpolationSuffix}${infer Rest}` ? (Value extends `${infer ActualValue},${string}` ? ActualValue : Value) | ParseInterpolationValues<Rest> : never;
    export type InterpolationMap<Ret> = Record<$PreservedValue<ParseInterpolationValues<Ret>, string>, unknown>;
    export type ParseTReturnPlural<Res, Key, KeyWithPlural = `${Key & string}${_PluralSeparator}${PluralSuffix}`> = Res[(KeyWithPlural | Key) & keyof Res];
    export type ParseTReturnPluralOrdinal<Res, Key, KeyWithOrdinalPlural = `${Key & string}${_PluralSeparator}ordinal${_PluralSeparator}${PluralSuffix}`> = Res[(KeyWithOrdinalPlural | Key) & keyof Res];
    export type ParseTReturn<Key, Res, TOpt extends TOptions = {}> = Key extends `${infer K1}${_KeySeparator}${infer RestKey}` ? ParseTReturn<RestKey, Res[K1 & keyof Res], TOpt> : TOpt['count'] extends number ? TOpt['ordinal'] extends boolean ? ParseTReturnPluralOrdinal<Res, Key> : ParseTReturnPlural<Res, Key> : Res extends readonly unknown[] ? Key extends `${infer NKey extends number}` ? Res[NKey] : never : Res[Key & keyof Res];
    export type TReturnOptionalNull = _ReturnNull extends true ? null : never;
    export type TReturnOptionalObjects<TOpt extends TOptions> = _ReturnObjects extends true ? $SpecialObject | string : TOpt['returnObjects'] extends true ? $SpecialObject : string;
    export type DefaultTReturn<TOpt extends TOptions> = TReturnOptionalObjects<TOpt> | TReturnOptionalNull;
    export type KeyWithContext<Key, TOpt extends TOptions> = TOpt['context'] extends string ? `${Key & string}${_ContextSeparator}${TOpt['context']}` : Key;
    export type TFunctionReturn<Ns extends Namespace, Key, TOpt extends TOptions, ActualNS extends Namespace = NsByTOptions<Ns, TOpt>, ActualKey = KeyWithContext<Key, TOpt>> = $IsResourcesDefined extends true ? ActualKey extends `${infer Nsp}${_NsSeparator}${infer RestKey}` ? ParseTReturn<RestKey, Resources[Nsp & keyof Resources], TOpt> : ParseTReturn<ActualKey, Resources[$FirstNamespace<ActualNS>], TOpt> : DefaultTReturn<TOpt>;
    export type TFunctionDetailedResult<T = string, TOpt extends TOptions = {}> = {
        /**
         * The plain used key
         */
        usedKey: string;
        /**
         * The translation result.
         */
        res: T;
        /**
         * The key with context / plural
         */
        exactUsedKey: string;
        /**
         * The used language for this translation.
         */
        usedLng: string;
        /**
         * The used namespace for this translation.
         */
        usedNS: string;
        /**
         * The parameters used for interpolation.
         */
        usedParams: InterpolationMap<T> & {
            count?: TOpt['count'];
        };
    };
    export type TFunctionReturnOptionalDetails<Ret, TOpt extends TOptions> = TOpt['returnDetails'] extends true ? TFunctionDetailedResult<Ret, TOpt> : Ret;
    export type AppendKeyPrefix<Key, KPrefix> = KPrefix extends string ? `${KPrefix}${_KeySeparator}${Key & string}` : Key;
    /** ************************
     * T function declaration *
     ************************* */
    export interface TFunction<Ns extends Namespace = DefaultNamespace, KPrefix = undefined> {
        $TFunctionBrand: $IsResourcesDefined extends true ? `${$FirstNamespace<Ns>}` : never;
        <const Key extends ParseKeys<Ns, TOpt, KPrefix> | TemplateStringsArray, const TOpt extends TOptions, Ret extends TFunctionReturn<Ns, AppendKeyPrefix<Key, KPrefix>, TOpt>, const ActualOptions extends TOpt & InterpolationMap<Ret> = TOpt & InterpolationMap<Ret>>(...args: [
            key: Key | Key[],
            options?: ActualOptions
        ] | [
            key: string | string[],
            options: TOpt & $Dictionary & {
                defaultValue: string;
            }
        ] | [
            key: string | string[],
            defaultValue: string,
            options?: TOpt & $Dictionary
        ]): TFunctionReturnOptionalDetails<Ret, TOpt>;
    }
    export type KeyPrefix<Ns extends Namespace> = ResourceKeys<true>[$FirstNamespace<Ns>] | undefined;
    export interface WithT<Ns extends Namespace = DefaultNamespace> {
        // Expose parameterized t in the i18next interface hierarchy
        t: TFunction<Ns>;
    }
    export interface Interpolator {
        init(options: InterpolationOptions, reset: boolean): undefined;
        reset(): undefined;
        resetRegExp(): undefined;
        interpolate(str: string, data: object, lng: string, options: InterpolationOptions): string;
        nest(str: string, fc: (...args: any[]) => any, options: InterpolationOptions): string;
    }
    export interface ResourceStore {
         data: Resource;
         options: InitOptions;
        /**
         * Gets fired when resources got added or removed
         */
        on(event: 'added' | 'removed', callback: (lng: string, ns: string) => void): void;
        /**
         * Remove event listener
         * removes all callback when callback not specified
         */
        off(event: 'added' | 'removed', callback?: (lng: string, ns: string) => void): void;
    }
    export interface Formatter {
        init(services: Services, i18nextOptions: InitOptions): void;
        add(name: string, fc: (value: any, lng: string | undefined, options: any) => string): void;
        addCached(name: string, fc: (lng: string | undefined, options: any) => (value: any) => string): void;
        format: FormatFunction;
    }
    export interface Services {
        backendConnector: any;
        i18nFormat: any;
        interpolator: Interpolator;
        languageDetector: any;
        languageUtils: any;
        logger: any;
        pluralResolver: any;
        resourceStore: ResourceStore;
        formatter?: Formatter;
    }
    export type ModuleType = 'backend' | 'logger' | 'languageDetector' | 'postProcessor' | 'i18nFormat' | 'formatter' | '3rdParty';
    export interface Module {
        type: ModuleType;
    }
    export type CallbackError = Error | string | null | undefined;
    export type ReadCallback = (err: CallbackError, data: ResourceKey | boolean | null | undefined) => void;
    export type MultiReadCallback = (err: CallbackError, data: Resource | null | undefined) => void;
    /**
     * Used to load data for i18next.
     * Can be provided as a singleton or as a prototype constructor (preferred for supporting multiple instances of i18next).
     * For singleton set property `type` to `'backend'` For a prototype constructor set static property.
     */
    export interface BackendModule<Options = object> extends Module {
        type: 'backend';
        init(services: Services, backendOptions: Options, i18nextOptions: InitOptions): void;
        read(language: string, namespace: string, callback: ReadCallback): void;
        /** Save the missing translation */
        create?(languages: readonly string[], namespace: string, key: string, fallbackValue: string): void;
        /** Load multiple languages and namespaces. For backends supporting multiple resources loading */
        readMulti?(languages: readonly string[], namespaces: readonly string[], callback: MultiReadCallback): void;
        /** Store the translation. For backends acting as cache layer */
        save?(language: string, namespace: string, data: ResourceLanguage): void;
    }
    /**
     * Used to detect language in user land.
     * Can be provided as a singleton or as a prototype constructor (preferred for supporting multiple instances of i18next).
     * For singleton set property `type` to `'languageDetector'` For a prototype constructor set static property.
     */
    export interface LanguageDetectorModule extends Module {
        type: 'languageDetector';
        init?(services: Services, detectorOptions: object, i18nextOptions: InitOptions): void;
        /** Must return detected language */
        detect(): string | readonly string[] | undefined;
        cacheUserLanguage?(lng: string): void;
    }
    /**
     * Used to detect language in user land.
     * Can be provided as a singleton or as a prototype constructor (preferred for supporting multiple instances of i18next).
     * For singleton set property `type` to `'languageDetector'` For a prototype constructor set static property.
     */
    export interface LanguageDetectorAsyncModule extends Module {
        type: 'languageDetector';
        /** Set to true to enable async detection */
        async: true;
        init?(services: Services, detectorOptions: object, i18nextOptions: InitOptions): void;
        /** Must call callback passing detected language or return a Promise */
        detect(callback: (lng: string | readonly string[] | undefined) => void | undefined): void | Promise<string | readonly string[] | undefined>;
        cacheUserLanguage?(lng: string): void | Promise<void>;
    }
    /**
     * Used to extend or manipulate the translated values before returning them in `t` function.
     * Need to be a singleton object.
     */
    export interface PostProcessorModule extends Module {
        /** Unique name */
        name: string;
        type: 'postProcessor';
        process(value: string, key: string | string[], options: TOptions, translator: any): string;
    }
    /**
     * Override the built-in console logger.
     * Do not need to be a prototype function.
     */
    export interface LoggerModule extends Module {
        type: 'logger';
        log(...args: any[]): void;
        warn(...args: any[]): void;
        error(...args: any[]): void;
    }
    export interface I18nFormatModule extends Module {
        type: 'i18nFormat';
    }
    export interface FormatterModule extends Module, Formatter {
        type: 'formatter';
    }
    export interface ThirdPartyModule extends Module {
        type: '3rdParty';
        init(i18next: i18n): void;
    }
    export interface Modules {
        backend?: BackendModule;
        logger?: LoggerModule;
        languageDetector?: LanguageDetectorModule | LanguageDetectorAsyncModule;
        i18nFormat?: I18nFormatModule;
        formatter?: FormatterModule;
        external: ThirdPartyModule[];
    }
    // helper to identify interface https://stackoverflow.com/a/45983481/2363935
    export interface Newable<T> {
        new (...args: any[]): T;
    }
    export interface NewableModule<T extends Module> extends Newable<T> {
        type: T['type'];
    }
    export type Callback = (error: any, t: TFunction) => void;
    /**
     * Uses similar args as the t function and returns true if a key exists.
     */
    export interface ExistsFunction<TKeys extends string = string, TInterpolationMap extends object = $Dictionary> {
        (key: TKeys | TKeys[], options?: TOptions<TInterpolationMap>): boolean;
    }
    export interface CloneOptions extends InitOptions {
        /**
         * Will create a new instance of the resource store and import the existing translation resources.
         * This way it will not shared the resource store instance.
         * @default false
         */
        forkResourceStore?: boolean;
    }
    export interface CustomInstanceExtenstions {
    }
    // eslint-disable-next-line @typescript-eslint/naming-convention
    export interface i18n extends CustomInstanceExtenstions {
        // Expose parameterized t in the i18next interface hierarchy
        t: TFunction<[
            DefaultNamespace,
            ...Exclude<FlatNamespace, DefaultNamespace>[]
        ]>;
        /**
         * The default of the i18next module is an i18next instance ready to be initialized by calling init.
         * You can create additional instances using the createInstance function.
         *
         * @param options - Initial options.
         * @param callback - will be called after all translations were loaded or with an error when failed (in case of using a backend).
         */
        init(callback?: Callback): Promise<TFunction>;
        init<T>(options: InitOptions<T>, callback?: Callback): Promise<TFunction>;
        loadResources(callback?: (err: any) => void): void;
        /**
         * The use function is there to load additional plugins to i18next.
         * For available module see the plugins page and don't forget to read the documentation of the plugin.
         *
         * @param module Accepts a interface or object
         */
        use<T extends Module>(module: T | NewableModule<T> | Newable<T>): this;
        /**
         * List of modules used
         */
        modules: Modules;
        /**
         * Internal container for all used plugins and implementation details like languageUtils, pluralResolvers, etc.
         */
        services: Services;
        /**
         * Internal container for translation resources
         */
        store: ResourceStore;
        /**
         * Uses similar args as the t function and returns true if a key exists.
         */
        exists: ExistsFunction;
        /**
         * Returns a resource data by language.
         */
        getDataByLanguage(lng: string): {
            [key: string]: {
                [key: string]: string;
            };
        } | undefined;
        /**
         * Returns a t function that defaults to given language or namespace.
         * Both params could be arrays of languages or namespaces and will be treated as fallbacks in that case.
         * On the returned function you can like in the t function override the languages or namespaces by passing them in options or by prepending namespace.
         *
         * Accepts optional keyPrefix that will be automatically applied to returned t function.
         */
        getFixedT<Ns extends Namespace | null = DefaultNamespace, TKPrefix extends KeyPrefix<ActualNs> = undefined, ActualNs extends Namespace = Ns extends null ? DefaultNamespace : Ns>(...args: [
            lng: string | readonly string[],
            ns?: Ns,
            keyPrefix?: TKPrefix
        ] | [
            lng: null,
            ns: Ns,
            keyPrefix?: TKPrefix
        ]): TFunction<ActualNs, TKPrefix>;
        /**
         * Changes the language. The callback will be called as soon translations were loaded or an error occurs while loading.
         * HINT: For easy testing - setting lng to 'cimode' will set t function to always return the key.
         */
        changeLanguage(lng?: string, callback?: Callback): Promise<TFunction>;
        /**
         * Is set to the current detected or set language.
         * If you need the primary used language depending on your configuration (supportedLngs, load) you will prefer using i18next.languages[0].
         */
        language: string;
        /**
         * Is set to an array of language-codes that will be used it order to lookup the translation value.
         */
        languages: readonly string[];
        /**
         * Is set to the current resolved language.
         * It can be used as primary used language, for example in a language switcher.
         */
        resolvedLanguage?: string;
        /**
         * Checks if namespace has loaded yet.
         * i.e. used by react-i18next
         */
        hasLoadedNamespace(ns: string | readonly string[], options?: {
            lng?: string | readonly string[];
            precheck: (i18n: i18n, loadNotPending: (lng: string | readonly string[], ns: string | readonly string[]) => boolean) => boolean;
        }): boolean;
        /**
         * Loads additional namespaces not defined in init options.
         */
        loadNamespaces(ns: string | readonly string[], callback?: Callback): Promise<void>;
        /**
         * Loads additional languages not defined in init options (preload).
         */
        loadLanguages(lngs: string | readonly string[], callback?: Callback): Promise<void>;
        /**
         * Reloads resources on given state. Optionally you can pass an array of languages and namespaces as params if you don't want to reload all.
         */
        reloadResources(lngs?: string | readonly string[], ns?: string | readonly string[], callback?: () => void): Promise<void>;
        reloadResources(lngs: null, ns: string | readonly string[], callback?: () => void): Promise<void>;
        /**
         * Changes the default namespace.
         */
        setDefaultNamespace(ns: string): void;
        /**
         * Checks if a namespace has been loaded.
         */
        hasLoadedNamespace(ns: string, options?: Pick<InitOptions, 'fallbackLng'>): boolean;
        /**
         * Returns rtl or ltr depending on languages read direction.
         */
        dir(lng?: string): 'ltr' | 'rtl';
        /**
         * Exposes interpolation.format function added on init.
         */
        format: FormatFunction;
        /**
         * Will return a new i18next instance.
         * Please read the options page for details on configuration options.
         * Providing a callback will automatically call init.
         * The callback will be called after all translations were loaded or with an error when failed (in case of using a backend).
         */
        createInstance(options?: InitOptions, callback?: Callback): i18n;
        /**
         * Creates a clone of the current instance. Shares store, plugins and initial configuration.
         * Can be used to create an instance sharing storage but being independent on set language or namespaces.
         */
        cloneInstance(options?: CloneOptions, callback?: Callback): i18n;
        /**
         * Gets fired after initialization.
         */
        on(event: 'initialized', callback: (options: InitOptions) => void): void;
        /**
         * Gets fired on loaded resources.
         */
        on(event: 'loaded', callback: (loaded: {
            [language: string]: {
                [namespace: string]: boolean;
            };
        }) => void): void;
        /**
         * Gets fired if loading resources failed.
         */
        on(event: 'failedLoading', callback: (lng: string, ns: string, msg: string) => void): void;
        /**
         * Gets fired on accessing a key not existing.
         */
        on(event: 'missingKey', callback: (lngs: readonly string[], namespace: string, key: string, res: string) => void): void;
        /**
         * Gets fired when resources got added or removed.
         */
        on(event: 'added' | 'removed', callback: (lng: string, ns: string) => void): void;
        /**
         * Gets fired when changeLanguage got called.
         */
        on(event: 'languageChanged', callback: (lng: string) => void): void;
        /**
         * Event listener
         */
        on(event: string, listener: (...args: any[]) => void): void;
        /**
         * Remove event listener
         * removes all callback when callback not specified
         */
        off(event: string, listener?: (...args: any[]) => void): void;
        /**
         * Gets one value by given key.
         */
        getResource(lng: string, ns: string, key: string, options?: Pick<InitOptions, 'keySeparator' | 'ignoreJSONStructure'>): any;
        /**
         * Adds one key/value.
         */
        addResource(lng: string, ns: string, key: string, value: string, options?: {
            keySeparator?: string;
            silent?: boolean;
        }): i18n;
        /**
         * Adds multiple key/values.
         */
        addResources(lng: string, ns: string, resources: any): i18n;
        /**
         * Adds a complete bundle.
         * Setting deep param to true will extend existing translations in that file.
         * Setting overwrite to true it will overwrite existing translations in that file.
         */
        addResourceBundle(lng: string, ns: string, resources: any, deep?: boolean, overwrite?: boolean): i18n;
        /**
         * Checks if a resource bundle exists.
         */
        hasResourceBundle(lng: string, ns: string): boolean;
        /**
         * Returns a resource bundle.
         */
        getResourceBundle(lng: string, ns: string): any;
        /**
         * Removes an existing bundle.
         */
        removeResourceBundle(lng: string, ns: string): i18n;
        /**
         * Current options
         */
        options: InitOptions;
        /**
         * Is initialized
         */
        isInitialized: boolean;
        /**
         * Store was initialized
         */
        initializedStoreOnce: boolean;
        /**
         * Language was initialized
         */
        initializedLanguageOnce: boolean;
        /**
         * Emit event
         */
        emit(eventName: string, ...args: any[]): void;
    }
}
export { i18n };
export interface DirectiveClass {
    new (part: PartInfo): Directive;
}
/**
 * This utility type extracts the signature of a directive class's render()
 * method so we can use it for the type of the generated directive function.
 */
export type DirectiveParameters<C extends Directive> = Parameters<C['render']>;
/**
 * A generated directive function doesn't evaluate the directive, but just
 * returns a DirectiveResult object that captures the arguments.
 */
export interface DirectiveResult<C extends DirectiveClass = DirectiveClass> {
}
export declare const PartType: {
    readonly ATTRIBUTE: 1;
    readonly CHILD: 2;
    readonly PROPERTY: 3;
    readonly BOOLEAN_ATTRIBUTE: 4;
    readonly EVENT: 5;
    readonly ELEMENT: 6;
};
export type PartType = (typeof PartType)[keyof typeof PartType];
export interface ChildPartInfo {
    readonly type: typeof PartType.CHILD;
}
export interface AttributePartInfo {
    readonly type: typeof PartType.ATTRIBUTE | typeof PartType.PROPERTY | typeof PartType.BOOLEAN_ATTRIBUTE | typeof PartType.EVENT;
    readonly strings?: ReadonlyArray<string>;
    readonly name: string;
    readonly tagName: string;
}
export interface ElementPartInfo {
    readonly type: typeof PartType.ELEMENT;
}
/**
 * Information about the part a directive is bound to.
 *
 * This is useful for checking that a directive is attached to a valid part,
 * such as with directive that can only be used on attribute bindings.
 */
export type PartInfo = ChildPartInfo | AttributePartInfo | ElementPartInfo;
/**
 * Creates a user-facing directive function from a Directive class. This
 * function has the same parameters as the directive's render() method.
 */
export declare const directive: <C extends DirectiveClass>(c: C) => (...values: Parameters<InstanceType<C>['render']>) => DirectiveResult<C>;
/**
 * Base class for creating custom directives. Users should extend this class,
 * implement `render` and/or `update`, and then pass their subclass to
 * `directive`.
 */
export declare abstract class Directive implements Disconnectable {
    constructor(_partInfo: PartInfo);
    get _$isConnected(): boolean;
    abstract render(...props: Array<unknown>): unknown;
    update(_part: Part, props: Array<unknown>): unknown;
}
/**
 * Used to sanitize any value before it is written into the DOM. This can be
 * used to implement a security policy of allowed and disallowed values in
 * order to prevent XSS attacks.
 *
 * One way of using this callback would be to check attributes and properties
 * against a list of high risk fields, and require that values written to such
 * fields be instances of a class which is safe by construction. Closure's Safe
 * HTML Types is one implementation of this technique (
 * https://github.com/google/safe-html-types/blob/master/doc/safehtml-types.md).
 * The TrustedTypes polyfill in API-only mode could also be used as a basis
 * for this technique (https://github.com/WICG/trusted-types).
 *
 * @param node The HTML node (usually either a #text node or an Element) that
 *     is being written to. Note that this is just an exemplar node, the write
 *     may take place against another instance of the same class of node.
 * @param name The name of an attribute or property (for example, 'href').
 * @param type Indicates whether the write that's about to be performed will
 *     be to a property or a node.
 * @return A function that will sanitize this class of writes.
 */
export type SanitizerFactory = (node: Node, name: string, type: 'property' | 'attribute') => ValueSanitizer;
/**
 * A function which can sanitize values that will be written to a specific kind
 * of DOM sink.
 *
 * See SanitizerFactory.
 *
 * @param value The value to sanitize. Will be the actual value passed into
 *     the lit-html template literal, so this could be of any type.
 * @return The value to write to the DOM. Usually the same as the input value,
 *     unless sanitization is needed.
 */
export type ValueSanitizer = (value: unknown) => unknown;
declare const HTML_RESULT = 1;
declare const SVG_RESULT = 2;
export type ResultType = typeof HTML_RESULT | typeof SVG_RESULT;
declare const ATTRIBUTE_PART = 1;
declare const CHILD_PART = 2;
declare const ELEMENT_PART = 6;
declare const COMMENT_PART = 7;
/**
 * The return type of the template tag functions, {@linkcode html} and
 * {@linkcode svg} when it hasn't been compiled by @lit-labs/compiler.
 *
 * A `TemplateResult` object holds all the information about a template
 * expression required to render it: the template strings, expression values,
 * and type of template (html or svg).
 *
 * `TemplateResult` objects do not create any DOM on their own. To create or
 * update DOM you need to render the `TemplateResult`. See
 * [Rendering](https://lit.dev/docs/components/rendering) for more information.
 *
 */
export type UncompiledTemplateResult<T extends ResultType = ResultType> = {
    ['_$litType$']: T;
    strings: TemplateStringsArray;
    values: unknown[];
};
/**
 * The return type of the template tag functions, {@linkcode html} and
 * {@linkcode svg}.
 *
 * A `TemplateResult` object holds all the information about a template
 * expression required to render it: the template strings, expression values,
 * and type of template (html or svg).
 *
 * `TemplateResult` objects do not create any DOM on their own. To create or
 * update DOM you need to render the `TemplateResult`. See
 * [Rendering](https://lit.dev/docs/components/rendering) for more information.
 *
 * In Lit 4, this type will be an alias of
 * MaybeCompiledTemplateResult, so that code will get type errors if it assumes
 * that Lit templates are not compiled. When deliberately working with only
 * one, use either {@linkcode CompiledTemplateResult} or
 * {@linkcode UncompiledTemplateResult} explicitly.
 */
export type TemplateResult<T extends ResultType = ResultType> = UncompiledTemplateResult<T>;
export type HTMLTemplateResult = TemplateResult<typeof HTML_RESULT>;
export type SVGTemplateResult = TemplateResult<typeof SVG_RESULT>;
/**
 * Interprets a template literal as an HTML template that can efficiently
 * render to and update a container.
 *
 * ```ts
 * const header = (title: string) => html`<h1>${title}</h1>`;
 * ```
 *
 * The `html` tag returns a description of the DOM to render as a value. It is
 * lazy, meaning no work is done until the template is rendered. When rendering,
 * if a template comes from the same expression as a previously rendered result,
 * it's efficiently updated instead of replaced.
 */
export declare const html: (strings: TemplateStringsArray, ...values: unknown[]) => TemplateResult<1>;
/**
 * Interprets a template literal as an SVG fragment that can efficiently
 * render to and update a container.
 *
 * ```ts
 * const rect = svg`<rect width='10' height='10'></rect>`;
 *
 * const myImage = html`
 *   <svg viewBox='0 0 10 10' xmlns='http://www.w3.org/2000/svg'>
 *     ${rect}
 *   </svg>`;
 * ```
 *
 * The `svg` *tag function* should only be used for SVG fragments, or elements
 * that would be contained **inside** an `<svg>` HTML element. A common error is
 * placing an `<svg>` *element* in a template tagged with the `svg` tag
 * function. The `<svg>` element is an HTML element and should be used within a
 * template tagged with the {@linkcode html} tag function.
 *
 * In LitElement usage, it's invalid to return an SVG fragment from the
 * `render()` method, as the SVG fragment will be contained within the element's
 * shadow root and thus cannot be used within an `<svg>` HTML element.
 */
export declare const svg: (strings: TemplateStringsArray, ...values: unknown[]) => TemplateResult<2>;
/**
 * A sentinel value that signals that a value was handled by a directive and
 * should not be written to the DOM.
 */
export declare const noChange: unique symbol;
/**
 * A sentinel value that signals a ChildPart to fully clear its content.
 *
 * ```ts
 * const button = html`${
 *  user.isAdmin
 *    ? html`<button>DELETE</button>`
 *    : nothing
 * }`;
 * ```
 *
 * Prefer using `nothing` over other falsy values as it provides a consistent
 * behavior between various expression binding contexts.
 *
 * In child expressions, `undefined`, `null`, `''`, and `nothing` all behave the
 * same and render no nodes. In attribute expressions, `nothing` _removes_ the
 * attribute, while `undefined` and `null` will render an empty string. In
 * property expressions `nothing` becomes `undefined`.
 */
export declare const nothing: unique symbol;
/**
 * Object specifying options for controlling lit-html rendering. Note that
 * while `render` may be called multiple times on the same `container` (and
 * `renderBefore` reference node) to efficiently update the rendered content,
 * only the options passed in during the first render are respected during
 * the lifetime of renders to that unique `container` + `renderBefore`
 * combination.
 */
export interface RenderOptions {
    /**
     * An object to use as the `this` value for event listeners. It's often
     * useful to set this to the host component rendering a template.
     */
    host?: object;
    /**
     * A DOM node before which to render content in the container.
     */
    renderBefore?: ChildNode | null;
    /**
     * Node used for cloning the template (`importNode` will be called on this
     * node). This controls the `ownerDocument` of the rendered DOM, along with
     * any inherited context. Defaults to the global `document`.
     */
    creationScope?: {
        importNode(node: Node, deep?: boolean): Node;
    };
    /**
     * The initial connected state for the top-level part being rendered. If no
     * `isConnected` option is set, `AsyncDirective`s will be connected by
     * default. Set to `false` if the initial render occurs in a disconnected tree
     * and `AsyncDirective`s should see `isConnected === false` for their initial
     * render. The `part.setConnected()` method must be used subsequent to initial
     * render to change the connected state of the part.
     */
    isConnected?: boolean;
}
export interface DirectiveParent {
    _$parent?: DirectiveParent;
    _$isConnected: boolean;
    __directive?: Directive;
    __directives?: Array<Directive | undefined>;
}
declare class Template {
    parts: Array<TemplatePart>;
    constructor({ strings, ['_$litType$']: type }: UncompiledTemplateResult, options?: RenderOptions);
    /** @nocollapse */
    static createElement(html: HTMLElement, _options?: RenderOptions): HTMLTemplateElement;
}
export interface Disconnectable {
    _$parent?: Disconnectable;
    _$disconnectableChildren?: Set<Disconnectable>;
    _$isConnected: boolean;
}
declare class TemplateInstance implements Disconnectable {
    _$template: Template;
    _$parts: Array<Part | undefined>;
    constructor(template: Template, parent: ChildPart);
    get parentNode(): Node;
    get _$isConnected(): boolean;
    _clone(options: RenderOptions | undefined): Node;
    _update(values: Array<unknown>): void;
}
export type AttributeTemplatePart = {
    readonly type: typeof ATTRIBUTE_PART;
    readonly index: number;
    readonly name: string;
    readonly ctor: typeof AttributePart;
    readonly strings: ReadonlyArray<string>;
};
export type ChildTemplatePart = {
    readonly type: typeof CHILD_PART;
    readonly index: number;
};
export type ElementTemplatePart = {
    readonly type: typeof ELEMENT_PART;
    readonly index: number;
};
export type CommentTemplatePart = {
    readonly type: typeof COMMENT_PART;
    readonly index: number;
};
/**
 * A TemplatePart represents a dynamic part in a template, before the template
 * is instantiated. When a template is instantiated Parts are created from
 * TemplateParts.
 */
export type TemplatePart = ChildTemplatePart | AttributeTemplatePart | ElementTemplatePart | CommentTemplatePart;
export type Part = ChildPart | AttributePart | PropertyPart | BooleanAttributePart | ElementPart | EventPart;
declare class ChildPart implements Disconnectable {
    readonly type = 2;
    readonly options: RenderOptions | undefined;
    _$committedValue: unknown;
    private _textSanitizer;
    get _$isConnected(): boolean;
    constructor(startNode: ChildNode, endNode: ChildNode | null, parent: TemplateInstance | ChildPart | undefined, options: RenderOptions | undefined);
    /**
     * The parent node into which the part renders its content.
     *
     * A ChildPart's content consists of a range of adjacent child nodes of
     * `.parentNode`, possibly bordered by 'marker nodes' (`.startNode` and
     * `.endNode`).
     *
     * - If both `.startNode` and `.endNode` are non-null, then the part's content
     * consists of all siblings between `.startNode` and `.endNode`, exclusively.
     *
     * - If `.startNode` is non-null but `.endNode` is null, then the part's
     * content consists of all siblings following `.startNode`, up to and
     * including the last child of `.parentNode`. If `.endNode` is non-null, then
     * `.startNode` will always be non-null.
     *
     * - If both `.endNode` and `.startNode` are null, then the part's content
     * consists of all child nodes of `.parentNode`.
     */
    get parentNode(): Node;
    /**
     * The part's leading marker node, if any. See `.parentNode` for more
     * information.
     */
    get startNode(): Node | null;
    /**
     * The part's trailing marker node, if any. See `.parentNode` for more
     * information.
     */
    get endNode(): Node | null;
    _$setValue(value: unknown, directiveParent?: DirectiveParent): void;
    private _insert;
    private _commitNode;
    private _commitText;
    private _commitTemplateResult;
    private _commitIterable;
}
/**
 * A top-level `ChildPart` returned from `render` that manages the connected
 * state of `AsyncDirective`s created throughout the tree below it.
 */
export interface RootPart extends ChildPart {
    /**
     * Sets the connection state for `AsyncDirective`s contained within this root
     * ChildPart.
     *
     * lit-html does not automatically monitor the connectedness of DOM rendered;
     * as such, it is the responsibility of the caller to `render` to ensure that
     * `part.setConnected(false)` is called before the part object is potentially
     * discarded, to ensure that `AsyncDirective`s have a chance to dispose of
     * any resources being held. If a `RootPart` that was previously
     * disconnected is subsequently re-connected (and its `AsyncDirective`s should
     * re-connect), `setConnected(true)` should be called.
     *
     * @param isConnected Whether directives within this tree should be connected
     * or not
     */
    setConnected(isConnected: boolean): void;
}
declare class AttributePart implements Disconnectable {
    readonly type: 1 | 3 | 4 | 5;
    readonly element: HTMLElement;
    readonly name: string;
    readonly options: RenderOptions | undefined;
    /**
     * If this attribute part represents an interpolation, this contains the
     * static strings of the interpolation. For single-value, complete bindings,
     * this is undefined.
     */
    readonly strings?: ReadonlyArray<string>;
    protected _sanitizer: ValueSanitizer | undefined;
    get tagName(): string;
    get _$isConnected(): boolean;
    constructor(element: HTMLElement, name: string, strings: ReadonlyArray<string>, parent: Disconnectable, options: RenderOptions | undefined);
}
declare class PropertyPart extends AttributePart {
    readonly type = 3;
}
declare class BooleanAttributePart extends AttributePart {
    readonly type = 4;
}
declare class EventPart extends AttributePart {
    readonly type = 5;
    constructor(element: HTMLElement, name: string, strings: ReadonlyArray<string>, parent: Disconnectable, options: RenderOptions | undefined);
    handleEvent(event: Event): void;
}
declare class ElementPart implements Disconnectable {
    element: Element;
    readonly type = 6;
    _$committedValue: undefined;
    options: RenderOptions | undefined;
    constructor(element: Element, parent: Disconnectable, options: RenderOptions | undefined);
    get _$isConnected(): boolean;
    _$setValue(value: unknown): void;
}
/**
 * Renders a value, usually a lit-html TemplateResult, to the container.
 *
 * This example renders the text 'Hello, Zoe!' inside a paragraph tag, appending
 * it to the container `document.body`.
 *
 * ```js
 * import {html, render} from 'lit';
 *
 * const name = 'Zoe';
 * render(html`<p>Hello, ${name}!</p>`, document.body);
 * ```
 *
 * @param value Any [renderable
 *   value](https://lit.dev/docs/templates/expressions/#child-expressions),
 *   typically a {@linkcode TemplateResult} created by evaluating a template tag
 *   like {@linkcode html} or {@linkcode svg}.
 * @param container A DOM container to render to. The first render will append
 *   the rendered value to the container, and subsequent renders will
 *   efficiently update the rendered value if the same result type was
 *   previously rendered there.
 * @param options See {@linkcode RenderOptions} for options documentation.
 * @see
 * {@link https://lit.dev/docs/libraries/standalone-templates/#rendering-lit-html-templates| Rendering Lit HTML Templates}
 */
export declare const render: {
    (value: unknown, container: HTMLElement | DocumentFragment, options?: RenderOptions): RootPart;
    setSanitizer: (newSanitizer: SanitizerFactory) => void;
    createSanitizer: SanitizerFactory;
    _testOnlyClearSanitizerFactoryDoNotCallOrElse: () => void;
};
/**
 * An abstract `Directive` base class whose `disconnected` method will be
 * called when the part containing the directive is cleared as a result of
 * re-rendering, or when the user calls `part.setConnected(false)` on
 * a part that was previously rendered containing the directive (as happens
 * when e.g. a LitElement disconnects from the DOM).
 *
 * If `part.setConnected(true)` is subsequently called on a
 * containing part, the directive's `reconnected` method will be called prior
 * to its next `update`/`render` callbacks. When implementing `disconnected`,
 * `reconnected` should also be implemented to be compatible with reconnection.
 *
 * Note that updates may occur while the directive is disconnected. As such,
 * directives should generally check the `this.isConnected` flag during
 * render/update to determine whether it is safe to subscribe to resources
 * that may prevent garbage collection.
 */
export declare abstract class AsyncDirective extends Directive {
    /**
     * The connection state for this Directive.
     */
    isConnected: boolean;
    /**
     * Initialize the part with internal fields
     * @param part
     * @param parent
     * @param attributeIndex
     */
    _$initialize(part: Part, parent: Disconnectable, attributeIndex: number | undefined): void;
    /**
     * Sets the value of the directive's Part outside the normal `update`/`render`
     * lifecycle of a directive.
     *
     * This method should not be called synchronously from a directive's `update`
     * or `render`.
     *
     * @param directive The directive to update
     * @param value The value to set
     */
    setValue(value: unknown): void;
    /**
     * User callbacks for implementing logic to release any resources/subscriptions
     * that may have been retained by this directive. Since directives may also be
     * re-connected, `reconnected` should also be implemented to restore the
     * working state of the directive prior to the next render.
     */
    protected disconnected(): void;
    protected reconnected(): void;
}
/**
 * Creates a new Ref object, which is container for a reference to an element.
 */
export declare const createRef: <T = Element>() => Ref<T>;
/**
 * An object that holds a ref value.
 */
export declare class Ref<T = Element> {
    /**
     * The current Element value of the ref, or else `undefined` if the ref is no
     * longer rendered.
     */
    readonly value?: T;
}
export type RefOrCallback<T = Element> = Ref<T> | ((el: T | undefined) => void);
declare class RefDirective extends AsyncDirective {
    private _element?;
    private _ref?;
    private _context?;
    render(_ref?: RefOrCallback): symbol;
    update(part: ElementPart, [ref]: Parameters<this['render']>): symbol;
    private _updateRefValue;
    private get _lastElementForRef();
    disconnected(): void;
    reconnected(): void;
}
declare const _directive_ref: (_ref?: RefOrCallback<Element> | undefined) => DirectiveResult<typeof RefDirective>;
export type Mapper<T> = (v: T, index?: number) => unknown;
declare class AsyncReplaceDirective extends AsyncDirective {
    private __value?;
    private __weakThis;
    private __pauser;
    render<T>(value: AsyncIterable<T>, _mapper?: Mapper<T>): symbol;
    update(_part: ChildPart, [value, mapper]: DirectiveParameters<this>): typeof noChange | undefined;
    protected commitValue(value: unknown, _index: number): void;
    disconnected(): void;
    reconnected(): void;
}
declare const asyncReplace: (value: AsyncIterable<unknown>, _mapper?: Mapper<unknown> | undefined) => DirectiveResult<typeof AsyncReplaceDirective>;
declare class AsyncAppendDirective extends AsyncReplaceDirective {
    private __childPart;
    constructor(partInfo: PartInfo);
    update(part: ChildPart, params: DirectiveParameters<this>): typeof noChange | undefined;
    protected commitValue(value: unknown, index: number): void;
}
declare const asyncAppend: (value: AsyncIterable<unknown>, _mapper?: ((v: unknown, index?: number | undefined) => unknown) | undefined) => DirectiveResult<typeof AsyncAppendDirective>;
declare class CacheDirective extends Directive {
    private _templateCache;
    private _value?;
    constructor(partInfo: PartInfo);
    render(v: unknown): unknown[];
    update(containerPart: ChildPart, [v]: DirectiveParameters<this>): unknown[];
}
declare const _directive_cache: (v: unknown) => DirectiveResult<typeof CacheDirective>;
declare const _directive_choose: <T, V, K extends T = T>(value: T, cases: [
    K,
    () => V
][], defaultCase?: (() => V) | undefined) => V | undefined;
/**
 * A key-value set of class names to truthy values.
 */
export interface ClassInfo {
    readonly [name: string]: string | boolean | number;
}
declare class ClassMapDirective extends Directive {
    /**
     * Stores the ClassInfo object applied to a given AttributePart.
     * Used to unset existing values when a new ClassInfo object is applied.
     */
    private _previousClasses?;
    private _staticClasses?;
    constructor(partInfo: PartInfo);
    render(classInfo: ClassInfo): string;
    update(part: AttributePart, [classInfo]: DirectiveParameters<this>): string | typeof noChange;
}
declare const classMap: (classInfo: ClassInfo) => DirectiveResult<typeof ClassMapDirective>;
declare class GuardDirective extends Directive {
    private _previousValue;
    render(_value: unknown, f: () => unknown): unknown;
    update(_part: Part, [value, f]: DirectiveParameters<this>): unknown;
}
declare const _directive_guard: (_value: unknown, f: () => unknown) => DirectiveResult<typeof GuardDirective>;
declare const ifDefined: <T>(value: T) => typeof nothing | NonNullable<T>;
declare function _directive_join<I, J>(items: Iterable<I> | undefined, joiner: (index: number) => J): Iterable<I | J>;
declare function _directive_join<I, J>(items: Iterable<I> | undefined, joiner: J): Iterable<I | J>;
declare class Keyed extends Directive {
    key: unknown;
    render(k: unknown, v: unknown): unknown;
    update(part: ChildPart, [k, v]: DirectiveParameters<this>): unknown;
}
declare const keyed: (k: unknown, v: unknown) => DirectiveResult<typeof Keyed>;
declare class LiveDirective extends Directive {
    constructor(partInfo: PartInfo);
    render(value: unknown): unknown;
    update(part: AttributePart, [value]: DirectiveParameters<this>): unknown;
}
declare const _directive_live: (value: unknown) => DirectiveResult<typeof LiveDirective>;
declare function _directive_map<T>(items: Iterable<T> | undefined, f: (value: T, index: number) => unknown): Generator<unknown, void, unknown>;
declare function _directive_range(end: number): Iterable<number>;
declare function _directive_range(start: number, end: number, step?: number): Iterable<number>;
export type KeyFn<T> = (item: T, index: number) => unknown;
export type ItemTemplate<T> = (item: T, index: number) => unknown;
export interface RepeatDirectiveFn {
    <T>(items: Iterable<T>, keyFnOrTemplate: KeyFn<T> | ItemTemplate<T>, template?: ItemTemplate<T>): unknown;
    <T>(items: Iterable<T>, template: ItemTemplate<T>): unknown;
    <T>(items: Iterable<T>, keyFn: KeyFn<T> | ItemTemplate<T>, template: ItemTemplate<T>): unknown;
}
declare const _directive_repeat: RepeatDirectiveFn;
/**
 * A key-value set of CSS properties and values.
 *
 * The key should be either a valid CSS property name string, like
 * `'background-color'`, or a valid JavaScript camel case property name
 * for CSSStyleDeclaration like `backgroundColor`.
 */
export interface StyleInfo {
    [name: string]: string | number | undefined | null;
}
declare class StyleMapDirective extends Directive {
    private _previousStyleProperties?;
    constructor(partInfo: PartInfo);
    render(styleInfo: Readonly<StyleInfo>): string;
    update(part: AttributePart, [styleInfo]: DirectiveParameters<this>): string | typeof noChange;
}
declare const styleMap: (styleInfo: Readonly<StyleInfo>) => DirectiveResult<typeof StyleMapDirective>;
declare class TemplateContentDirective extends Directive {
    private _previousTemplate?;
    constructor(partInfo: PartInfo);
    render(template: HTMLTemplateElement): DocumentFragment | typeof noChange;
}
declare const templateContent: (template: HTMLTemplateElement) => DirectiveResult<typeof TemplateContentDirective>;
declare class UnsafeHTMLDirective extends Directive {
    static directiveName: string;
    static resultType: number;
    private _value;
    private _templateResult?;
    constructor(partInfo: PartInfo);
    render(value: string | typeof nothing | typeof noChange | undefined | null): typeof noChange | typeof nothing | TemplateResult | null | undefined;
}
declare const unsafeHTML: (value: string | typeof noChange | typeof nothing | null | undefined) => DirectiveResult<typeof UnsafeHTMLDirective>;
declare class UnsafeSVGDirective extends UnsafeHTMLDirective {
    static directiveName: string;
    static resultType: number;
}
declare const unsafeSVG: (value: string | typeof noChange | typeof nothing | null | undefined) => DirectiveResult<typeof UnsafeSVGDirective>;
declare class UntilDirective extends AsyncDirective {
    private __lastRenderedIndex;
    private __values;
    private __weakThis;
    private __pauser;
    render(...args: Array<unknown>): unknown;
    update(_part: Part, args: Array<unknown>): unknown;
    disconnected(): void;
    reconnected(): void;
}
declare const _directive_until: (...values: unknown[]) => DirectiveResult<typeof UntilDirective>;
/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: BSD-3-Clause
 */
export type Falsy = null | undefined | false | 0 | -0 | 0n | '';
declare function _directive_when<C extends Falsy, T, F = undefined>(condition: C, trueCase: (c: C) => T, falseCase?: (c: C) => F): F;
declare function _directive_when<C, T, F>(condition: C extends Falsy ? never : C, trueCase: (c: C) => T, falseCase?: (c: C) => F): T;
declare function _directive_when<C, T, F = undefined>(condition: C, trueCase: (c: Exclude<C, Falsy>) => T, falseCase?: (c: Extract<C, Falsy>) => F): C extends Falsy ? F : T;
export declare const _Σ: {
    AttributePart: AttributePart;
    PropertyPart: PropertyPart;
    BooleanAttributePart: BooleanAttributePart;
    EventPart: EventPart;
    ElementPart: ElementPart;
};
declare namespace directives {
    type asyncAppend = typeof asyncAppend;
    type asyncReplace = typeof asyncReplace;
    type cache = typeof _directive_cache;
    type choose = typeof _directive_choose;
    type classMap = typeof classMap;
    type guard = typeof _directive_guard;
    type ifDefined = typeof ifDefined;
    type join = typeof _directive_join;
    type keyed = typeof keyed;
    type live = typeof _directive_live;
    type map = typeof _directive_map;
    type range = typeof _directive_range;
    type ref = typeof _directive_ref;
    type repeat = typeof _directive_repeat;
    type styleMap = typeof styleMap;
    type templateContent = typeof templateContent;
    type unsafeHTML = typeof unsafeHTML;
    type unsafeSVG = typeof unsafeSVG;
    type until = typeof _directive_until;
    type when = typeof _directive_when;
}
export interface TemplateDirectives {
    asyncAppend: directives.asyncAppend;
    asyncReplace: directives.asyncReplace;
    cache: directives.cache;
    choose: directives.choose;
    classMap: directives.classMap;
    guard: directives.guard;
    ifDefined: directives.ifDefined;
    join: directives.join;
    keyed: directives.keyed;
    live: directives.live;
    map: directives.map;
    range: directives.range;
    ref: directives.ref;
    repeat: directives.repeat;
    styleMap: directives.styleMap;
    templateContent: directives.templateContent;
    unsafeHTML: directives.unsafeHTML;
    unsafeSVG: directives.unsafeSVG;
    until: directives.until;
    when: directives.when;
}
export declare const directives: TemplateDirectives;
/**
 * @en Convert from `string` to `TemplateStringsArray`. <br>
 *     This method is helper brigdge for the {@link html} or the {@link svg} are able to received plain string.
 * @ja `string` を `TemplateStringsArray`に変換. <br>
 *     {@link html} や {@link svg} が文字列を受け付けるためのブリッジメソッド
 *
 * @example <br>
 *
 * ```ts
 * import { toTemplateStringsArray as bridge } from '@cdp/runtime';
 *
 * const raw = '<p>Hello Raw String</p>';
 * render(html(bridge(raw)), document.body);
 * ```
 *
 * @param src
 *  - `en` plain string / string array. ex) {@link JST} returned value.
 *  - `ja` プレーン文字列 / 文字列配列. ex) {@link JST} の戻り値などを想定
 */
export declare const toTemplateStringsArray: (src: string | string[] | TemplateStringsArray) => TemplateStringsArray;
export type TemplateBridgeArg = Record<string, {} | null | undefined>;
export type TemplateBridgeEndine = (view?: TemplateBridgeArg) => TemplateResult | SVGTemplateResult;
export type TemplateTransformer = (template: HTMLTemplateElement | string) => TemplateBridgeEndine;
export type TemplateTag = (strings: TemplateStringsArray, ...values: unknown[]) => TemplateResult | SVGTemplateResult;
export type TransformDirective = (value: string | typeof noChange | typeof nothing | null | undefined) => DirectiveResult;
export type TransformTester = (input: string, config: TransformConfig) => boolean;
export type TransformExecutor = (input: string, config: TransformConfig) => TemplateResult | SVGTemplateResult | undefined;
export interface TransformeContext {
    test: TransformTester;
    transform: TransformExecutor;
}
export interface TransformConfig {
    html: TemplateTag;
    transformVariable: TransformExecutor;
    delimiter?: {
        start: string;
        end: string;
    };
    transformers?: Record<string, TransformeContext>;
}
export declare function createMustacheTransformer(html: TemplateTag, unsafeHTML: TransformDirective): TemplateTransformer;
export declare function createMustacheTransformer(config: TransformConfig): TemplateTransformer;
export declare const transformer: {
    variable: TransformExecutor;
    unsafeVariable: (unsafeHTML: TransformDirective) => TransformeContext;
    section: () => TransformeContext;
    invertedSection: () => TransformeContext;
    comment: () => TransformeContext;
    customDelimiter: () => TransformeContext;
};
/**
 * A TemplateRenderer is responsible for rendering a block call, like
 * `<template name='foo'>`
 */
export declare type TemplateRenderer = (view: TemplateBridgeArg, handlers: TemplateHandlers, renderers: TemplateRenderers) => unknown;
export declare type TemplateRenderers = Record<string, TemplateRenderer>;
/**
 * A TemplateHandlers is responsible for rendering control flow like
 * `<template type='if' if='{{x}}'>`
 */
export declare type TemplateHandler = (template: HTMLTemplateElement, view: TemplateBridgeArg, handlers: TemplateHandlers, renderers: TemplateRenderers) => unknown;
export declare type TemplateHandlers = Record<string, TemplateHandler>;
/**
 * @returns {Function} a template function of the form (view) => TemplateResult
 */
export declare const prepareTemplate: (template: HTMLTemplateElement, handlers?: TemplateHandlers, renderers?: TemplateRenderers, superTemplate?: HTMLTemplateElement | undefined) => TemplateBridgeEndine;
export interface EvaluateTemplateResult {
    values: unknown[];
}
/**
 * Evaluates the given template and returns its result
 *
 * @param template
 * @param view
 * @param handlers
 * @param renderers
 * @returns
 */
export declare const evaluateTemplate: (template: HTMLTemplateElement, view: object, handlers?: TemplateHandlers, renderers?: TemplateRenderers) => EvaluateTemplateResult;
export interface CreateStampinoTemplateOptions {
    handlers?: TemplateHandlers;
    renderers?: TemplateRenderers;
    superTemplate?: HTMLTemplateElement | undefined;
}
export declare function createStampinoTransformer(options?: CreateStampinoTemplateOptions): TemplateTransformer;
declare namespace path2regexp {
export interface ParseOptions {
    /**
     * Set the default delimiter for repeat parameters. (default: `'/'`)
     */
    delimiter?: string;
    /**
     * List of characters to automatically consider prefixes when parsing.
     */
    prefixes?: string;
}
export function parse(str: string, options?: ParseOptions): Token[];
export interface TokensToFunctionOptions {
    /**
     * When `true` the regexp will be case sensitive. (default: `false`)
     */
    sensitive?: boolean;
    /**
     * Function for encoding input strings for output.
     */
    encode?: (value: string, token: Key) => string;
    /**
     * When `false` the function can produce an invalid (unmatched) path. (default: `true`)
     */
    validate?: boolean;
}
export function compile<P extends object = object>(str: string, options?: ParseOptions & TokensToFunctionOptions): PathFunction<P>;
export type PathFunction<P extends object = object> = (data?: P) => string;
export function tokensToFunction<P extends object = object>(tokens: Token[], options?: TokensToFunctionOptions): PathFunction<P>;
export interface RegexpToFunctionOptions {
    /**
     * Function for decoding strings for params.
     */
    decode?: (value: string, token: Key) => string;
}
/**
 * A match result contains data about the path match.
 */
export interface MatchResult<P extends object = object> {
    path: string;
    index: number;
    params: P;
}
/**
 * A match is either `false` (no match) or a match result.
 */
export type Match<P extends object = object> = false | MatchResult<P>;
/**
 * The match function takes a string and returns whether it matched the path.
 */
export type MatchFunction<P extends object = object> = (path: string) => Match<P>;
export function match<P extends object = object>(str: Path, options?: ParseOptions & TokensToRegexpOptions & RegexpToFunctionOptions): MatchFunction<P>;
export function regexpToFunction<P extends object = object>(re: RegExp, keys: Key[], options?: RegexpToFunctionOptions): MatchFunction<P>;
/**
 * Metadata about a key.
 */
export interface Key {
    name: string | number;
    prefix: string;
    suffix: string;
    pattern: string;
    modifier: string;
}
/**
 * A token is a string (nothing special) or key metadata (capture group).
 */
export type Token = string | Key;
export interface TokensToRegexpOptions {
    /**
     * When `true` the regexp will be case sensitive. (default: `false`)
     */
    sensitive?: boolean;
    /**
     * When `true` the regexp won't allow an optional trailing delimiter to match. (default: `false`)
     */
    strict?: boolean;
    /**
     * When `true` the regexp will match to the end of the string. (default: `true`)
     */
    end?: boolean;
    /**
     * When `true` the regexp will match from the beginning of the string. (default: `true`)
     */
    start?: boolean;
    /**
     * Sets the final character for non-ending optimistic matches. (default: `/`)
     */
    delimiter?: string;
    /**
     * List of characters that can also be 'end' characters.
     */
    endsWith?: string;
    /**
     * Encode path tokens for use in the `RegExp`.
     */
    encode?: (value: string) => string;
}
export function tokensToRegexp(tokens: Token[], keys?: Key[], options?: TokensToRegexpOptions): RegExp;
/**
 * Supported `path-to-regexp` input types.
 */
export type Path = string | RegExp | Array<string | RegExp>;
export function pathToRegexp(path: Path, keys?: Key[], options?: TokensToRegexpOptions & ParseOptions): RegExp;
}
export { path2regexp };
import { $cdp, Accessible, AnyObject, Arguments, ArrayChangeRecord, CancelToken, Cancelable, Class, Constructor, EventAll, EventBroker, EventReceiver, EventSource, IStorage, IStorageDataOptions, IStorageDataReturnType, IStorageEventCallback, IStorageOptions, JST, KeyToType, Keys, NonFunctionPropertyNames, Nullish, ObservableArray, ObservableObject, PlainObject, Result, Silenceable, StorageDataTypeList, StorageInputDataTypeList, Subscribable, Subscription, TemplateCompileOptions, TypedData, Types, UnknownFunction, UnknownObject } from '@cdp/lib-core';
import { AjaxGetRequestShortcutOptions, AjaxOptions, AjaxRequestOptions, Serializable } from '@cdp/lib-worker';
export type ElementBase = Node | Window;
export type ElementResult<T> = T extends ElementBase ? T : HTMLElement;
export type SelectorBase = Node | Window | string | Nullish;
export type ElementifySeed<T extends SelectorBase = HTMLElement> = T | (T extends ElementBase ? T[] : never) | NodeListOf<T extends Node ? T : never>;
export type QueryContext = ParentNode & Partial<NonElementParentNode>;
/**
 * @en {@link DOMStatic.utils.evaluate | evaluate}() options.
 * @ja {@link DOMStatic.utils.evaluate | evaluate}() に渡すオプション
 */
export interface EvalOptions {
    type?: string;
    src?: string;
    nonce?: string;
    noModule?: string;
}
declare class DOMBase<T extends ElementBase> implements ArrayLike<T>, Iterable<T> {
    /**
     * @en number of `Element`
     * @ja 内包する `Element` 数
     */
    readonly length: number;
    /**
     * @en `Element` accessor
     * @ja `Element` への添え字アクセス
     */
    readonly [n: number]: T;
    /**
     * constructor
     *
     * @param elements
     *  - `en` operation targets `Element` array.
     *  - `ja` 操作対象の `Element` 配列
     */
    constructor(elements: T[]);
    /**
     * @en Check target is `Node` and connected to` Document` or `ShadowRoot`.
     * @ja 対象が `Node` でありかつ `Document` または `ShadowRoot` に接続されているか判定
     *
     * @param el
     *  - `en` {@link ElementBase} instance
     *  - `ja` {@link ElementBase} インスタンス
     */
    get isConnected(): boolean;
    /**
     * @en Iterator of {@link ElementBase} values in the array.
     * @ja 格納している {@link ElementBase} にアクセス可能なイテレータオブジェクトを返却
     */
    [Symbol.iterator](): Iterator<T>;
    /**
     * @en Returns an iterable of key(index), value({@link ElementBase}) pairs for every entry in the array.
     * @ja key(index), value({@link ElementBase}) 配列にアクセス可能なイテレータオブジェクトを返却
     */
    entries(): IterableIterator<[
        number,
        T
    ]>;
    /**
     * @en Returns an iterable of keys(index) in the array.
     * @ja key(index) 配列にアクセス可能なイテレータオブジェクトを返却
     */
    keys(): IterableIterator<number>;
    /**
     * @en Returns an iterable of values({@link ElementBase}) in the array.
     * @ja values({@link ElementBase}) 配列にアクセス可能なイテレータオブジェクトを返却
     */
    values(): IterableIterator<T>;
}
/**
 * @en Base interface for DOM Mixin class.
 * @ja DOM Mixin クラスの既定インターフェイス
 */
export interface DOMIterable<T extends ElementBase = HTMLElement> extends Partial<DOMBase<T>> {
    length: number;
    [n: number]: T;
    [Symbol.iterator]: () => Iterator<T>;
}
export type DOMValueType<T, K = 'value'> = T extends HTMLSelectElement ? (string | string[]) : K extends keyof T ? T[K] : string;
export type DOMData = PlainObject<TypedData>;
declare class DOMAttributes<TElement extends ElementBase> implements DOMIterable<TElement> {
    readonly [n: number]: TElement;
    readonly length: number;
    [Symbol.iterator]: () => Iterator<TElement>;
    entries: () => IterableIterator<[
        number,
        TElement
    ]>;
    /**
     * @en Add css class to elements.
     * @ja css class 要素に追加
     *
     * @param className
     *  - `en` class name or class name list (array).
     *  - `ja` クラス名またはクラス名の配列を指定
     */
    addClass(className: string | string[]): this;
    /**
     * @en Remove css class to elements.
     * @ja css class 要素を削除
     *
     * @param className
     *  - `en` class name or class name list (array).
     *  - `ja` クラス名またはクラス名の配列を指定
     */
    removeClass(className: string | string[]): this;
    /**
     * @en Determine whether any of the matched elements are assigned the given class.
     * @ja 指定されたクラス名を少なくとも要素が持っているか判定
     *
     * @param className
     *  - `en` class name
     *  - `ja` クラス名
     */
    hasClass(className: string): boolean;
    /**
     * @en Add or remove one or more classes from each element in the set of matched elements, <br>
     *     depending on either the class's presence or the value of the state argument.
     * @ja 現在の状態に応じて, 指定されたクラス名を要素に追加/削除を実行
     *
     * @param className
     *  - `en` class name or class name list (array).
     *  - `ja` クラス名またはクラス名の配列を指定
     * @param force
     *  - `en` if this argument exists, true: the classes should be added / false: removed.
     *  - `ja` 引数が存在する場合, true: クラスを追加 / false: クラスを削除
     */
    toggleClass(className: string | string[], force?: boolean): this;
    /**
     * @en Get property value. <br>
     *     The method gets the property value for only the first element in the matched set.
     * @ja プロパティ値の取得 <br>
     *     最初の要素が取得対象
     *
     * @param name
     *  - `en` target property name
     *  - `ja` プロパティ名を指定
     */
    prop<T extends NonFunctionPropertyNames<TElement>>(name: T): TElement[T];
    /**
     * @en Set single property value for the set of matched elements.
     * @ja 配下の要素に対して単一プロパティの設定
     *
     * @param name
     *  - `en` target property name
     *  - `ja` プロパティ名を指定
     * @param value
     *  - `en` target property value
     *  - `ja` 設定するプロパティ値
     */
    prop<T extends NonFunctionPropertyNames<TElement>>(name: T, value: TElement[T]): this;
    /**
     * @en Set multi property values for the set of matched elements.
     * @ja 配下の要素に対して複数プロパティの設定
     *
     * @param properties
     *  - `en` An object of property-value pairs to set.
     *  - `ja` property-value ペアを持つオブジェクトを指定
     */
    prop(properties: PlainObject): this;
    /**
     * @en Get attribute value. <br>
     *     The method gets the attribute value for only the first element in the matched set.
     * @ja 属性値の取得 <br>
     *     最初の要素が取得対象
     *
     * @param name
     *  - `en` target attribute name
     *  - `ja` 属性名を指定
     */
    attr(name: string): string | undefined;
    /**
     * @en Set single attribute value for the set of matched elements.
     * @ja 配下の要素に対して単一属性の設定
     *
     * @param name
     *  - `en` target attribute name
     *  - `ja` 属性名を指定
     * @param value
     *  - `en` target attribute value. if `null` set, remove attribute.
     *  - `ja` 設定する属性値. `null` が指定された場合削除
     */
    attr(name: string, value: string | number | boolean | null): this;
    /**
     * @en Set multi attribute values for the set of matched elements.
     * @ja 配下の要素に対して複数属性の設定
     *
     * @param attributes
     *  - `en` An object of attribute-value pairs to set.
     *  - `ja` attribute-value ペアを持つオブジェクトを指定
     */
    attr(properties: PlainObject): this;
    /**
     * @en Remove specified attribute.
     * @ja 指定した属性を削除
     *
     * @param name
     *  - `en` attribute name or attribute name list (array).
     *  - `ja` 属性名または属性名の配列を指定
     */
    removeAttr(name: string | string[]): this;
    /**
     * @en Get the current value of the first element in the set of matched elements.
     * @ja value 値の取得. 最初の要素が取得対象
     *
     * @returns
     *  - `en` `string` or `number` or `string[]` (`<select multiple='multiple'>`).
     *  - `ja` `string` または `number` または `string[]` (`<select multiple='multiple'>`)
     */
    val<T extends ElementBase = TElement>(): DOMValueType<T>;
    /**
     * @en Set the value of every matched element.
     * @ja 配下の要素に対して value 値を設定
     *
     * @param value
     *  - `en` `string` or `number` or `string[]` (`<select multiple='multiple'>`).
     *  - `ja` `string` または `number` または `string[]` (`<select multiple='multiple'>`)
     */
    val<T extends ElementBase = TElement>(value: DOMValueType<T>): this;
    /**
     * @en Return the values all `DOMStringMap` store set by an HTML5 data-* attribute for the first element in the collection.
     * @ja 最初の要素の HTML5 data-* 属性で `DOMStringMap` に格納された全データ値を返却
     */
    data(): DOMData | undefined;
    /**
     * @en Return the value at the named data store for the first element in the collection, as set by data(key, value) or by an HTML5 data-* attribute.
     * @ja 最初の要素の key で指定した HTML5 data-* 属性値を返却
     *
     * @param key
     *  - `en` string equivalent to data-`key` is given.
     *  - `ja` data-`key` に相当する文字列を指定
     */
    data(key: string): TypedData | undefined;
    /**
     * @en Store arbitrary data associated with the matched elements.
     * @ja 配下の要素に対して任意のデータを格納
     *
     * @param key
     *  - `en` string equivalent to data-`key` is given.
     *  - `ja` data-`key` に相当する文字列を指定
     * @param value
     *  - `en` data value (not only `string`)
     *  - `ja` 設定する値を指定 (文字列以外も受付可)
     */
    data(key: string, value: TypedData): this;
    /**
     * @en Remove specified data.
     * @ja 指定したデータをデータ領域から削除
     *
     * @param key
     *  - `en` string equivalent to data-`key` is given.
     *  - `ja` data-`key` に相当する文字列を指定
     */
    removeData(key: string | string[]): this;
}
export type DOMModificationCallback<T extends ElementBase, U extends ElementBase> = (index: number, element: T) => U;
declare class DOMTraversing<TElement extends ElementBase> implements DOMIterable<TElement> {
    readonly [n: number]: TElement;
    readonly length: number;
    [Symbol.iterator]: () => Iterator<TElement>;
    entries: () => IterableIterator<[
        number,
        TElement
    ]>;
    /**
     * @en Retrieve one of the elements matched by the {@link DOM} instance.
     * @ja インデックスを指定して配下の要素にアクセス
     *
     * @param index
     *  - `en` A zero-based integer indicating which element to retrieve. <br>
     *         If negative index is counted from the end of the matched set.
     *  - `ja` 0 base のインデックスを指定 <br>
     *         負値が指定された場合, 末尾からのインデックスとして解釈される
     */
    get(index: number): TElement | undefined;
    /**
     * @en Retrieve the elements matched by the {@link DOM} instance.
     * @ja 配下の要素すべてを配列で取得
     */
    get(): TElement[];
    /**
     * @en Retrieve all the elements contained in the {@link DOM} set, as an array.
     * @ja 配下の要素すべてを配列で取得
     */
    toArray(): TElement[];
    /**
     * @en Return the position of the first element within the {@link DOM} collection relative to its sibling elements.
     * @ja {@link DOM} 内の最初の要素が兄弟要素の何番目に所属するかを返却
     */
    index(): number | undefined;
    /**
     * @en Search for a given a selector, element, or {@link DOM} instance from among the matched elements.
     * @ja セレクタ, 要素, または {@link DOM} インスタンスを指定し, 配下の何番目に所属しているかを返却
     */
    index<T extends ElementBase>(selector: string | T | DOM<T>): number | undefined;
    /**
     * @en Reduce the set of matched elements to the first in the set as {@link DOM} instance.
     * @ja 管轄している最初の要素を {@link DOM} インスタンスにして取得
     */
    first(): DOM<TElement>;
    /**
     * @en Reduce the set of matched elements to the final one in the set as {@link DOM} instance.
     * @ja 管轄している末尾の要素を {@link DOM} インスタンスにして取得
     */
    last(): DOM<TElement>;
    /**
     * @en Create a new {@link DOM} instance with elements added to the set from selector.
     * @ja 指定された `selector` で取得した `Element` を追加した新規 {@link DOM} インスタンスを返却
     *
     * @param selector
     *  - `en` Object(s) or the selector string which becomes origin of {@link DOM}.
     *  - `ja` {@link DOM} のもとになるインスタンス(群)またはセレクタ文字列
     * @param context
     *  - `en` Set using `Document` context. When being un-designating, a fixed value of the environment is used.
     *  - `ja` 使用する `Document` コンテキストを指定. 未指定の場合は環境の既定値が使用される.
     */
    add<T extends SelectorBase>(selector: DOMSelector<T>, context?: QueryContext): DOM<TElement>;
    /**
     * @en Check the current matched set of elements against a selector, element, or {@link DOM} instance.
     * @ja セレクタ, 要素, または {@link DOM} インスタンスを指定し, 現在の要素のセットと一致するか確認
     *
     * @param selector
     *  - `en` Object(s) or the selector string which becomes origin of {@link DOM}, test function.
     *  - `ja` {@link DOM} のもとになるインスタンス(群)またはセレクタ文字列, テスト関数
     * @returns
     *  - `en` `true` if at least one of these elements matches the given arguments.
     *  - `ja` 引数に指定した条件が要素の一つでも一致すれば `true` を返却
     */
    is<T extends SelectorBase>(selector: DOMSelector<T> | DOMIterateCallback<TElement>): boolean;
    /**
     * @en Reduce the set of matched elements to those that match the selector or pass the function's test.
     * @ja セレクタ, 要素, または {@link DOM} インスタンスを指定し, 現在の要素のセットと一致したものを返却
     *
     * @param selector
     *  - `en` Object(s) or the selector string which becomes origin of {@link DOM}, test function.
     *  - `ja` {@link DOM} のもとになるインスタンス(群)またはセレクタ文字列, テスト関数
     * @returns
     *  - `en` New {@link DOM} instance including filtered elements.
     *  - `ja` フィルタリングされた要素を内包する 新規 {@link DOM} インスタンス
     */
    filter<T extends SelectorBase>(selector: DOMSelector<T> | DOMIterateCallback<TElement>): DOM<TElement>;
    /**
     * @en Remove elements from the set of match the selector or pass the function's test.
     * @ja セレクタ, 要素, または {@link DOM} インスタンスを指定し, 現在の要素のセットと一致したものを削除して返却
     *
     * @param selector
     *  - `en` Object(s) or the selector string which becomes origin of {@link DOM}, test function.
     *  - `ja` {@link DOM} のもとになるインスタンス(群)またはセレクタ文字列, テスト関数
     * @returns
     *  - `en` New {@link DOM} instance excluding filtered elements.
     *  - `ja` フィルタリングされた要素を以外を内包する 新規 {@link DOM} インスタンス
     */
    not<T extends SelectorBase>(selector: DOMSelector<T> | DOMIterateCallback<TElement>): DOM<TElement>;
    /**
     * @en Get the descendants of each element in the current set of matched elements, filtered by a selector.
     * @ja 配下の要素に対して指定したセレクタに一致する要素を検索
     *
     * @param selector
     *  - `en` Object(s) or the selector string which becomes origin of {@link DOM}.
     *  - `ja` {@link DOM} のもとになるインスタンス(群)またはセレクタ文字列
     */
    find<T extends SelectorBase = SelectorBase>(selector: DOMSelector<T>): DOMResult<T>;
    /**
     * @en Reduce the set of matched elements to those that have a descendant that matches the selector.
     * @ja 配下の要素に対して指定したセレクタに一致した子要素持つ要素を返却
     *
     * @param selector
     *  - `en` Object(s) or the selector string which becomes origin of {@link DOM}.
     *  - `ja` {@link DOM} のもとになるインスタンス(群)またはセレクタ文字列
     */
    has<T extends SelectorBase = SelectorBase>(selector: DOMSelector<T>): DOMResult<T>;
    /**
     * @en Pass each element in the current matched set through a function, producing a new {@link DOM} instance containing the return values.
     * @ja コールバックで変更された要素を用いて新たに {@link DOM} インスタンスを構築
     *
     * @param callback
     *  - `en` modification function object that will be invoked for each element in the current set.
     *  - `ja` 各要素に対して呼び出される変更関数
     */
    map<T extends ElementBase>(callback: DOMModificationCallback<TElement, T>): DOM<T>;
    /**
     * @en Iterate over a {@link DOM} instance, executing a function for each matched element.
     * @ja 配下の要素に対してコールバック関数を実行
     *
     * @param callback
     *  - `en` callback function object that will be invoked for each element in the current set.
     *  - `ja` 各要素に対して呼び出されるコールバック関数
     */
    each(callback: DOMIterateCallback<TElement>): this;
    /**
     * @en Reduce the set of matched elements to a subset specified by a range of indices.
     * @ja インデックス指定された範囲の要素を含む {@link DOM} インスタンスを返却
     *
     * @param begin
     *  - `en` An integer indicating the 0-based position at which the elements begin to be selected.
     *  - `ja` 取り出しの開始位置を示す 0 から始まるインデックス
     * @param end
     *  - `en` An integer indicating the 0-based position at which the elements stop being selected.
     *  - `ja` 取り出しを終える直前の位置を示す 0 から始まるインデックス
     */
    slice(begin?: number, end?: number): DOM<TElement>;
    /**
     * @en Reduce the set of matched elements to the one at the specified index.
     * @ja インデックス指定した要素を含む {@link DOM} インスタンスを返却
     *
     * @param index
     *  - `en` A zero-based integer indicating which element to retrieve. <br>
     *         If negative index is counted from the end of the matched set.
     *  - `ja` 0 base のインデックスを指定 <br>
     *         負値が指定された場合, 末尾からのインデックスとして解釈される
     */
    eq(index: number): DOM<TElement>;
    /**
     * @en For each element in the set, get the first element that matches the selector by testing the element itself and traversing up through its ancestors in the DOM tree.
     * @ja 開始要素から最も近い親要素を選択. セレクター指定した場合, マッチする最も近い親要素を返却
     *
     * @param selector
     *  - `en` Object(s) or the selector string which becomes origin of {@link DOM}, test function.
     *  - `ja` {@link DOM} のもとになるインスタンス(群)またはセレクタ文字列, テスト関数
     */
    closest<T extends SelectorBase = SelectorBase>(selector: DOMSelector<T>): DOMResult<T>;
    /**
     * @en Get the children of each element in the set of matched elements, optionally filtered by a selector.
     * @ja 各要素の子要素を取得. セレクタが指定された場合はフィルタリングされた結果を返却
     *
     * @param selector
     *  - `en` filtered by a selector.
     *  - `ja` フィルタ用セレクタ
     */
    children<T extends Node = HTMLElement, U extends SelectorBase = SelectorBase>(selector?: DOMSelector<U>): DOM<T>;
    /**
     * @en Get the first parent of each element in the current set of matched elements.
     * @ja 管轄している各要素の最初の親要素を返却
     *
     * @param selector
     *  - `en` filtered by a selector.
     *  - `ja` フィルタ用セレクタ
     * @returns {@link DOM} instance
     */
    parent<T extends Node = HTMLElement, U extends SelectorBase = SelectorBase>(selector?: DOMSelector<U>): DOM<T>;
    /**
     * @en Get the ancestors of each element in the current set of matched elements.
     * @ja 管轄している各要素の祖先の親要素を返却
     *
     * @param selector
     *  - `en` filtered by a selector.
     *  - `ja` フィルタ用セレクタ
     * @returns {@link DOM} instance
     */
    parents<T extends Node = HTMLElement, U extends SelectorBase = SelectorBase>(selector?: DOMSelector<U>): DOM<T>;
    /**
     * @en Get the ancestors of each element in the current set of matched elements, <br>
     *     up to but not including the element matched by the selector, DOM node, or {@link DOM} instance
     * @ja 管轄している各要素の祖先で, 指定したセレクターや条件に一致する要素が出てくるまで選択して取得
     *
     * @param selector
     *  - `en` Object(s) or the selector string which becomes origin of {@link DOM}.
     *  - `ja` {@link DOM} のもとになるインスタンス(群)またはセレクタ文字列
     * @param filter
     *  - `en` filtered by a string selector.
     *  - `ja` フィルタ用文字列セレクタ
     * @returns {@link DOM} instance
     */
    parentsUntil<T extends Node = HTMLElement, U extends SelectorBase = SelectorBase, V extends SelectorBase = SelectorBase>(selector?: DOMSelector<U>, filter?: DOMSelector<V>): DOM<T>;
    /**
     * @en Get the immediately following sibling of each element in the set of matched elements. <br>
     *     If a selector is provided, it retrieves the next sibling only if it matches that selector.
     * @ja 要素集合の各要素の直後にあたる兄弟要素を抽出 <br>
     *     条件式を指定し、結果セットから更に絞込みを行うことも可能
     *
     * @param selector
     *  - `en` filtered by a selector.
     *  - `ja` フィルタ用セレクタ
     */
    next<T extends Node = HTMLElement, U extends SelectorBase = SelectorBase>(selector?: DOMSelector<U>): DOM<T>;
    /**
     * @en Get all following siblings of each element in the set of matched elements, optionally filtered by a selector.
     * @ja マッチした要素集合内の各要素の次以降の全ての兄弟要素を取得. セレクタを指定することでフィルタリングすることが可能.
     *
     * @param selector
     *  - `en` filtered by a selector.
     *  - `ja` フィルタ用セレクタ
     */
    nextAll<T extends Node = HTMLElement, U extends SelectorBase = SelectorBase>(selector?: DOMSelector<U>): DOM<T>;
    /**
     * @en Get all following siblings of each element up to but not including the element matched by the selector.
     * @ja マッチした要素の次以降の兄弟要素で, 指定したセレクターや条件に一致する要素が出てくるまで選択して取得
     *
     * @param selector
     *  - `en` Object(s) or the selector string which becomes origin of {@link DOM}.
     *  - `ja` {@link DOM} のもとになるインスタンス(群)またはセレクタ文字列
     * @param filter
     *  - `en` filtered by a string selector.
     *  - `ja` フィルタ用文字列セレクタ
     */
    nextUntil<T extends Node = HTMLElement, U extends SelectorBase = SelectorBase, V extends SelectorBase = SelectorBase>(selector?: DOMSelector<U>, filter?: DOMSelector<V>): DOM<T>;
    /**
     * @en Get the immediately preceding sibling of each element in the set of matched elements. <br>
     *     If a selector is provided, it retrieves the previous sibling only if it matches that selector.
     * @ja マッチした要素集合の各要素の直前の兄弟要素を抽出 <br>
     *     条件式を指定し、結果セットから更に絞込みを行うことも可能
     *
     * @param selector
     *  - `en` filtered by a selector.
     *  - `ja` フィルタ用セレクタ
     */
    prev<T extends Node = HTMLElement, U extends SelectorBase = SelectorBase>(selector?: DOMSelector<U>): DOM<T>;
    /**
     * @en Get all preceding siblings of each element in the set of matched elements, optionally filtered by a selector.
     * @ja マッチした要素集合内の各要素の前以降の全ての兄弟要素を取得. セレクタを指定することでフィルタリングすることが可能.
     *
     * @param selector
     *  - `en` filtered by a selector.
     *  - `ja` フィルタ用セレクタ
     */
    prevAll<T extends Node = HTMLElement, U extends SelectorBase = SelectorBase>(selector?: DOMSelector<U>): DOM<T>;
    /**
     * @en Get all preceding siblings of each element up to but not including the element matched by the selector.
     * @ja マッチした要素の前以降の兄弟要素で, 指定したセレクタや条件に一致する要素が出てくるまで選択して取得
     *
     * @param selector
     *  - `en` Object(s) or the selector string which becomes origin of {@link DOM}.
     *  - `ja` {@link DOM} のもとになるインスタンス(群)またはセレクタ文字列
     * @param filter
     *  - `en` filtered by a string selector.
     *  - `ja` フィルタ用文字列セレクタ
     */
    prevUntil<T extends Node = HTMLElement, U extends SelectorBase = SelectorBase, V extends SelectorBase = SelectorBase>(selector?: DOMSelector<U>, filter?: DOMSelector<V>): DOM<T>;
    /**
     * @en Get the siblings of each element in the set of matched elements, optionally filtered by a selector
     * @ja マッチした各要素の兄弟要素を取得
     *
     * @param selector
     *  - `en` filtered by a selector.
     *  - `ja` フィルタ用セレクタ
     */
    siblings<T extends Node = HTMLElement, U extends SelectorBase = SelectorBase>(selector?: DOMSelector<U>): DOM<T>;
    /**
     * @en Get the children of each element in the set of matched elements, including text and comment nodes.
     * @ja テキストやHTMLコメントを含む子要素を取得
     */
    contents<T extends Node = HTMLElement>(): DOM<T>;
    /**
     * @en Get the closest ancestor element that is positioned.
     * @ja 要素の先祖要素で, スタイルでポジション指定(positiionがrelative, absolute, fixedのいずれか)されているものを取得
     */
    offsetParent<T extends Node = HTMLElement>(): DOM<T>;
}
declare class DOMManipulation<TElement extends ElementBase> implements DOMIterable<TElement> {
    readonly [n: number]: TElement;
    readonly length: number;
    [Symbol.iterator]: () => Iterator<TElement>;
    entries: () => IterableIterator<[
        number,
        TElement
    ]>;
    /**
     * @en Get the HTML contents of the first element in the set of matched elements.
     * @ja 先頭要素の HTML を取得
     */
    html(): string;
    /**
     * @en Set the HTML contents of each element in the set of matched elements.
     * @ja 配下の要素に指定した HTML を設定
     *
     * @param htmlString
     *  - `en` A string of HTML to set as the content of each matched element.
     *  - `ja` 要素内に挿入する HTML 文字列を指定
     */
    html(htmlString: string): this;
    /**
     * @en Get the text contents of the first element in the set of matched elements. <br>
     *     jQuery returns the combined text of each element, but this method makes only first element's text.
     * @ja 先頭要素のテキストを取得 <br>
     *     jQuery は各要素の連結テキストを返却するが本メソッドは先頭要素のみを対象とする
     */
    text(): string;
    /**
     * @en Set the content of each element in the set of matched elements to the specified text.
     * @ja 配下の要素に指定したテキストを設定
     *
     * @param text
     *  - `en` The text to set as the content of each matched element.
     *  - `ja` 要素内に挿入するテキストを指定
     */
    text(value: string | number | boolean): this;
    /**
     * @en Insert content, specified by the parameter, to the end of each element in the set of matched elements.
     * @ja 配下の要素に引数で指定したコンテンツを追加
     *
     * @param contents
     *  - `en` element(s), text node(s), HTML string, or {@link DOM} instance.
     *  - `ja` 追加する要素(群), テキストノード(群), HTML string, または {@link DOM} インスタンス
     */
    append<T extends Element>(...contents: (Node | string | DOM<T> | NodeListOf<T>)[]): this;
    /**
     * @en Insert every element in the set of matched elements to the end of the target.
     * @ja 配下要素を他の要素に追加
     *
     * @param selector
     *  - `en` Object(s) or the selector string which becomes origin of {@link DOM}.
     *  - `ja` {@link DOM} のもとになるインスタンス(群)またはセレクタ文字列
     */
    appendTo<T extends SelectorBase>(selector: DOMSelector<T>): DOMResult<T>;
    /**
     * @en Insert content, specified by the parameter, to the beginning of each element in the set of matched elements.
     * @ja 配下の要素の先頭に引数で指定したコンテンツを挿入
     *
     * @param contents
     *  - `en` element(s), text node(s), HTML string, or {@link DOM} instance.
     *  - `ja` 追加する要素(群), テキストノード(群), HTML string, または {@link DOM} インスタンス
     */
    prepend<T extends Element>(...contents: (Node | string | DOM<T> | NodeListOf<T>)[]): this;
    /**
     * @en Insert every element in the set of matched elements to the beginning of the target.
     * @ja 配下要素を他の要素の先頭に挿入
     *
     * @param selector
     *  - `en` Object(s) or the selector string which becomes origin of {@link DOM}.
     *  - `ja` {@link DOM} のもとになるインスタンス(群)またはセレクタ文字列
     */
    prependTo<T extends SelectorBase>(selector: DOMSelector<T>): DOMResult<T>;
    /**
     * @en Insert content, specified by the parameter, before each element in the set of matched elements.
     * @ja 配下の要素の前に指定した HTML や要素を挿入
     *
     * @param contents
     *  - `en` element(s), text node(s), HTML string, or {@link DOM} instance.
     *  - `ja` 追加する要素(群), テキストノード(群), HTML string, または {@link DOM} インスタンス
     */
    before<T extends Element>(...contents: (Node | string | DOM<T> | NodeListOf<T>)[]): this;
    /**
     * @en Insert every element in the set of matched elements before the target.
     * @ja 配下の要素を指定した別要素の前に挿入
     *
     * @param selector
     *  - `en` Object(s) or the selector string which becomes origin of {@link DOM}.
     *  - `ja` {@link DOM} のもとになるインスタンス(群)またはセレクタ文字列
     */
    insertBefore<T extends SelectorBase>(selector: DOMSelector<T>): DOMResult<T>;
    /**
     * @en Insert content, specified by the parameter, after each element in the set of matched elements.
     * @ja 配下の要素の後ろに指定した HTML や要素を挿入
     *
     * @param contents
     *  - `en` element(s), text node(s), HTML string, or {@link DOM} instance.
     *  - `ja` 追加する要素(群), テキストノード(群), HTML string, または {@link DOM} インスタンス
     */
    after<T extends Element>(...contents: (Node | string | DOM<T> | NodeListOf<T>)[]): this;
    /**
     * @en Insert every element in the set of matched elements after the target.
     * @ja 配下の要素を指定した別要素の後ろに挿入
     *
     * @param selector
     *  - `en` Object(s) or the selector string which becomes origin of {@link DOM}.
     *  - `ja` {@link DOM} のもとになるインスタンス(群)またはセレクタ文字列
     */
    insertAfter<T extends SelectorBase>(selector: DOMSelector<T>): DOMResult<T>;
    /**
     * @en Wrap an HTML structure around all elements in the set of matched elements.
     * @ja 配下の要素を指定した別要素でそれぞれ囲む
     *
     * @param selector
     *  - `en` Object(s) or the selector string which becomes origin of {@link DOM}.
     *  - `ja` {@link DOM} のもとになるインスタンス(群)またはセレクタ文字列
     */
    wrapAll<T extends SelectorBase>(selector: DOMSelector<T>): this;
    /**
     * @en Wrap an HTML structure around the content of each element in the set of matched elements.
     * @ja 配下の要素の内側を, 指定した別エレメントでそれぞれ囲む
     *
     * @param selector
     *  - `en` Object(s) or the selector string which becomes origin of {@link DOM}.
     *  - `ja` {@link DOM} のもとになるインスタンス(群)またはセレクタ文字列
     */
    wrapInner<T extends SelectorBase>(selector: DOMSelector<T>): this;
    /**
     * @en Wrap an HTML structure around each element in the set of matched elements.
     * @ja 配下の要素を, 指定した別要素でそれぞれ囲む
     *
     * @param selector
     *  - `en` Object(s) or the selector string which becomes origin of {@link DOM}.
     *  - `ja` {@link DOM} のもとになるインスタンス(群)またはセレクタ文字列
     */
    wrap<T extends SelectorBase>(selector: DOMSelector<T>): this;
    /**
     * @en Remove the parents of the set of matched elements from the DOM, leaving the matched elements in their place.
     * @ja 要素の親エレメントを削除
     *
     * @param selector
     *  - `en` filtered by a selector.
     *  - `ja` フィルタ用セレクタ
     */
    unwrap<T extends SelectorBase>(selector?: DOMSelector<T>): this;
    /**
     * @en Remove all child nodes of the set of matched elements from the DOM.
     * @ja 配下の要素内の子要素(テキストも対象)をすべて削除
     */
    empty(): this;
    /**
     * @en Remove the set of matched elements from the DOM. This method keeps event listener information.
     * @ja 要素を DOM から削除. 削除後もイベントリスナは有効
     *
     * @param selector
     *  - `en` Object(s) or the selector string which becomes origin of {@link DOM}.
     *  - `ja` {@link DOM} のもとになるインスタンス(群)またはセレクタ文字列
     */
    detach<T extends SelectorBase>(selector?: DOMSelector<T>): this;
    /**
     * @en Remove the set of matched elements from the DOM.
     * @ja 要素を DOM から削除
     *
     * @param selector
     *  - `en` Object(s) or the selector string which becomes origin of {@link DOM}.
     *  - `ja` {@link DOM} のもとになるインスタンス(群)またはセレクタ文字列
     */
    remove<T extends SelectorBase>(selector?: DOMSelector<T>): this;
    /**
     * @en Replace each element in the set of matched elements with the provided new content and return the set of elements that was removed.
     * @ja 配下の要素を指定された別の要素や HTML と差し替え
     *
     * @param newContent
     *  - `en` Object(s) or the selector string which becomes origin of {@link DOM}.
     *  - `ja` {@link DOM} のもとになるインスタンス(群)またはセレクタ文字列
     */
    replaceWith<T extends SelectorBase>(newContent?: DOMSelector<T>): this;
    /**
     * @en Replace each target element with the set of matched elements.
     * @ja 配下の要素を指定した別の要素と差し替え
     *
     * @param selector
     *  - `en` Object(s) or the selector string which becomes origin of {@link DOM}.
     *  - `ja` {@link DOM} のもとになるインスタンス(群)またはセレクタ文字列
     */
    replaceAll<T extends SelectorBase>(selector: DOMSelector<T>): DOMResult<T>;
}
declare class DOMStyles<TElement extends ElementBase> implements DOMIterable<TElement> {
    readonly [n: number]: TElement;
    readonly length: number;
    [Symbol.iterator]: () => Iterator<TElement>;
    entries: () => IterableIterator<[
        number,
        TElement
    ]>;
    /**
     * @en Get the computed style properties for the first element in the set of matched elements.
     * @ja 先頭要素の CSS に設定されているプロパティ値を取得
     *
     * @param name
     *  - `en` CSS property name as chain-cace.
     *  - `ja` CSS プロパティ名をチェインケースで指定
     * @returns
     *  - `en` CSS property value string.
     *  - `ja` CSS プロパティ値を文字列で返却
     */
    css(name: string): string;
    /**
     * @en Get the multiple computed style properties for the first element in the set of matched elements.
     * @ja 先頭要素の CSS に設定されているプロパティ値を複数取得
     *
     * @param names
     *  - `en` CSS property name array as chain-cace.
     *  - `ja` CSS プロパティ名配列をチェインケースで指定
     * @returns
     *  - `en` CSS property-value object.
     *  - `ja` CSS プロパティを格納したオブジェクト
     */
    css(names: string[]): PlainObject<string>;
    /**
     * @en Set CSS propertiy for the set of matched elements.
     * @ja 要素の CSS プロパティに値を設定
     *
     * @param name
     *  - `en` CSS property name as chain-cace.
     *  - `ja` CSS プロパティ名をチェインケースで指定
     * @param value
     *  - `en` string value to set for the property. if null passed, remove property.
     *  - `ja` 設定する値を文字列で指定. null 指定で削除.
     */
    css(name: string, value: string | null): this;
    /**
     * @en Set one or more CSS properties for the set of matched elements.
     * @ja 要素の CSS 複数のプロパティに値を設定
     *
     * @param properties
     *  - `en` An object of property-value pairs to set.
     *  - `ja` CSS プロパティを格納したオブジェクト
     */
    css(properties: PlainObject<string | null>): this;
    /**
     * @en Get the current computed width for the first element in the set of matched elements or set the width of every matched element.
     * @ja 最初の要素の計算済み横幅をピクセル単位で取得
     */
    width(): number;
    /**
     * @en Set the CSS width of each element in the set of matched elements.
     * @ja 配下の要素の横幅を指定
     *
     * @param value
     *  - `en` An integer representing the number of pixels, or an integer along with an optional unit of measure appended (as a string).
     *  - `ja` 引数の値が数値のときは `px` として扱い, 文字列は CSS のルールに従う
     */
    width(value: number | string): this;
    /**
     * @en Get the current computed height for the first element in the set of matched elements or set the width of every matched element.
     * @ja 最初の要素の計算済み立幅をピクセル単位で取得
     */
    height(): number;
    /**
     * @en Set the CSS height of each element in the set of matched elements.
     * @ja 配下の要素の縦幅を指定
     *
     * @param value
     *  - `en` An integer representing the number of pixels, or an integer along with an optional unit of measure appended (as a string).
     *  - `ja` 引数の値が数値のときは `px` として扱い, 文字列は CSS のルールに従う
     */
    height(value: number | string): this;
    /**
     * @en Get the current computed inner width for the first element in the set of matched elements, including padding but not border.
     * @ja 最初の要素の内部横幅(borderは除き、paddingは含む)を取得
     */
    innerWidth(): number;
    /**
     * @en Set the CSS inner width of each element in the set of matched elements.
     * @ja 配下の要素の内部横幅(borderは除き、paddingは含む)を設定
     *
     * @param value
     *  - `en` An integer representing the number of pixels, or an integer along with an optional unit of measure appended (as a string).
     *  - `ja` 引数の値が数値のときは `px` として扱い, 文字列は CSS のルールに従う
     */
    innerWidth(value: number | string): this;
    /**
     * @en Get the current computed inner height for the first element in the set of matched elements, including padding but not border.
     * @ja 最初の要素の内部縦幅(borderは除き、paddingは含む)を取得
     */
    innerHeight(): number;
    /**
     * @en Set the CSS inner height of each element in the set of matched elements.
     * @ja 配下の要素の内部縦幅(borderは除き、paddingは含む)を設定
     *
     * @param value
     *  - `en` An integer representing the number of pixels, or an integer along with an optional unit of measure appended (as a string).
     *  - `ja` 引数の値が数値のときは `px` として扱い, 文字列は CSS のルールに従う
     */
    innerHeight(value: number | string): this;
    /**
     * @en Get the current computed outer width (including padding, border, and optionally margin) for the first element in the set of matched elements.
     * @ja 最初の要素の外部横幅(border、paddingを含む)を取得. オプション指定によりマージン領域を含めたものも取得可
     *
     * @param includeMargin
     *  - `en` A Boolean indicating whether to include the element's margin in the calculation.
     *  - `ja` マージン領域を含める場合は true を指定
     */
    outerWidth(includeMargin?: boolean): number;
    /**
     * @en Set the CSS outer width of each element in the set of matched elements.
     * @ja 配下の要素の外部横幅(border、paddingを含む)を設定
     *
     * @param value
     *  - `en` An integer representing the number of pixels, or an integer along with an optional unit of measure appended (as a string).
     *  - `ja` 引数の値が数値のときは `px` として扱い, 文字列は CSS のルールに従う
     * @param includeMargin
     *  - `en` A Boolean indicating whether to include the element's margin in the calculation.
     *  - `ja` マージン領域を含める場合は true を指定
     */
    outerWidth(value: number | string, includeMargin?: boolean): this;
    /**
     * @en Get the current computed outer height (including padding, border, and optionally margin) for the first element in the set of matched elements.
     * @ja 最初の要素の外部縦幅(border、paddingを含む)を取得. オプション指定によりマージン領域を含めたものも取得可
     *
     * @param includeMargin
     *  - `en` A Boolean indicating whether to include the element's margin in the calculation.
     *  - `ja` マージン領域を含める場合は true を指定
     */
    outerHeight(includeMargin?: boolean): number;
    /**
     * @en Set the CSS outer height of each element in the set of matched elements.
     * @ja 配下の要素の外部縦幅(border、paddingを含む)を設定
     *
     * @param value
     *  - `en` An integer representing the number of pixels, or an integer along with an optional unit of measure appended (as a string).
     *  - `ja` 引数の値が数値のときは `px` として扱い, 文字列は CSS のルールに従う
     * @param includeMargin
     *  - `en` A Boolean indicating whether to include the element's margin in the calculation.
     *  - `ja` マージン領域を含める場合は true を指定
     */
    outerHeight(value: number | string, includeMargin?: boolean): this;
    /**
     * @en Get the current coordinates of the first element in the set of matched elements, relative to the offset parent.
     * @ja 最初の要素の親要素からの相対的な表示位置を返却
     */
    position(): {
        top: number;
        left: number;
    };
    /**
     * @en Get the current coordinates of the first element in the set of matched elements, relative to the document.
     * @ja document を基準として, マッチしている要素集合の1つ目の要素の現在の座標を取得
     */
    offset(): {
        top: number;
        left: number;
    };
    /**
     * @en Set the current coordinates of every element in the set of matched elements, relative to the document.
     * @ja 配下の要素に document を基準にした現在座標を設定
     *
     * @param coordinates
     *  - `en` An object containing the properties `top` and `left`.
     *  - `ja` `top`, `left` プロパティを含むオブジェクトを指定
     */
    offset(coordinates: {
        top?: number;
        left?: number;
    }): this;
}
export interface ConnectEventMap {
    'connected': Event;
    'disconnected': Event;
}
export type DOMEventMap<T> = T extends Window ? WindowEventMap : T extends Document ? DocumentEventMap : T extends HTMLBodyElement ? HTMLBodyElementEventMap & ConnectEventMap : T extends HTMLMediaElement ? HTMLMediaElementEventMap & ConnectEventMap : T extends HTMLElement ? HTMLElementEventMap & ConnectEventMap : T extends Element ? ElementEventMap & ConnectEventMap : GlobalEventHandlersEventMap;
export type DOMEventListener<T = HTMLElement, M extends DOMEventMap<T> = DOMEventMap<T>> = (event: M[keyof M], ...args: unknown[]) => unknown;
export type EventWithNamespace<T extends DOMEventMap<unknown>> = keyof T | `${string & keyof T}.${string}`;
export type MakeEventType<T, M> = T extends keyof M ? keyof M : (T extends `${string & keyof M}.${infer C}` ? `${string & keyof M}.${C}` : never);
export type EventType<T extends DOMEventMap<unknown>> = MakeEventType<EventWithNamespace<T>, T>;
export type EventTypeOrNamespace<T extends DOMEventMap<unknown>> = EventType<T> | `.${string}`;
declare class DOMEvents<TElement extends ElementBase> implements DOMIterable<TElement> {
    readonly [n: number]: TElement;
    readonly length: number;
    [Symbol.iterator]: () => Iterator<TElement>;
    entries: () => IterableIterator<[
        number,
        TElement
    ]>;
    /**
     * @en Add event handler function to one or more events to the elements. (live event available)
     * @ja 要素に対して, 1つまたは複数のイベントハンドラを設定 (動的要素にも有効)
     *
     * @param type
     *  - `en` event name or event name array.
     *  - `ja` イベント名またはイベント名配列
     * @param selector
     *  - `en` A selector string to filter the descendants of the selected elements that trigger the event.
     *  - `ja` イベント発行元をフィルタリングするセレクタ文字列
     * @param listener
     *  - `en` callback function
     *  - `ja` コールバック関数
     * @param options
     *  - `en` options for `addEventLisntener`
     *  - `ja` `addEventLisntener` に指定するオプション
     */
    on<TEventMap extends DOMEventMap<TElement>>(type: EventType<TEventMap> | (EventType<TEventMap>)[], selector: string, listener: DOMEventListener<TElement, TEventMap>, options?: boolean | AddEventListenerOptions): this;
    /**
     * @en Add event handler function to one or more events to the elements. (live event available)
     * @ja 要素に対して, 1つまたは複数のイベントハンドラを設定 (動的要素にも有効)
     *
     * @param type
     *  - `en` event name or event name array.
     *  - `ja` イベント名またはイベント名配列
     * @param listener
     *  - `en` callback function
     *  - `ja` コールバック関数
     * @param options
     *  - `en` options for `addEventLisntener`
     *  - `ja` `addEventLisntener` に指定するオプション
     */
    on<TEventMap extends DOMEventMap<TElement>>(type: EventType<TEventMap> | (EventType<TEventMap>)[], listener: DOMEventListener<TElement, TEventMap>, options?: boolean | AddEventListenerOptions): this;
    /**
     * @en Remove event handler. The handler designated at {@link DOMEvents.on | on}() or {@link DOMEvents.once | once}() and that same condition are released. <br>
     *     If the method receives no arguments, all handlers are released.
     * @ja 設定されているイベントハンドラの解除. {@link DOMEvents.on | on}() または {@link DOMEvents.once | once}() と同条件で指定したものが解除される <br>
     *     引数が無い場合はすべてのハンドラが解除される.
     *
     * @param type
     *  - `en` event name or event name array.
     *  - `ja` イベント名またはイベント名配列
     * @param selector
     *  - `en` A selector string to filter the descendants of the selected elements that trigger the event.
     *  - `ja` イベント発行元をフィルタリングするセレクタ文字列
     * @param listener
     *  - `en` callback function
     *  - `ja` コールバック関数
     * @param options
     *  - `en` options for `addEventLisntener`
     *  - `ja` `addEventLisntener` に指定するオプション
     */
    off<TEventMap extends DOMEventMap<TElement>>(type: EventTypeOrNamespace<TEventMap> | (EventTypeOrNamespace<TEventMap>)[], selector: string, listener?: DOMEventListener<TElement, TEventMap>, options?: boolean | AddEventListenerOptions): this;
    /**
     * @en Remove event handler. The handler designated at {@link DOMEvents.on | on}() or {@link DOMEvents.once | once}() and that same condition are released. <br>
     *     If the method receives no arguments, all handlers are released.
     * @ja 設定されているイベントハンドラの解除. {@link DOMEvents.on | on}() または {@link DOMEvents.once | once}() と同条件で指定したものが解除される <br>
     *     引数が無い場合はすべてのハンドラが解除される.
     *
     * @param type
     *  - `en` event name or event name array.
     *  - `ja` イベント名またはイベント名配列
     * @param listener
     *  - `en` callback function
     *  - `ja` コールバック関数
     * @param options
     *  - `en` options for `addEventLisntener`
     *  - `ja` `addEventLisntener` に指定するオプション
     */
    off<TEventMap extends DOMEventMap<TElement>>(type: EventTypeOrNamespace<TEventMap> | (EventTypeOrNamespace<TEventMap>)[], listener?: DOMEventListener<TElement, TEventMap>, options?: boolean | AddEventListenerOptions): this;
    /**
     * @en Remove all event handler.
     * @ja 設定されているすべてのイベントハンドラの解除
     */
    off(): this;
    /**
     * @en Add event handler function to one or more events to the elements that will be executed only once. (live event available)
     * @ja 要素に対して, 一度だけ呼び出されるイベントハンドラを設定 (動的要素に対しても有効)
     *
     * @param type
     *  - `en` event name or event name array.
     *  - `ja` イベント名またはイベント名配列
     * @param selector
     *  - `en` A selector string to filter the descendants of the selected elements that trigger the event.
     *  - `ja` イベント発行元をフィルタリングするセレクタ文字列
     * @param listener
     *  - `en` callback function
     *  - `ja` コールバック関数
     * @param options
     *  - `en` options for `addEventLisntener`
     *  - `ja` `addEventLisntener` に指定するオプション
     */
    once<TEventMap extends DOMEventMap<TElement>>(type: EventType<TEventMap> | (EventType<TEventMap>)[], selector: string, listener: DOMEventListener<TElement, TEventMap>, options?: boolean | AddEventListenerOptions): this;
    /**
     * @en Add event handler function to one or more events to the elements that will be executed only once. (live event available)
     * @ja 要素に対して, 一度だけ呼び出されるイベントハンドラを設定 (動的要素に対しても有効)
     *
     * @param type
     *  - `en` event name or event name array.
     *  - `ja` イベント名またはイベント名配列
     * @param listener
     *  - `en` callback function
     *  - `ja` コールバック関数
     * @param options
     *  - `en` options for `addEventLisntener`
     *  - `ja` `addEventLisntener` に指定するオプション
     */
    once<TEventMap extends DOMEventMap<TElement>>(type: EventType<TEventMap> | (EventType<TEventMap>)[], listener: DOMEventListener<TElement, TEventMap>, options?: boolean | AddEventListenerOptions): this;
    /**
     * @en Execute all handlers added to the matched elements for the specified event.
     * @ja 設定されているイベントハンドラに対してイベントを発行
     *
     * @example <br>
     *
     * ```ts
     * // w/ event-namespace behaviour
     * $('.link').on('click.hoge.piyo', (e) => { ... });
     * $('.link').on('click.hoge',  (e) => { ... });
     *
     * $('.link').trigger('.hoge');           // compile error. (not fire)
     * $('.link').trigger('click.hoge');      // fire both.
     * $('.link').trigger('click.hoge.piyo'); // fire only first one
     * ```
     * @param seed
     *  - `en` event name or event name array. / `Event` instance or `Event` instance array.
     *  - `ja` イベント名またはイベント名配列 / `Event` インスタンスまたは `Event` インスタンス配列
     * @param eventData
     *  - `en` optional sending data.
     *  - `ja` 送信する任意のデータ
     */
    trigger<TEventMap extends DOMEventMap<TElement>>(seed: EventType<TEventMap> | (EventType<TEventMap>)[] | Event | Event[] | (EventType<TEventMap> | Event)[], ...eventData: unknown[]): this;
    /**
     * @en Shortcut for {@link DOMEvents.once | once}('transitionstart').
     * @ja {@link DOMEvents.once | once}('transitionstart') のユーティリティ
     *
     * @param callback
     *  - `en` `transitionstart` handler.
     *  - `ja` `transitionstart` ハンドラ
     * @param permanent
     *  - `en` if set `true`, callback keep living until elements removed.
     *  - `ja` `true` を設定した場合, 要素が削除されるまでコールバックが有効
     */
    transitionStart(callback: (event: TransitionEvent, ...args: unknown[]) => void, permanent?: boolean): this;
    /**
     * @en Shortcut for {@link DOMEvents.once | once}('transitionend').
     * @ja {@link DOMEvents.once | once}('transitionend') のユーティリティ
     *
     * @param callback
     *  - `en` `transitionend` handler.
     *  - `ja` `transitionend` ハンドラ
     * @param permanent
     *  - `en` if set `true`, callback keep living until elements removed.
     *  - `ja` `true` を設定した場合, 要素が削除されるまでコールバックが有効
     */
    transitionEnd(callback: (event: TransitionEvent, ...args: unknown[]) => void, permanent?: boolean): this;
    /**
     * @en Shortcut for {@link DOMEvents.once | once}('animationstart').
     * @ja {@link DOMEvents.once | once}('animationstart') のユーティリティ
     *
     * @param callback
     *  - `en` `animationstart` handler.
     *  - `ja` `animationstart` ハンドラ
     * @param permanent
     *  - `en` if set `true`, callback keep living until elements removed.
     *  - `ja` `true` を設定した場合, 要素が削除されるまでコールバックが有効
     */
    animationStart(callback: (event: AnimationEvent, ...args: unknown[]) => void, permanent?: boolean): this;
    /**
     * @en Shortcut for {@link DOMEvents.once | once}('animationend').
     * @ja {@link DOMEvents.once | once}('animationend') のユーティリティ
     *
     * @param callback
     *  - `en` `animationend` handler.
     *  - `ja` `animationend` ハンドラ
     * @param permanent
     *  - `en` if set `true`, callback keep living until elements removed.
     *  - `ja` `true` を設定した場合, 要素が削除されるまでコールバックが有効
     */
    animationEnd(callback: (event: AnimationEvent, ...args: unknown[]) => void, permanent?: boolean): this;
    /**
     * @en Bind one or two handlers to the matched elements, to be executed when the `mouseenter` and `mouseleave` the elements.
     * @ja 1つまたは2つのハンドラを指定し, 一致した要素の `mouseenter`, `mouseleave` を検知
     *
     * @param handlerIn(Out)
     *  - `en` A function to execute when the `mouseenter` the element. <br>
     *        If handler set only one, a function to execute when the `mouseleave` the element, too.
     *  - `ja` `mouseenter` イベントハンドラを指定. <br>
     *          引数が1つである場合, `mouseleave` ハンドラも兼ねる
     * @param handlerOut
     *  - `en` A function to execute when the `mouseleave` the element.
     *  - `ja` `mouseleave` ハンドラを指定
     */
    hover(handlerIn: DOMEventListener, handlerOut?: DOMEventListener): this;
    /**
     * @en Trigger or handle `click` event.
     * @ja `click` イベントの発行または捕捉
     *
     * @param handler
     *  - `en` event handler is designated. when omitting, the event is triggered.
     *  - `ja` イベントハンドラを指定. 省略した場合はイベントを発行
     * @param options
     *  - `en` options for `addEventLisntener`
     *  - `ja` `addEventLisntener` に指定するオプション
     */
    click(handler?: DOMEventListener, options?: boolean | AddEventListenerOptions): this;
    /**
     * @en Trigger or handle `dblclick` event.
     * @ja `dblclick` イベントの発行または捕捉
     *
     * @param handler
     *  - `en` event handler is designated. when omitting, the event is triggered.
     *  - `ja` イベントハンドラを指定. 省略した場合はイベントを発行
     * @param options
     *  - `en` options for `addEventLisntener`
     *  - `ja` `addEventLisntener` に指定するオプション
     */
    dblclick(handler?: DOMEventListener, options?: boolean | AddEventListenerOptions): this;
    /**
     * @en Trigger or handle `blur` event.
     * @ja `blur` イベントの発行または捕捉
     *
     * @param handler
     *  - `en` event handler is designated. when omitting, the event is triggered.
     *  - `ja` イベントハンドラを指定. 省略した場合はイベントを発行
     * @param options
     *  - `en` options for `addEventLisntener`
     *  - `ja` `addEventLisntener` に指定するオプション
     */
    blur(handler?: DOMEventListener, options?: boolean | AddEventListenerOptions): this;
    /**
     * @en Trigger or handle `focus` event.
     * @ja `focus` イベントの発行または捕捉
     *
     * @param handler
     *  - `en` event handler is designated. when omitting, the event is triggered.
     *  - `ja` イベントハンドラを指定. 省略した場合はイベントを発行
     * @param options
     *  - `en` options for `addEventLisntener`
     *  - `ja` `addEventLisntener` に指定するオプション
     */
    focus(handler?: DOMEventListener, options?: boolean | AddEventListenerOptions): this;
    /**
     * @en Trigger or handle `focusin` event.
     * @ja `focusin` イベントの発行または捕捉
     *
     * @param handler
     *  - `en` event handler is designated. when omitting, the event is triggered.
     *  - `ja` イベントハンドラを指定. 省略した場合はイベントを発行
     * @param options
     *  - `en` options for `addEventLisntener`
     *  - `ja` `addEventLisntener` に指定するオプション
     */
    focusin(handler?: DOMEventListener, options?: boolean | AddEventListenerOptions): this;
    /**
     * @en Trigger or handle `focusout` event.
     * @ja `focusout` イベントの発行または捕捉
     *
     * @param handler
     *  - `en` event handler is designated. when omitting, the event is triggered.
     *  - `ja` イベントハンドラを指定. 省略した場合はイベントを発行
     * @param options
     *  - `en` options for `addEventLisntener`
     *  - `ja` `addEventLisntener` に指定するオプション
     */
    focusout(handler?: DOMEventListener, options?: boolean | AddEventListenerOptions): this;
    /**
     * @en Trigger or handle `keyup` event.
     * @ja `keyup` イベントの発行または捕捉
     *
     * @param handler
     *  - `en` event handler is designated. when omitting, the event is triggered.
     *  - `ja` イベントハンドラを指定. 省略した場合はイベントを発行
     * @param options
     *  - `en` options for `addEventLisntener`
     *  - `ja` `addEventLisntener` に指定するオプション
     */
    keyup(handler?: DOMEventListener, options?: boolean | AddEventListenerOptions): this;
    /**
     * @en Trigger or handle `keydown` event.
     * @ja `keydown` イベントの発行または捕捉
     *
     * @param handler
     *  - `en` event handler is designated. when omitting, the event is triggered.
     *  - `ja` イベントハンドラを指定. 省略した場合はイベントを発行
     * @param options
     *  - `en` options for `addEventLisntener`
     *  - `ja` `addEventLisntener` に指定するオプション
     */
    keydown(handler?: DOMEventListener, options?: boolean | AddEventListenerOptions): this;
    /**
     * @en Trigger or handle `keypress` event.
     * @ja `keypress` イベントの発行または捕捉
     *
     * @param handler
     *  - `en` event handler is designated. when omitting, the event is triggered.
     *  - `ja` イベントハンドラを指定. 省略した場合はイベントを発行
     * @param options
     *  - `en` options for `addEventLisntener`
     *  - `ja` `addEventLisntener` に指定するオプション
     */
    keypress(handler?: DOMEventListener, options?: boolean | AddEventListenerOptions): this;
    /**
     * @en Trigger or handle `submit` event.
     * @ja `submit` イベントの発行または捕捉
     *
     * @param handler
     *  - `en` event handler is designated. when omitting, the event is triggered.
     *  - `ja` イベントハンドラを指定. 省略した場合はイベントを発行
     * @param options
     *  - `en` options for `addEventLisntener`
     *  - `ja` `addEventLisntener` に指定するオプション
     */
    submit(handler?: DOMEventListener, options?: boolean | AddEventListenerOptions): this;
    /**
     * @en Trigger or handle `contextmenu` event.
     * @ja `contextmenu` イベントの発行または捕捉
     *
     * @param handler
     *  - `en` event handler is designated. when omitting, the event is triggered.
     *  - `ja` イベントハンドラを指定. 省略した場合はイベントを発行
     * @param options
     *  - `en` options for `addEventLisntener`
     *  - `ja` `addEventLisntener` に指定するオプション
     */
    contextmenu(handler?: DOMEventListener, options?: boolean | AddEventListenerOptions): this;
    /**
     * @en Trigger or handle `change` event.
     * @ja `change` イベントの発行または捕捉
     *
     * @param handler
     *  - `en` event handler is designated. when omitting, the event is triggered.
     *  - `ja` イベントハンドラを指定. 省略した場合はイベントを発行
     * @param options
     *  - `en` options for `addEventLisntener`
     *  - `ja` `addEventLisntener` に指定するオプション
     */
    change(handler?: DOMEventListener, options?: boolean | AddEventListenerOptions): this;
    /**
     * @en Trigger or handle `mousedown` event.
     * @ja `mousedown` イベントの発行または捕捉
     *
     * @param handler
     *  - `en` event handler is designated. when omitting, the event is triggered.
     *  - `ja` イベントハンドラを指定. 省略した場合はイベントを発行
     * @param options
     *  - `en` options for `addEventLisntener`
     *  - `ja` `addEventLisntener` に指定するオプション
     */
    mousedown(handler?: DOMEventListener, options?: boolean | AddEventListenerOptions): this;
    /**
     * @en Trigger or handle `mousemove` event.
     * @ja `mousemove` イベントの発行または捕捉
     *
     * @param handler
     *  - `en` event handler is designated. when omitting, the event is triggered.
     *  - `ja` イベントハンドラを指定. 省略した場合はイベントを発行
     * @param options
     *  - `en` options for `addEventLisntener`
     *  - `ja` `addEventLisntener` に指定するオプション
     */
    mousemove(handler?: DOMEventListener, options?: boolean | AddEventListenerOptions): this;
    /**
     * @en Trigger or handle `mouseup` event.
     * @ja `mouseup` イベントの発行または捕捉
     *
     * @param handler
     *  - `en` event handler is designated. when omitting, the event is triggered.
     *  - `ja` イベントハンドラを指定. 省略した場合はイベントを発行
     * @param options
     *  - `en` options for `addEventLisntener`
     *  - `ja` `addEventLisntener` に指定するオプション
     */
    mouseup(handler?: DOMEventListener, options?: boolean | AddEventListenerOptions): this;
    /**
     * @en Trigger or handle `mouseenter` event.
     * @ja `mouseenter` イベントの発行または捕捉
     *
     * @param handler
     *  - `en` event handler is designated. when omitting, the event is triggered.
     *  - `ja` イベントハンドラを指定. 省略した場合はイベントを発行
     * @param options
     *  - `en` options for `addEventLisntener`
     *  - `ja` `addEventLisntener` に指定するオプション
     */
    mouseenter(handler?: DOMEventListener, options?: boolean | AddEventListenerOptions): this;
    /**
     * @en Trigger or handle `mouseleave` event.
     * @ja `mouseleave` イベントの発行または捕捉
     *
     * @param handler
     *  - `en` event handler is designated. when omitting, the event is triggered.
     *  - `ja` イベントハンドラを指定. 省略した場合はイベントを発行
     * @param options
     *  - `en` options for `addEventLisntener`
     *  - `ja` `addEventLisntener` に指定するオプション
     */
    mouseleave(handler?: DOMEventListener, options?: boolean | AddEventListenerOptions): this;
    /**
     * @en Trigger or handle `mouseout` event.
     * @ja `mouseout` イベントの発行または捕捉
     *
     * @param handler
     *  - `en` event handler is designated. when omitting, the event is triggered.
     *  - `ja` イベントハンドラを指定. 省略した場合はイベントを発行
     * @param options
     *  - `en` options for `addEventLisntener`
     *  - `ja` `addEventLisntener` に指定するオプション
     */
    mouseout(handler?: DOMEventListener, options?: boolean | AddEventListenerOptions): this;
    /**
     * @en Trigger or handle `mouseover` event.
     * @ja `mouseover` イベントの発行または捕捉
     *
     * @param handler
     *  - `en` event handler is designated. when omitting, the event is triggered.
     *  - `ja` イベントハンドラを指定. 省略した場合はイベントを発行
     * @param options
     *  - `en` options for `addEventLisntener`
     *  - `ja` `addEventLisntener` に指定するオプション
     */
    mouseover(handler?: DOMEventListener, options?: boolean | AddEventListenerOptions): this;
    /**
     * @en Trigger or handle `touchstart` event.
     * @ja `touchstart` イベントの発行または捕捉
     *
     * @param handler
     *  - `en` event handler is designated. when omitting, the event is triggered.
     *  - `ja` イベントハンドラを指定. 省略した場合はイベントを発行
     * @param options
     *  - `en` options for `addEventLisntener`
     *  - `ja` `addEventLisntener` に指定するオプション
     */
    touchstart(handler?: DOMEventListener, options?: boolean | AddEventListenerOptions): this;
    /**
     * @en Trigger or handle `touchend` event.
     * @ja `touchend` イベントの発行または捕捉
     *
     * @param handler
     *  - `en` event handler is designated. when omitting, the event is triggered.
     *  - `ja` イベントハンドラを指定. 省略した場合はイベントを発行
     * @param options
     *  - `en` options for `addEventLisntener`
     *  - `ja` `addEventLisntener` に指定するオプション
     */
    touchend(handler?: DOMEventListener, options?: boolean | AddEventListenerOptions): this;
    /**
     * @en Trigger or handle `touchmove` event.
     * @ja `touchmove` イベントの発行または捕捉
     *
     * @param handler
     *  - `en` event handler is designated. when omitting, the event is triggered.
     *  - `ja` イベントハンドラを指定. 省略した場合はイベントを発行
     * @param options
     *  - `en` options for `addEventLisntener`
     *  - `ja` `addEventLisntener` に指定するオプション
     */
    touchmove(handler?: DOMEventListener, options?: boolean | AddEventListenerOptions): this;
    /**
     * @en Trigger or handle `touchcancel` event.
     * @ja `touchcancel` イベントの発行または捕捉
     *
     * @param handler
     *  - `en` event handler is designated. when omitting, the event is triggered.
     *  - `ja` イベントハンドラを指定. 省略した場合はイベントを発行
     * @param options
     *  - `en` options for `addEventLisntener`
     *  - `ja` `addEventLisntener` に指定するオプション
     */
    touchcancel(handler?: DOMEventListener, options?: boolean | AddEventListenerOptions): this;
    /**
     * @en Trigger or handle `resize` event.
     * @ja `resize` イベントの発行または捕捉
     *
     * @param handler
     *  - `en` event handler is designated. when omitting, the event is triggered.
     *  - `ja` イベントハンドラを指定. 省略した場合はイベントを発行
     * @param options
     *  - `en` options for `addEventLisntener`
     *  - `ja` `addEventLisntener` に指定するオプション
     */
    resize(handler?: DOMEventListener, options?: boolean | AddEventListenerOptions): this;
    /**
     * @en Trigger or handle `scroll` event.
     * @ja `scroll` イベントの発行または捕捉
     *
     * @param handler
     *  - `en` event handler is designated. when omitting, the event is triggered.
     *  - `ja` イベントハンドラを指定. 省略した場合はイベントを発行
     * @param options
     *  - `en` options for `addEventLisntener`
     *  - `ja` `addEventLisntener` に指定するオプション
     */
    scroll(handler?: DOMEventListener, options?: boolean | AddEventListenerOptions): this;
    /**
     * @en Create a deep copy of the set of matched elements.
     * @ja 配下の要素のディープコピーを作成
     *
     * @param withEvents
     *  - `en` A Boolean indicating whether event handlers should be copied along with the elements.
     *  - `ja` イベントハンドラもコピーするかどうかを決定
     * @param deep
     *  - `en` A Boolean indicating whether event handlers for all children of the cloned element should be copied.
     *  - `ja` boolean値で、配下の要素のすべての子要素に対しても、付随しているイベントハンドラをコピーするかどうかを決定
     */
    clone(withEvents?: boolean, deep?: boolean): DOM<TElement>;
}
/**
 * @en {@link DOM}`.scrollTo()` options definition.
 * @ja {@link DOM}`.scrollTo()` に指定するオプション定義
 */
export interface DOMScrollOptions {
    /**
     * @en the vertical scroll value by pixcels.
     * @ja 縦スクロール量をピクセルで指定
     */
    top?: number;
    /**
     * @en the horizontal scroll value by pixcels.
     * @ja 横スクロール量をピクセルで指定
     */
    left?: number;
    /**
     * @en the time to spend on scroll. [msec]
     * @ja スクロールに費やす時間 [msec]
     */
    duration?: number;
    /**
     * @en timing function default: 'swing'
     * @ja タイミング関数 既定値: 'swing'
     */
    easing?: 'linear' | 'swing' | ((progress: number) => number);
    /**
     * @en scroll completion callback.
     * @ja スクロール完了コールバック
     */
    callback?: () => void;
}
declare class DOMScroll<TElement extends ElementBase> implements DOMIterable<TElement> {
    readonly [n: number]: TElement;
    readonly length: number;
    [Symbol.iterator]: () => Iterator<TElement>;
    entries: () => IterableIterator<[
        number,
        TElement
    ]>;
    /**
     * @en Get the number of pixels vertical scrolled.
     * @ja 縦方向スクロールされたピクセル数を取得
     */
    scrollTop(): number;
    /**
     * @en Set the number of pixels vertical scrolled.
     * @ja 縦方向スクロールするピクセル数を指定
     *
     * @param position
     *  - `en` the scroll value by pixcels.
     *  - `ja` スクロール量をピクセルで指定
     * @param duration
     *  - `en` the time to spend on scroll. [msec]
     *  - `ja` スクロールに費やす時間 [msec]
     * @param easing
     *  - `en` timing function default: 'swing'
     *  - `ja` タイミング関数 既定値: 'swing'
     * @param callback
     *  - `en` scroll completion callback.
     *  - `ja` スクロール完了コールバック
     */
    scrollTop(position: number, duration?: number, easing?: 'linear' | 'swing' | ((progress: number) => number), callback?: () => void): this;
    /**
     * @en Get the number of pixels horizontal scrolled.
     * @ja 横方向スクロールされたピクセル数を取得
     */
    scrollLeft(): number;
    /**
     * @en Set the number of pixels horizontal scrolled.
     * @ja 横方向スクロールするピクセル数を指定
     *
     * @param position
     *  - `en` the scroll value by pixcels.
     *  - `ja` スクロール量をピクセルで指定
     * @param duration
     *  - `en` the time to spend on scroll. [msec]
     *  - `ja` スクロールに費やす時間 [msec]
     * @param easing
     *  - `en` timing function default: 'swing'
     *  - `ja` タイミング関数 既定値: 'swing'
     * @param callback
     *  - `en` scroll completion callback.
     *  - `ja` スクロール完了コールバック
     */
    scrollLeft(position: number, duration?: number, easing?: 'linear' | 'swing' | ((progress: number) => number), callback?: () => void): this;
    /**
     * @en Set the number of pixels vertical and horizontal scrolled.
     * @ja 縦横方向スクロールするピクセル数を指定
     *
     * @param x
     *  - `en` the horizontal scroll value by pixcels.
     *  - `ja` 横スクロール量をピクセルで指定
     * @param y
     *  - `en` the vertical scroll value by pixcels.
     *  - `ja` 縦スクロール量をピクセルで指定
     * @param duration
     *  - `en` the time to spend on scroll. [msec]
     *  - `ja` スクロールに費やす時間 [msec]
     * @param easing
     *  - `en` timing function default: 'swing'
     *  - `ja` タイミング関数 既定値: 'swing'
     * @param callback
     *  - `en` scroll completion callback.
     *  - `ja` スクロール完了コールバック
     */
    scrollTo(x: number, y: number, duration?: number, easing?: 'linear' | 'swing' | ((progress: number) => number), callback?: () => void): this;
    /**
     * @en Set the scroll values by optoins.
     * @ja オプションを用いてスクロール指定
     */
    scrollTo(options: DOMScrollOptions): this;
}
/**
 * @en {@link DOM} effect parameter.
 * @ja {@link DOM} エフェクト効果のパラメータ
 */
export type DOMEffectParameters = Keyframe[] | PropertyIndexedKeyframes | null;
/**
 * @en {@link DOM} effect options.
 * @ja {@link DOM} エフェクト効果のオプション
 */
export type DOMEffectOptions = number | KeyframeAnimationOptions;
/**
 * @en {@link DOM} effect context object.
 * @ja {@link DOM} のエフェクト効果のコンテキストオブジェクト
 */
export interface DOMEffectContext<TElement extends ElementBase> {
    /**
     * @en {@link DOM} instance that called {@link DOMEffects.animate | animate}() method.
     * @ja {@link DOMEffects.animate | animate}() メソッドを実行した {@link DOM} インスタンス
     */
    readonly dom: DOM<TElement>;
    /**
     * @en `Element` and `Animation` instance map by execution {@link DOMEffects.animate | animate}() method at this time.
     * @ja 今回 {@link DOMEffects.animate | animate}() 実行した `Element` と `Animation` インスタンスのマップ
     */
    readonly animations: Map<TElement, Animation>;
    /**
     * @en The current finished Promise for this animation.
     * @ja 対象アニメーションの終了時に発火する `Promise` オブジェクト
     */
    readonly finished: Promise<DOMEffectContext<TElement>>;
}
declare class DOMEffects<TElement extends ElementBase> implements DOMIterable<TElement> {
    readonly [n: number]: TElement;
    readonly length: number;
    [Symbol.iterator]: () => Iterator<TElement>;
    entries: () => IterableIterator<[
        number,
        TElement
    ]>;
    /**
     * @en Start animation by `Web Animation API`.
     * @ja `Web Animation API` を用いてアニメーションを実行
     */
    animate(params: DOMEffectParameters, options: DOMEffectOptions): DOMEffectContext<TElement>;
    /**
     * @en Cancel current running animation.
     * @ja 現在実行しているアニメーションを中止
     */
    cancel(): this;
    /**
     * @en Finish current running animation.
     * @ja 現在実行しているアニメーションを終了
     */
    finish(): this;
    /**
     * @en Execute force reflow.
     * @ja 強制リフローを実行
     */
    reflow(): this;
    /**
     * @en Execute force repaint.
     * @ja 強制再描画を実行
     */
    repaint(): this;
}
export type DOMFeatures<T extends ElementBase> = DOMBase<T> & DOMAttributes<T> & DOMTraversing<T> & DOMManipulation<T> & DOMStyles<T> & DOMEvents<T> & DOMScroll<T> & DOMEffects<T>;
/**
 * @en {@link DOM} plugin method definition.
 * @ja {@link DOM} プラグインメソッド定義
 *
 * @note
 *  - プラグイン拡張定義はこのインターフェイスマージする.
 *  - TypeScript 3.7 時点で, module interface のマージは module の完全なパスを必要とするため,
 *    本レポジトリでは bundle した `dist/dom.d.ts` を提供する.
 *
 * @see
 *  - https://github.com/microsoft/TypeScript/issues/33326
 *  - https://stackoverflow.com/questions/57848134/trouble-updating-an-interface-using-declaration-merging
 */
export interface DOMPlugin {
}
/**
 * @en This interface provides DOM operations like `jQuery` library.
 * @ja `jQuery` のようなDOM 操作を提供するインターフェイス
 */
export interface DOM<T extends ElementBase = HTMLElement> extends DOMFeatures<T>, DOMPlugin {
}
export type DOMSelector<T extends SelectorBase = HTMLElement> = ElementifySeed<T> | DOM<T extends ElementBase ? T : never>;
export type DOMResult<T extends SelectorBase> = T extends DOM<ElementBase> ? T : (T extends ElementBase ? DOM<T> : DOM<HTMLElement>);
export type DOMIterateCallback<T extends ElementBase> = (index: number, element: T) => boolean | void;
declare const DOMClass_base: import('@cdp/lib-core').MixinConstructor<typeof DOMBase, import('@cdp/lib-core').MixinClass & DOMBase<ElementBase> & DOMAttributes<any> & DOMTraversing<any> & DOMManipulation<any> & DOMStyles<any> & DOMEvents<any> & DOMScroll<any> & DOMEffects<any> & object>;
declare class DOMClass extends DOMClass_base {
    /**
     * private constructor
     *
     * @param elements
     *  - `en` operation targets `Element` array.
     *  - `ja` 操作対象の `Element` 配列
     */
    private constructor();
}
/**
 * @en Check the value-type is {@link DOM}.
 * @ja {@link DOM} 型であるか判定
 *
 * @param x
 *  - `en` evaluated value
 *  - `ja` 評価する値
 */
export declare function isDOMClass(x: unknown): x is DOM;
/**
 * @en Provides functionality equivalent to `jQuery` DOM manipulation.
 * @ja `jQuery` の DOM 操作と同等の機能を提供
 *
 * @example <br>
 *
 * ```ts
 * import { dom as $ } from '@cdp/runtime';
 *
 * // Get the <button> element with the class 'continue' and change its HTML to 'Next Step...'
 * $('button.continue').html('Next Step...');
 * ```
 */
export interface DOMStatic {
    /**
     * @en Provides functionality equivalent to `jQuery` DOM manipulation. <br>
     *     Create {@link DOM} instance from `selector` arg.
     * @ja `jQuery` の DOM 操作と同等の機能を提供 <br>
     *     指定された `selector` {@link DOM} インスタンスを作成
     *
     * @example <br>
     *
     * ```ts
     * import { dom as $ } from '@cdp/runtime';
     *
     * // Get the <button> element with the class 'continue' and change its HTML to 'Next Step...'
     * $('button.continue').html('Next Step...');
     * ```
     *
     * @param selector
     *  - `en` Object(s) or the selector string which becomes origin of {@link DOM}.
     *  - `ja` {@link DOM} のもとになるオブジェクト(群)またはセレクタ文字列
     * @param context
     *  - `en` Set using `Document` context. When being un-designating, a fixed value of the environment is used.
     *  - `ja` 使用する `Document` コンテキストを指定. 未指定の場合は環境の既定値が使用される.
     * @returns {@link DOM} instance.
     */
    <T extends SelectorBase>(selector?: DOMSelector<T>, context?: QueryContext | null): DOMResult<T>;
    /**
     * @en The object's `prototype` alias.
     * @ja オブジェクトの `prototype`エイリアス
     */
    fn: DOMClass & Record<string | symbol, unknown>;
    /** DOM Utilities */
    readonly utils: {
        /**
         * @en Check the value-type is Window.
         * @ja Window 型であるか判定
         *
         * @param x
         *  - `en` evaluated value
         *  - `ja` 評価する値
         */
        isWindowContext(x: unknown): x is Window;
        /**
         * @en Create Element array from seed arg.
         * @ja 指定された Seed から Element 配列を作成
         *
         * @param seed
         *  - `en` Object(s) or the selector string which becomes origin of Element array.
         *  - `ja` Element 配列のもとになるオブジェクト(群)またはセレクタ文字列
         * @param context
         *  - `en` Set using `Document` context. When being un-designating, a fixed value of the environment is used.
         *  - `ja` 使用する `Document` コンテキストを指定. 未指定の場合は環境の既定値が使用される.
         * @returns Element[] based Node or Window object.
         */
        elementify<T extends SelectorBase>(seed?: ElementifySeed<T>, context?: QueryContext | null): ElementResult<T>[];
        /**
         * @en Create Element array from seed arg. <br>
         *     And also lists for the `DocumentFragment` inside the `<template>` tag.
         * @ja 指定された Seed から Element 配列を作成 <br>
         *     `<template>` タグ内の `DocumentFragment` も列挙する
         *
         * @param seed
         *  - `en` Object(s) or the selector string which becomes origin of Element array.
         *  - `ja` Element 配列のもとになるオブジェクト(群)またはセレクタ文字列
         * @param context
         *  - `en` Set using `Document` context. When being un-designating, a fixed value of the environment is used.
         *  - `ja` 使用する `Document` コンテキストを指定. 未指定の場合は環境の既定値が使用される.
         * @returns Element[] based Node.
         */
        rootify<T extends SelectorBase>(seed?: ElementifySeed<T>, context?: QueryContext | null): ElementResult<T>[];
        /**
         * @en The `eval` function by which script `nonce` attribute considered under the CSP condition.
         * @ja CSP 環境においてスクリプト `nonce` 属性を考慮した `eval` 実行関数
         */
        evaluate(code: string, options?: Element | EvalOptions, context?: Document | null): any;
        /**
         * @en Enabling the node to detect events of DOM connected and disconnected.
         * @ja 要素に対して, DOM への接続, DOM からの切断イベントを検出可能にする
         *
         * @example <br>
         *
         * ```ts
         * import { dom } from '@cdp/runtime';
         * const { detectify, undetectify } = dom.utils;
         *
         * const el = document.createElement('div');
         *
         * // observation start
         * detectify(el);
         * el.addEventListener('connected', () => {
         *     console.log('on connected');
         * });
         * el.addEventListener('disconnected', () => {
         *     console.log('on disconnected');
         * });
         *
         * // observation stop
         * undetectify(el);
         * ```
         *
         * @param node
         *  - `en` target node
         *  - `ja` 対象の要素
         * @param observed
         *  - `en` Specifies the root element to watch. If not specified, `ownerDocument` is evaluated first, followed by global `document`.
         *  - `ja` 監視対象のルート要素を指定. 未指定の場合は `ownerDocument`, グローバル `document` の順に評価される
         */
        detectify<T extends Node>(node: T, observed?: Node): T;
        /**
         * @en Undetect connected and disconnected from DOM events for an element.
         * @ja 要素に対して, DOM への接続, DOM からの切断イベントを検出を解除する
         *
         * @param node
         *  - `en` target node. If not specified, execute all release.
         *  - `ja` 対象の要素. 指定しない場合は全解除を実行
         */
        undetectify<T extends Node>(node?: T): void;
    };
}
export declare const dom: DOMStatic;
/**
 * @en DOM relation event map hash.
 * @ja DOM イベントに関連付けるハッシュ定義
 */
export type ViewEventsHash<TElement extends Node = HTMLElement, TFuncName = string> = Record<string, TFuncName | DOMEventListener<TElement>>;
/**
 * @en {@link View} construction options.
 * @ja {@link View} 構築に指定するオプション
 */
export interface ViewConstructionOptions<TElement extends Node = HTMLElement, TFuncName = string> {
    el?: DOMSelector<TElement | string>;
    events?: ViewEventsHash<TElement, TFuncName>;
    id?: string;
    className?: string;
    tagName?: string;
    attributes?: PlainObject<string | number | boolean | null>;
}
export type ViewFindSelector = Node | string | Nullish;
/**
 * @en Core implementation of {@link View} without {@link EventSource} interface. <br>
 *     Can be specified as mixin source.
 * @ja {@link EventSource} インターフェイスを持たない {@link View} のコア実装 <br>
 *     Mixin source として指定可能
 */
export declare abstract class ViewCore<TElement extends Node = HTMLElement> {
    /**
     * constructor
     *
     * @param options
     *  - `en` construction options.
     *  - `ja` 構築オプション
     */
    constructor(options?: ViewConstructionOptions<TElement>);
    /**
     * @en Release all listeners.
     * @ja すべてのリスナーを解除
     */
    release(): this;
    /**
     * @en Remove this view by taking the element out of the DOM with release all listeners.
     * @ja View から DOM を切り離し, リスナーを解除
     */
    remove(): this;
    /**
     * @en Get content ID.
     * @ja コンテンツ ID を取得
     */
    get id(): string;
    /**
     * @en Get element.
     * @ja 要素を取得
     */
    get el(): TElement;
    /**
     * @en Get {@link DOM} object.
     * @ja {@link DOM} オブジェクトを取得
     */
    get $el(): DOM<TElement>;
    /**
     * @en Get internal content ID.
     * @ja 内部のコンテンツ ID を取得
     */
    protected get _cid(): string;
    /**
     * @en Get default tag name.
     * @ja 既定のタグ名を取得
     */
    protected get _tagName(): string;
    /**
     * @en Attributes instance
     * @ja 属性を格納するインスタンス
     */
    protected get _attrs(): PlainObject<string | number | boolean | null>;
    /**
     * @en Change the view's element (`this.el` property) and re-delegate the view's events on the new element.
     * @ja View が管轄する要素 (`this.el` property) の変更. イベント再設定も実行
     *
     * @param el
     *  - `en` Object or the selector string which becomes origin of element.
     *  - `ja` 要素のもとになるオブジェクトまたはセレクタ文字列
     */
    setElement(el: DOMSelector<TElement | string>): this;
    /**
     * @en Set DOM callbacks from {@link ViewEventsHash} object.
     * @ja {@link ViewEventsHash} オブジェクトから DOM コールバックを設定
     *
     * @param events
     *  - `en` {@link ViewEventsHash} object. `this.events()` is used by default.
     *  - `ja` {@link ViewEventsHash} オブジェクト. 既定値は `this.events()`
     */
    delegateEvents(events?: ViewEventsHash<TElement>): this;
    /**
     * @en Clears all callbacks previously bound to the view by `delegate`.
     * @ja `delegate` されたイベントをすべて削除
     */
    undelegateEvents(): this;
    /**
     * @en Add event handler function to one or more events to the elements. (live event available)
     * @ja 要素に対して, 1つまたは複数のイベントハンドラを設定 (動的要素にも有効)
     *
     * @param type
     *  - `en` event name or event name array.
     *  - `ja` イベント名またはイベント名配列
     * @param selector
     *  - `en` A selector string to filter the descendants of the selected elements that trigger the event.
     *  - `ja` イベント発行元をフィルタリングするセレクタ文字列
     * @param listener
     *  - `en` callback function
     *  - `ja` コールバック関数
     * @param options
     *  - `en` options for `addEventLisntener`
     *  - `ja` `addEventLisntener` に指定するオプション
     */
    delegate<TEventMap extends DOMEventMap<TElement>>(type: EventType<TEventMap> | (EventType<TEventMap>)[], selector: string, listener: DOMEventListener<TElement, TEventMap>, options?: boolean | AddEventListenerOptions): this;
    /**
     * @en Add event handler function to one or more events to the elements. (live event available)
     * @ja 要素に対して, 1つまたは複数のイベントハンドラを設定 (動的要素にも有効)
     *
     * @param type
     *  - `en` event name or event name array.
     *  - `ja` イベント名またはイベント名配列
     * @param listener
     *  - `en` callback function
     *  - `ja` コールバック関数
     * @param options
     *  - `en` options for `addEventLisntener`
     *  - `ja` `addEventLisntener` に指定するオプション
     */
    delegate<TEventMap extends DOMEventMap<TElement>>(type: EventType<TEventMap> | (EventType<TEventMap>)[], listener: DOMEventListener<TElement, TEventMap>, options?: boolean | AddEventListenerOptions): this;
    /**
     * @en Remove event handler. The handler designated at {@link DOMEvents.on} or {@link DOMEvents.once} and that same condition are released. <br>
     *     If the method receives no arguments, all handlers are released.
     * @ja 設定されているイベントハンドラの解除. {@link DOMEvents.on} または {@link DOMEvents.once} と同条件で指定したものが解除される <br>
     *     引数が無い場合はすべてのハンドラが解除される.
     *
     * @param type
     *  - `en` event name or event name array.
     *  - `ja` イベント名またはイベント名配列
     * @param selector
     *  - `en` A selector string to filter the descendants of the selected elements that trigger the event.
     *  - `ja` イベント発行元をフィルタリングするセレクタ文字列
     * @param listener
     *  - `en` callback function
     *  - `ja` コールバック関数
     * @param options
     *  - `en` options for `addEventLisntener`
     *  - `ja` `addEventLisntener` に指定するオプション
     */
    undelegate<TEventMap extends DOMEventMap<TElement>>(type: EventTypeOrNamespace<TEventMap> | (EventTypeOrNamespace<TEventMap>)[], selector: string, listener?: DOMEventListener<TElement, TEventMap>, options?: boolean | AddEventListenerOptions): this;
    /**
     * @en Remove event handler. The handler designated at {@link DOMEvents.on} or {@link DOMEvents.once} and that same condition are released. <br>
     *     If the method receives no arguments, all handlers are released.
     * @ja 設定されているイベントハンドラの解除. {@link DOMEvents.on} または {@link DOMEvents.once} と同条件で指定したものが解除される <br>
     *     引数が無い場合はすべてのハンドラが解除される.
     *
     * @param type
     *  - `en` event name or event name array.
     *  - `ja` イベント名またはイベント名配列
     * @param listener
     *  - `en` callback function
     *  - `ja` コールバック関数
     * @param options
     *  - `en` options for `addEventLisntener`
     *  - `ja` `addEventLisntener` に指定するオプション
     */
    undelegate<TEventMap extends DOMEventMap<TElement>>(type: EventTypeOrNamespace<TEventMap> | (EventTypeOrNamespace<TEventMap>)[], listener?: DOMEventListener<TElement, TEventMap>, options?: boolean | AddEventListenerOptions): this;
    /**
     * @en Get the descendants of each element in the current set of matched elements, filtered by a selector.
     * @ja 配下の要素に対して指定したセレクタに一致する要素を検索
     *
     * @param selector
     *  - `en` Object(s) or the selector string which becomes origin of DOM.
     *  - `ja` DOM のもとになるインスタンス(群)またはセレクタ文字列
     */
    $<T extends ViewFindSelector = ViewFindSelector>(selector: DOMSelector<T>): DOMResult<T>;
    /**
     * @en The events hash (or method) can be used to specify a set of DOM events that will be bound to methods on your View through delegateEvents.
     * @ja イベントセレクタとコールバックのハッシュを定義し, ルートエンティティで捕捉する DOM イベントを指定
     *
     *
     * @example <br>
     *
     * ```ts
     * class SampleView extends View {
     *     protected events(): ViewEventsHash {
     *         return {
     *             'mousedown .title':  'edit',
     *             'click .button':     'save',
     *             'click .open':       function(e) { ... },
     *             'click .close':      this.onClose,
     *         };
     *     }
     * }
     * ```
     *
     * @override
     */
    protected events(): ViewEventsHash<TElement>;
    /**
     * @en Implement this function with your code that renders the view template from model data, and updates `this.el` with the new HTML.
     * @ja `this.el` 更新時の新しい HTML をレンダリングロジックの実装関数. モデル更新と View テンプレートを連動させる.
     *
     * @example <br>
     *
     * ```ts
     * import { TemplateEngine } from '@cdp/runtime';
     *
     * class SampleView extends View {
     *     private _template = TemplateEngine.compile('{{title}}');
     *     render(): void {
     *         this.$el.html(this._template(this.model));
     *     }
     * }
     * ```
     */
    abstract render(...args: unknown[]): any;
}
/**
 * @en Base class definition for view that manages the layout and a DOM events.
 * @ja レイアウト管理と DOM イベントの監視を行う View の基底クラス定義
 *
 * @example <br>
 *
 * ```ts
 * import {
 *     TemplateEngine,
 *     DOM, dom as $,
 *     View, ViewEventsHash,
 * } from '@cdp/rumtime';
 * import { ToDo, ToDoEventSource } from './todo';
 *
 * const _template = TemplateEngine.compile($('#item-template').html());
 *
 * export class ToDoView extends View {
 *     private _model: ToDo;
 *     private _$input?: DOM<HTMLInputElement>;
 *
 *     constructor(todo: ToDo) {
 *         super({ tagName: 'li' });
 *         this._model = todo;
 *         this.listenTo(this._model as ToDoEventSource, '@change', this.render.bind(this));
 *         this.listenTo(this._model as ToDoEventSource, '@destroy', this.remove.bind(this));
 *     }
 *
 *     protected events(): ViewEventsHash<HTMLElement> {
 *         return {
 *             'click .toggle':   this.toggleDone,
 *             'dblclick .view':  this.edit,
 *             'click a.destroy': this.clear,
 *             'keypress .edit':  this.updateOnEnter,
 *             'blur .edit':      this.close,
 *         };
 *     }
 *
 *     render(): this {
 *         this.$el.html(_template(this._model.toJSON()));
 *         this.$el.toggleClass('done', this._model.done);
 *         this._$input = this.$('.edit') as DOM<HTMLInputElement>;
 *         return this;
 *     }
 *     :
 * }
 * ```
 */
export type View<TElement extends Node = HTMLElement, TEvent extends object = object> = ViewCore<TElement> & EventSource<TEvent>;
export declare const View: {
    readonly prototype: View<any, any>;
    new <TElement extends Node = HTMLElement, TEvent extends object = object>(options?: ViewConstructionOptions<TElement>): View<TElement, TEvent>;
};
/**
 * @en Get the directory to which `url` belongs.
 * @ja 指定 `url` の所属するディレクトリを取得
 *
 * @param url
 *  - `en` target URL
 *  - `ja` 対象の URL
 */
export declare const getWebDirectory: (url: string) => string;
/**
 * @en Accsessor for Web root location <br>
 *     Only the browser environment will be an allocating place in index.html, and becomes effective.
 * @ja Web root location へのアクセス <br>
 *     index.html の配置場所となり、ブラウザ環境のみ有効となる.
 */
export declare const webRoot: string;
/**
 * @en Convert to an absolute url string if given a relative path. <br>
 *     If you want to access to Assets and in spite of the script location, the function is available.
 * @ja 相対パスが指定されている場合は、絶対URL文字列に変換 <br>
 *     js の配置に依存することなく `assets` アクセスしたいときに使用する.
 *
 * @see https://stackoverflow.com/questions/2188218/relative-paths-in-javascript-in-an-external-file
 *
 * @example <br>
 *
 * ```ts
 *  console.log(toUrl('/res/data/collection.json'));
 *  // 'http://localhost:8080/app/res/data/collection.json'
 * ```
 *
 * @param seed
 *  - `en` set relative path from {@link webRoot}.
 *  - `ja` {@link webRoot} からの相対パスを指定
 */
export declare const toUrl: (seed: string) => string;
/**
 * @en Get the timing that does not block the rendering process etc.
 * @ja レンダリング処理等をブロックしないタイミングを取得
 *
 * @example <br>
 *
 * ```ts
 *  await waitFrame();
 * ```
 *
 * @param frameCount
 *  - `en` wait frame count.
 *  - `ja` 処理待ちを行うフレーム数
 * @param executor
 *  - `en` wait frame executor.
 *  - `ja` 処理待ちを行う実行関数
 */
export declare function waitFrame(frameCount?: number, executor?: UnknownFunction): Promise<void>;
/**
 * @en Wait until the current thread is idle.
 * @ja 現在のスレッドがアイドル状態になるまで待機
 *
 * @example <br>
 *
 * ```ts
 *  await waitIdle();
 * ```
 *
 */
export declare function waitIdle(options?: IdleRequestOptions): Promise<void>;
/**
 * @en Load template options.
 * @ja ロードテンプレートオプション
 */
export interface LoadTemplateOptions extends AjaxGetRequestShortcutOptions {
    /**
     * @en The template acquisition URL. if not specified the template will be searched from `document`.
     * @ja テンプレート取得先 URL. 指定がない場合は `document` から検索
     */
    url?: string;
    /**
     * @en If you don't want to cache the template in memory, given `true`.
     * @ja テンプレートをメモリにキャッシュしない場合は `true` を指定
     */
    noCache?: boolean;
}
/**
 * @en Clear template's resources.
 * @ja テンプレートリソースキャッシュの削除
 */
export declare function clearTemplateCache(): void;
/**
 * @en Load template source.
 * @ja テンプレートソースのロード
 *
 * @param selector
 *  - `en` The selector string of DOM.
 *  - `ja` DOM セレクタ文字列
 * @param options
 *  - `en` load options
 *  - `ja` ロードオプション
 */
export declare function loadTemplateSource(selector: string, options?: LoadTemplateOptions): Promise<string | HTMLTemplateElement | undefined>;
/**
 * @en Forced conversion to HTML string.
 * @ja HTML 文字列に強制変換
 *
 * @param src
 *  - `en` `HTMLTemplateElement` instance or HTML string
 *  - `ja` `HTMLTemplateElement` インスタンスまたは HTML 文字列
 */
export declare function toTemplateString(src: string | HTMLTemplateElement | undefined): string | undefined;
/**
 * @en Forced conversion to `HTMLTemplateElement`. (If it is a Node, create a clone with `cloneNode(true)`)
 * @ja `HTMLTemplateElement` に強制変換 (Nodeである場合には `cloneNode(true)` による複製を作成)
 *
 * @param src
 *  - `en` `HTMLTemplateElement` instance or HTML string
 *  - `ja` `HTMLTemplateElement` インスタンスまたは HTML 文字列
 */
export declare function toTemplateElement(src: string | HTMLTemplateElement | undefined): HTMLTemplateElement | undefined;
/**
 * @en Platform information.
 * @ja プラットフォーム情報
 *
 * @see other framework implementation <br>
 *  - Framework7
 *    - https://github.com/framework7io/framework7/blob/master/src/core/shared/get-device.js
 *    - https://github.com/framework7io/framework7/blob/master/src/core/shared/get-device.d.ts
 *    - https://github.com/framework7io/framework7/blob/master/src/core/shared/get-support.js
 *    - https://github.com/framework7io/framework7/blob/master/src/core/shared/get-support.d.ts
 *    - https://github.com/framework7io/framework7/blob/v4/src/core/utils/device.js    // check legacy device: iPhoneX etc
 *    - https://github.com/framework7io/framework7/blob/v4/src/core/utils/device.d.ts
 *  - OnsenUI
 *    - https://github.com/OnsenUI/OnsenUI/blob/master/core/src/ons/platform.js
 *  - Web
 *    - https://www.bit-hive.com/articles/20190820
 */
export interface Platform {
    /** true for iOS info */
    readonly ios: boolean;
    /** true for Android info */
    readonly android: boolean;
    /** true for Android Chrome */
    readonly androidChrome: boolean;
    /** true for desktop browser */
    readonly desktop: boolean;
    /** true for mobile info */
    readonly mobile: boolean;
    /** true for smart phone (including iPod) info */
    readonly phone: boolean;
    /** true for tablet info */
    readonly tablet: boolean;
    /** true for iPhone */
    readonly iphone: boolean;
    /** true for iPhoneX */
    readonly iphoneX: boolean;
    /** true for iPod */
    readonly ipod: boolean;
    /** true for iPad */
    readonly ipad: boolean;
    /** true for MS Edge browser */
    readonly edge: boolean;
    /** true for Internet Explorer browser*/
    readonly ie: boolean;
    /** true for FireFox browser*/
    readonly firefox: boolean;
    /** true for desktop MacOS */
    readonly macos: boolean;
    /** true for desktop Windows */
    readonly windows: boolean;
    /** true when app running in cordova environment */
    readonly cordova: boolean;
    /** true when app running in electron environment */
    readonly electron: boolean;
    /** Contains OS can be ios, android or windows (for Windows Phone) */
    readonly os: string;
    /** Contains OS version, e.g. 11.2.0 */
    readonly osVersion: string | null | undefined;
    /** Device pixel ratio */
    readonly pixelRatio: number;
}
/**
 * @en Query platform information.
 * @ja プラットフォーム情報の取得
 *
 * @param context
 *  - `en` given `Navigator`, `Screen`, `devicePixelRatio` information.
 *  - `ja` 環境の `Navigator`, `Screen`, `devicePixelRatio` を指定
 */
export declare const queryPlatform: (context?: {
    navigator?: {
        userAgent: string;
        platform: string;
        standalone?: boolean;
    };
    screen?: {
        width: number;
        height: number;
    };
    devicePixelRatio?: number;
}) => Platform;
/**
 * @en Platform information on runtime.
 * @ja ランタイムのプラットフォーム情報
 */
export declare const platform: Platform;
/**
 * @en The behaviour for `i18next` error detection.
 * @ja `i18next` のエラー検知時の振る舞い
 */
export interface I18NDetectErrorBehaviour extends Cancelable {
    /** default: true */
    noThrow?: boolean;
}
/**
 * @en Option interface for {@link initializeI18N}().
 * @ja {@link initializeI18N}() に指定するオプションインターフェイス
 */
export interface I18NOptions extends i18n.InitOptions, I18NDetectErrorBehaviour {
    /** short-cut for `ns` & 'defaultNS' */
    namespace?: string;
    /** backend options */
    backend?: i18n.AjaxBackendOptions | PlainObject;
    /** short-cut for backend.loadPath */
    resourcePath?: string;
    /** fallback resource name mapping [lng, locale]*/
    fallbackResources?: Record<string, string>;
    /** dom-localizer options */
    dom?: i18n.DomLocalizerOptions;
}
/**
 * @en Translate funcion.
 * @ja 翻訳関数
 */
export declare const t: i18n.TFunction;
/**
 * @en Initialize `i18next` instance.
 * @ja `i18next` インスタンスの初期化
 *
 * @param options
 *  - `en` init options
 *  - `ja` 初期化オプションを指定
 */
export declare const initializeI18N: (options?: I18NOptions) => Promise<i18n.TFunction>;
/**
 * @en Get the current detected or set language.
 * @ja 現在設定されている言語を取得
 *
 * @returns `ja-JP`, `ja`
 */
export declare const getLanguage: () => string;
/**
 * @en Get an array of `language-codes` that will be used it order to lookup the translation value.
 * @ja 翻訳の検索に使用される `language-codes` リストを取得
 *
 * @see
 *  - https://www.i18next.com/overview/api#languages
 */
export declare const getLanguageList: () => readonly string[];
/**
 * @en Changes the language.
 * @ja 言語の切り替え
 */
export declare const changeLanguage: (lng: string, options?: I18NDetectErrorBehaviour) => Promise<i18n.TFunction>;
/**
 * @en DOM localizer method.
 * @ja DOM ローカライズ
 *
 * @param selector
 *  - `en` Object(s) or the selector string which becomes origin of {@link DOM}.
 *  - `ja` {@link DOM} のもとになるオブジェクト(群)またはセレクタ文字列
 * @param options
 *  - `en` translation options.
 *  - `ja` 翻訳オプション
 */
export declare const localize: <T extends string | Node>(selector: DOMSelector<T>, options?: i18n.TOptions) => DOMResult<T>;
/**
 * @en Web storage data type set interface.
 * @ja Web storage に格納可能な型の集合
 */
export type WebStorageDataTypeList = StorageDataTypeList & Serializable;
/** WebStorage I/O options */
export type WebStorageOptions<K extends Keys<WebStorageDataTypeList> = Keys<WebStorageDataTypeList>> = IStorageDataOptions<WebStorageDataTypeList, K>;
/** WebStorage return value */
export type WebStorageResult<K extends Keys<WebStorageDataTypeList>> = KeyToType<WebStorageDataTypeList, K>;
/** WebStorage data type */
export type WebStorageDataTypes = Types<WebStorageDataTypeList>;
/** MemoryStorage return type */
export type WebStorageReturnType<D extends WebStorageDataTypes> = IStorageDataReturnType<StorageDataTypeList, D>;
/** WebStorage input data type */
export type WebStorageInputDataTypes = StorageInputDataTypeList<WebStorageDataTypeList>;
/** WebStorage event callback */
export type WebStorageEventCallback = IStorageEventCallback<WebStorageDataTypeList>;
/**
 * @en Web storage class. This class implements `IStorage` interface by using `window.localStorage`.
 * @ja ウェブストレージクラス. 本クラスは `window.localStorage` を用いて `IStorage` を実装
 */
export declare class WebStorage implements IStorage<WebStorageDataTypeList> {
    /**
     * constructor
     *
     * @param storage
     *  - `en` Web {@link Storage} instance
     *  - `ja` Web {@link Storage} インスタンス
     */
    constructor(storage: Storage);
    /**
     * @en {@link IStorage} kind signature.
     * @ja {@link IStorage} の種別を表す識別子
     */
    get kind(): string;
    /**
     * @en Returns the current value associated with the given key, or null if the given key does not exist in the list associated with the object.
     * @ja キーに対応する値を取得. 存在しない場合は null を返却
     *
     * @param key
     *  - `en` access key
     *  - `ja` アクセスキー
     * @param options
     *  - `en` I/O options
     *  - `ja` I/O オプション
     * @returns
     *  - `en` Returns the value which corresponds to a key with type change designated in `dataType`.
     *  - `ja` `dataType` で指定された型変換を行って, キーに対応する値を返却
     */
    getItem<D extends WebStorageDataTypes = WebStorageDataTypes>(key: string, options?: WebStorageOptions<never>): Promise<WebStorageReturnType<D>>;
    /**
     * @en Returns the current value associated with the given key, or null if the given key does not exist in the list associated with the object.
     * @ja キーに対応する値を取得. 存在しない場合は null を返却
     *
     * @param key
     *  - `en` access key
     *  - `ja` アクセスキー
     * @param options
     *  - `en` I/O options
     *  - `ja` I/O オプション
     * @returns
     *  - `en` Returns the value which corresponds to a key with type change designated in `dataType`.
     *  - `ja` `dataType` で指定された型変換を行って, キーに対応する値を返却
     */
    getItem<K extends Keys<WebStorageDataTypeList>>(key: string, options?: WebStorageOptions<K>): Promise<WebStorageResult<K> | null>;
    /**
     * @en Sets the value of the pair identified by key to value, creating a new key/value pair if none existed for key previously.
     * @ja キーを指定して値を設定. 存在しない場合は新規に作成
     *
     * @param key
     *  - `en` access key
     *  - `ja` アクセスキー
     * @param options
     *  - `en` I/O options
     *  - `ja` I/O オプション
     */
    setItem<V extends WebStorageInputDataTypes>(key: string, value: V, options?: WebStorageOptions<never>): Promise<void>;
    /**
     * @en Removes the key/value pair with the given key from the list associated with the object, if a key/value pair with the given key exists.
     * @ja 指定されたキーに対応する値が存在すれば削除
     *
     * @param options
     *  - `en` storage options
     *  - `ja` ストレージオプション
     */
    removeItem(key: string, options?: IStorageOptions): Promise<void>;
    /**
     * @en Empties the list associated with the object of all key/value pairs, if there are any.
     * @ja すべてのキーに対応する値を削除
     *
     * @param options
     *  - `en` storage options
     *  - `ja` ストレージオプション
     */
    clear(options?: IStorageOptions): Promise<void>;
    /**
     * @en Returns all entry keys.
     * @ja すべてのキー一覧を返却
     *
     * @param options
     *  - `en` cancel options
     *  - `ja` キャンセルオプション
     */
    keys(options?: Cancelable): Promise<string[]>;
    /**
     * @en Subscrive event(s).
     * @ja イベント購読設定
     *
     * @param listener
     *  - `en` callback function.
     *  - `ja` たコールバック関数
     */
    on(listener: WebStorageEventCallback): Subscription;
    /**
     * @en Unsubscribe event(s).
     * @ja イベント購読解除
     *
     * @param listener
     *  - `en` callback function.
     *         When not set this parameter, listeners are released.
     *  - `ja` コールバック関数
     *         指定しない場合はすべてを解除
     */
    off(listener?: WebStorageEventCallback): void;
}
export declare const webStorage: WebStorage;
/**
 * @en The event definition fired in {@link IDataSync}.
 * @ja {@link IDataSync} 内から発行されるイベント定義
 */
export interface SyncEvent<T extends object> {
    /** @args [context, response] */
    '@request': [
        EventBroker<SyncEvent<T>>,
        Promise<T | PlainObject>
    ];
}
/**
 * @en List of the methods and the return value types {@link IDataSync} supports.
 * @ja {@link IDataSync} がサポートするメソッドと戻り値のリスト
 */
export interface SyncMethodList<T extends object = PlainObject> {
    create: PlainObject | void;
    update: PlainObject | void;
    patch: PlainObject | void;
    delete: PlainObject | void;
    read: T;
}
/**
 * @en {@link IDataSync.sync | IDataSync.sync}() method list.
 * @ja {@link IDataSync.sync | IDataSync.sync}() に指定するメソッド一覧
 */
export type SyncMethods = keyof SyncMethodList;
/**
 * @en Return type of {@link IDataSync.sync | IDataSync.sync}().
 * @ja {@link IDataSync.sync | IDataSync.sync}() の戻り値の型
 */
export type SyncResult<K extends SyncMethods, T extends object = PlainObject> = KeyToType<SyncMethodList<T>, K>;
/**
 * @en Default {@link SyncContext} type.
 * @ja {@link SyncContext} の既定型
 */
export type SyncObject = AnyObject;
/**
 * @en Context type of {@link IDataSync.sync | IDataSync.sync}().
 * @ja {@link IDataSync.sync | IDataSync.sync}() に指定するコンテキストの型
 */
export type SyncContext<T extends object = SyncObject> = EventBroker<SyncEvent<T>> & {
    id?: string;
    toJSON(): T;
};
/**
 * @en {@link IDataSync.sync | IDataSync.sync}() options.
 * @ja {@link IDataSync.sync | IDataSync.sync}() に指定するオプション
 */
export interface IDataSyncOptions extends Cancelable {
    /**
     * @en Data to be sent to the server. {@link AjaxOptions} compatible. <br>
     *     If this property passed, the value is reflected as primary.
     *
     * @ja サーバーに送信されるデータ. {@link AjaxOptions} 互換 <br>
     *     指定された場合, このオプションが優先される.
     */
    data?: PlainObject;
}
/**
 * @en The interface for during a data source to synchronize with a context. <br>
 *     The function is equivalent to `Backbone.sync()`.
 * @ja コンテキストとデータソース間の同期をとるためのインターフェイス <br>
 *     `Backbone.sync()` 相当の機能を提供
 */
export interface IDataSync<T extends object = SyncObject> {
    /**
     * @en {@link IDataSync} kind signature.
     * @ja {@link IDataSync} の種別を表す識別子
     */
    readonly kind: string;
    /**
     * @en Do data synchronization.
     * @ja データ同期
     *
     * @param method
     *  - `en` operation string
     *  - `ja` オペレーションを指定
     * @param context
     *  - `en` synchronized context object
     *  - `ja` 同期するコンテキストオブジェクト
     * @param options
     *  - `en` option object
     *  - `ja` オプション
     */
    sync<K extends SyncMethods>(method: K, context: SyncContext<T>, options?: IDataSyncOptions): Promise<SyncResult<K, T>>;
}
export declare const dataSyncNULL: IDataSync<object>;
/**
 * @en Options interface for {@link RestDataSync}.
 * @ja {@link RestDataSync} に指定するオプション
 */
export interface RestDataSyncOptions extends AjaxOptions<'json'> {
    url?: string;
}
export declare const dataSyncREST: IDataSync<import('@cdp/lib-core').AnyObject>;
/**
 * @en {@link IDataSync} interface for {@link IStorage} accessor.
 * @ja {@link IStorage} アクセッサを備える {@link IDataSync} インターフェイス
 */
export interface IStorageDataSync<T extends object = SyncObject> extends IDataSync<T> {
    /**
     * @en Get current {@link IStorage} instance.
     * @ja 現在対象の {@link IStorage} インスタンスにアクセス
     */
    getStorage(): IStorage;
    /**
     * @en Set new {@link IStorage} instance.
     * @ja 新しい {@link IStorage} インスタンスを設定
     */
    setStorage(newStorage: IStorage): this;
    /**
     * @en Set new id-separator.
     * @ja 新しい ID セパレータを設定
     *
     * @param newSeparator
     *  - `en` new separator string
     *  - `ja` 新しいセパレータ文字列
     * @returns
     *  - `en` old separator string
     *  - `ja` 以前い設定されていたセパレータ文字列
     */
    setIdSeparator(newSeparator: string): string;
}
/**
 * @en {@link StorageDataSync} construction options.
 * @ja {@link StorageDataSync} 構築に指定するオプション
 */
export interface StorageDataSyncConstructionOptions {
    separator?: string;
}
/**
 * @en Options interface for {@link StorageDataSync}.
 * @ja {@link StorageDataSync} に指定するオプション
 */
export type StorageDataSyncOptions = IDataSyncOptions & IStorageOptions;
/**
 * @en Create {@link IStorageDataSync} object with {@link IStorage}.
 * @ja {@link IStorage} を指定して, {@link IStorageDataSync} オブジェクトを構築
 *
 * @param storage
 *  - `en` {@link IStorage} object
 *  - `ja` {@link IStorage} オブジェクト
 * @param options
 *  - `en` construction options
 *  - `ja` 構築オプション
 */
export declare const createStorageDataSync: (storage: IStorage, options?: StorageDataSyncConstructionOptions) => IStorageDataSync;
export declare const dataSyncSTORAGE: IStorageDataSync<import('@cdp/lib-core').AnyObject>;
/**
 * @en Get or update default {@link IDataSync} object.
 * @ja 既定の {@link IDataSync} オブジェクトの取得 / 更新
 *
 * @param newSync
 *  - `en` new data-sync object. if `undefined` passed, only returns the current object.
 *  - `ja` 新しい data-sync オブジェクトを指定. `undefined` が渡される場合は現在設定されている data-sync の返却のみ行う
 * @returns
 *  - `en` old data-sync object.
 *  - `ja` 以前の data-sync オブジェクトを返却
 */
export declare function defaultSync(newSync?: IDataSync): IDataSync;
/**
 * @en Valid attributes result.
 * @ja 属性検証の有効値
 */
export declare const RESULT_VALID_ATTRS: Readonly<Result>;
/**
 * @en Base class definition for model that provides a basic set of functionality for managing interaction.
 * @ja インタラクションのための基本機能を提供する Model の基底クラス定義
 *
 * @example <br>
 *
 * ```ts
 * import { Model, ModelConstructor } from '@cdp/runtime';
 *
 * interface ContentAttribute {
 *   uri: string;
 *   readonly size: number;
 *   cookie?: string;
 * }
 * ```
 *
 * - Basic Usage
 *
 * ```ts
 * // early cast
 * const ContentBase = Model as ModelConstructor<Model<ContentAttribute>, ContentAttribute>;
 *
 * class Content extends ContentBase {
 *   constructor(attrs: ContentAttribute) {
 *     super(attrs);
 *   }
 * }
 * ```
 *
 * or
 *
 * ```ts
 * // late cast
 * class ContentClass extends Model<ContentAttribute> {
 *   constructor(attrs: ContentAttribute) {
 *     super(attrs);
 *   }
 * }
 *
 * const Content = ContentClass as ModelConstructor<ContentClass, ContentAttribute>;
 * ```
 * then
 *
 * ```ts
 * const content = new Content({
 *   uri: 'aaa.txt',
 *   size: 10,
 *   cookie: undefined, // need explicit assign
 * });
 *
 * console.log(content.uri);    // 'aaa.txt'
 * console.log(content.size);   // '10'
 * console.log(content.cookie); // 'undefined'
 * ```
 *
 * - Using Custom TEvent
 *
 * ```ts
 * import { ModelEvent } from '@cdp/model';
 *
 * interface CustomEvent extends ModelEvent<ContentAttribute> {
 *   fire: [boolean, number];
 * }
 *
 * :
 *
 * // early cast
 * const ContentBase = Model as ModelConstructor<Model<ContentAttribute, CustomEvent>, ContentAttribute>;
 * class Content extends ContentBase {
 *   :
 * }
 *
 * // late cast
 * class ContentClass extends Model<ContentAttribute, CustomEvent> {
 *   :
 * }
 * const Content = ContentClass as ModelConstructor<ContentClass, ContentAttribute>;
 *
 * const content = new Content({ ... });
 * content.trigger('fire', true, 100);
 * ```
 */
export declare abstract class Model<T extends object = any, TEvent extends ModelEvent<T> = ModelEvent<T>> extends EventReceiver implements EventSource<TEvent> {
    /**
     * @en Get ID attribute name.
     * @ja ID アトリビュート名にアクセス
     *
     * @override
     */
    static idAttribute: string;
    /**
     * constructor
     *
     * @param attributes
     *  - `en` initial attribute values
     *  - `ja` 属性の初期値を指定
     */
    constructor(attributes: Required<T>, options?: ModelConstructionOptions);
    /**
     * @en Get content ID.
     * @ja コンテンツ ID を取得
     */
    get id(): string;
    /**
     * @en Attributes instance
     * @ja 属性を格納するインスタンス
     */
    protected get _attrs(): Accessible<ObservableObject>;
    /**
     * @en Default attributes instance
     * @ja 既定値属性を格納するインスタンス
     */
    protected get _baseAttrs(): T;
    /**
     * @en Previous attributes instance
     * @ja 変更前の属性を格納するインスタンス
     */
    protected get _prevAttrs(): Accessible<T>;
    /**
     * @en Changed attributes instance
     * @ja 変更のあった属性を格納するインスタンス
     */
    protected get _changedAttrs(): Partial<T>;
    /**
     * @en Get internal content ID.
     * @ja 内部のコンテンツ ID を取得
     */
    protected get _cid(): string;
    /**
     * @en Get creating options.
     * @ja 構築時のオプションを取得
     */
    protected get _options(): ModelSetOptions;
    /**
     * @en EventSource type resolver.
     * @ja EventSource 型解決用ヘルパーアクセッサ
     */
    get $(): EventSource<TEvent>;
    /**
     * @en Check whether this object has clients.
     * @ja クライアントが存在するか判定
     *
     * @param channel
     *  - `en` event channel key. (string | symbol)
     *  - `ja` イベントチャネルキー (string | symbol)
     * @param listener
     *  - `en` callback function of the `channel` corresponding.
     *  - `ja` `channel` に対応したコールバック関数
     */
    hasListener<Channel extends keyof TEvent>(channel?: Channel, listener?: (...args: Arguments<TEvent[Channel]>) => unknown): boolean;
    /**
     * @en Returns registered channel keys.
     * @ja 登録されているチャネルキーを返却
     */
    channels(): (keyof TEvent)[];
    /**
     * @en Notify event to clients.
     * @ja event 発行
     *
     * @param channel
     *  - `en` event channel key. (string | symbol)
     *  - `ja` イベントチャネルキー (string | symbol)
     * @param args
     *  - `en` arguments for callback function of the `channel` corresponding.
     *  - `ja` `channel` に対応したコールバック関数に渡す引数
     */
    trigger<Channel extends keyof TEvent>(channel: Channel, ...args: Arguments<Partial<TEvent[Channel]>>): void;
    /**
     * @en Unsubscribe event(s).
     * @ja イベント購読解除
     *
     * @param channel
     *  - `en` target event channel key. (string | symbol)
     *         When not set this parameter, everything is released.
     *  - `ja` 対象のイベントチャネルキー (string | symbol)
     *         指定しない場合はすべて解除
     * @param listener
     *  - `en` callback function of the `channel` corresponding.
     *         When not set this parameter, all same `channel` listeners are released.
     *  - `ja` `channel` に対応したコールバック関数
     *         指定しない場合は同一 `channel` すべてを解除
     */
    off<Channel extends keyof TEvent>(channel?: Channel | Channel[], listener?: (...args: Arguments<TEvent[Channel]>) => unknown): void;
    /**
     * @en Subscrive event(s).
     * @ja イベント購読設定
     *
     * @param channel
     *  - `en` target event channel key. (string | symbol)
     *  - `ja` 対象のイベントチャネルキー (string | symbol)
     * @param listener
     *  - `en` callback function of the `channel` corresponding.
     *  - `ja` `channel` に対応したコールバック関数
     */
    on<Channel extends keyof TEvent>(channel: Channel | Channel[], listener: (...args: Arguments<TEvent[Channel]>) => unknown): Subscription;
    /**
     * @en Subscrive event(s) but it causes the bound callback to only fire once before being removed.
     * @ja 一度だけハンドリング可能なイベント購読設定
     *
     * @param channel
     *  - `en` target event channel key. (string | symbol)
     *  - `ja` 対象のイベントチャネルキー (string | symbol)
     * @param listener
     *  - `en` callback function of the `channel` corresponding.
     *  - `ja` `channel` に対応したコールバック関数
     */
    once<Channel extends keyof TEvent>(channel: Channel | Channel[], listener: (...args: Arguments<TEvent[Channel]>) => unknown): Subscription;
    /**
     * @en Check valid or not.
     * @ja 検証の成否を取得
     */
    get isValid(): boolean;
    /**
     * @en Validate result accesser.
     * @ja 検証結果にアクセス
     */
    validate(options?: Silenceable): Result;
    /**
     * @en Validate data method.
     * @ja データ検証
     *
     * @override
     *
     * @param attributes
     *  - `en` validatee attributes
     *  - `ja` 被検証属性
     * @param options
     *  - `en` validate options
     *  - `ja` 検証オプション
     */
    protected validateAttributes<A extends T>(attributes: ModelAttributeInput<A>, options?: ModelValidateAttributeOptions): Result;
    /**
     * @en Check the {@link Model} has valid property. (not `null` or `undefined`)
     * @ja {@link Model} が有効なプロパティを持っているか確認 (`null` または `undefined` でない)
     */
    has(attribute: keyof T): boolean;
    /**
     * @en Get the HTML-escaped value of an attribute.
     * @ja HTML で使用する文字を制御文字に置換した属性値を取得
     */
    escape(attribute: keyof T): string;
    /**
     * @en Update attributes for batch input with options.
     * @ja 属性の一括設定
     *
     * @param attributes
     *  - `en` update attributes
     *  - `ja` 更新属性
     * @param options
     *  - `en` set attributes options
     *  - `ja` 属性更新用オプション
     */
    setAttributes<A extends T>(attributes: ModelAttributeInput<A>, options?: ModelSetOptions): this;
    /**
     * @en Clear all attributes on the {@link Model}. (set `undefined`)
     * @ja {@link Model} からすべての属性を削除 (`undefined` を設定)
     */
    clear(options?: ModelSetOptions): this;
    /**
     * @en Return a copy of the model's `attributes` object.
     * @ja Model 属性値のコピーを返却
     */
    toJSON(): T;
    /**
     * @es Clone this instance.
     * @ja インスタンスの複製を返却
     *
     * @override
     */
    clone(): this;
    /**
     * @en Check changed attributes.
     * @ja 変更された属性値を持つか判定
     *
     * @param attribute
     *  - `en` checked attribute
     *  - `ja` 検証する属性
     */
    hasChanged(attribute?: keyof T): boolean;
    /**
     * @en Return an object containing all the attributes that have changed, or `undefined` if there are no changed attributes.
     * @ja 入力した attributes 値の差分に対して変更がある属性値を返却. 差分がない場合は `undefiend` を返却
     *
     * @param attributes
     *  - `en` checked attributes
     *  - `ja` 検証する属性
     */
    changed(attributes?: Partial<T>): Partial<T> | undefined;
    /**
     * @en Get the previous value of an attribute, recorded at the time the last `@change` event was fired.
     * @ja `@change` が発火された前の属性値を取得
     */
    previous<K extends keyof T>(attribute: K): T[K];
    /**
     * @en Check a {@link Model} is new if it has never been saved to the server, and lacks an id.
     * @ja {@link Model} がまだサーバーに存在しないかチェック. 既定では `idAttribute` の有無で判定
     */
    protected isNew(): boolean;
    /**
     * @en Converts a response into the hash of attributes to be `set` on the model. The default implementation is just to pass the response along.
     * @ja レスポンスの変換メソッド. 既定では何もしない
     *
     * @override
     */
    protected parse(response: ModelSeed | void, options?: ModelSetOptions): T | void;
    /**
     * @en Proxy {@link IDataSync.sync | IDataSync.sync}() by default -- but override this if you need custom syncing semantics for *this* particular model.
     * @ja データ同期. 必要に応じてオーバーライド可能.
     *
     * @override
     *
     * @param method
     *  - `en` operation string
     *  - `ja` オペレーションを指定
     * @param context
     *  - `en` synchronized context object
     *  - `ja` 同期するコンテキストオブジェクト
     * @param options
     *  - `en` option object
     *  - `ja` オプション
     */
    protected sync<K extends ModelSyncMethods>(method: K, context: Model<T>, options?: ModelDataSyncOptions): Promise<ModelSyncResult<K, T>>;
    /**
     * @en Fetch the {@link Model} from the server, merging the response with the model's local attributes.
     * @ja {@link Model} 属性のサーバー同期. レスポンスのマージを実行
     */
    fetch(options?: ModelFetchOptions): Promise<T>;
    /**
     * @en Set a hash of {@link Model} attributes, and sync the model to the server. <br>
     *     If the server returns an attributes hash that differs, the model's state will be `set` again.
     * @ja {@link Model} 属性をサーバーに保存. <br>
     *     異なる属性が返却される場合は再設定
     *
     * @param key
     *  - `en` update attribute key
     *  - `ja` 更新属性キー
     * @param value
     *  - `en` update attribute value
     *  - `ja` 更新属性値
     * @param options
     *  - `en` save options
     *  - `ja` 保存オプション
     */
    save<K extends keyof T>(key?: keyof T, value?: T[K], options?: ModelSaveOptions): Promise<T | void>;
    /**
     * @en Set a hash of {@link Model} attributes, and sync the model to the server. <br>
     *     If the server returns an attributes hash that differs, the model's state will be `set` again.
     * @ja {@link Model} 属性をサーバーに保存. <br>
     *     異なる属性が返却される場合は再設定
     *
     * @param attributes
     *  - `en` update attributes
     *  - `ja` 更新属性
     * @param options
     *  - `en` save options
     *  - `ja` 保存オプション
     */
    save<A extends T>(attributes: ModelAttributeInput<A> | Nullish, options?: ModelSaveOptions): Promise<T | void>;
    /**
     * @en Destroy this {@link Model} on the server if it was already persisted.
     * @ja {@link Model} をサーバーから削除
     *
     * @param options
     *  - `en` destroy options
     *  - `ja` 破棄オプション
     */
    destroy(options?: ModelDestroyOptions): Promise<T | void>;
}
/**
 * @en Check the value-type is {@link Model}.
 * @ja {@link Model} 型であるか判定
 *
 * @param x
 *  - `en` evaluated value
 *  - `ja` 評価する値
 */
export declare function isModel(x: unknown): x is Model;
/**
 * @en Query {@link Model} `id-attribute`.
 * @ja {@link Model} の `id-attribute` を取得
 */
export declare function idAttribute(x: unknown, fallback?: string): string;
/**
 * @en Validable base interface.
 * @ja 検証可否の定義
 */
export interface Validable {
    validate?: boolean;
    noThrow?: boolean;
}
/**
 * @en Parseable base interface.
 * @ja パース可否の定義
 */
export interface Parseable {
    parse?: boolean;
}
/**
 * @en Waitable base interface.
 * @ja 遅延更新可否の定義
 */
export interface Waitable {
    wait?: boolean;
}
/**
 * @en Default {@link Model} seed type.
 * @ja 既定の {@link Model} シードデータ型
 */
export type ModelSeed = PlainObject;
/** helper for {@link ModelAttributeChangeEvent} */
export type ChangedAttributeEvent<T extends object> = `@change:${string & NonFunctionPropertyNames<T>}`;
/** helper for {@link ModelAttributeChangeEvent} */
export type MakeEventArg<T extends object, K> = K extends `@change:${infer A}` ? A extends keyof T ? [
    Model<T>,
    T[A],
    T[A],
    A
] : never : never;
/**
 * @en {@link Model} attribute change event definition.
 * @ja {@link Model} 属性変更イベント定義
 */
export type ModelAttributeChangeEvent<T extends object> = {
    [K in ChangedAttributeEvent<T>]: MakeEventArg<T, K>;
};
/**
 * @en Default {@link Model} event definition.
 * @ja 既定の {@link Model} イベント定義
 */
export type ModelEvent<T extends object> = EventAll & SyncEvent<T> & ModelAttributeChangeEvent<T> & {
    /**
     * @en when a model is added to a collection.
     * @ja Model が  Collection に追加されたときに発行
     *
     * @args [model, collection, options]
     */
    '@add': [
        Model<T>,
        unknown,
        Silenceable
    ];
    /**
     * @en when a model is removed from a collection.
     * @ja Model が Collection から削除されたときに発行
     *
     * @args [model, collection, options]
     */
    '@remove': [
        Model<T>,
        unknown,
        Silenceable
    ];
    /**
     * @en notified when some attribute changed.
     * @ja 属性が変更されたときに発行
     *
     * @args [model]
     */
    '@change': Model<T>;
    /**
     * @en notified when a model has been successfully synced with the server.
     * @ja サーバー同期に成功したときに発行
     *
     * @args [model, seed, options]
     */
    '@sync': [
        Model<T>,
        ModelSeed,
        ModelDataSyncOptions
    ];
    /**
     * @en notified when a model is destroyed.
     * @ja Model が破棄されたときに発行
     *
     * @args [model, options]
     */
    '@destroy': [
        Model<T>,
        ModelDestroyOptions
    ];
    /**
     * @en notified when some attribute failed.
     * @ja 属性が変更に失敗したときに発行
     *
     * @args [model, attributes, errorInfo]
     */
    '@invalid': [
        Model<T>,
        T,
        Result
    ];
    /**
     * @en notified when a model's request to the server has failed.
     * @ja サーバーリクエストに失敗したときに発行
     *
     * @args [model, errorInfo, options]
     */
    '@error': [
        Model<T>,
        Error,
        ModelDataSyncOptions
    ];
};
/**
 * @en {@link Model} attributes definition.
 * @ja {@link Model} が持つ属性の定義
 */
export type ModelAttributes<T extends object> = {
    [P in keyof T]: T[P];
};
/**
 * @en {@link Model} base constructor definition.
 * @ja {@link Model} の基底コンストラクタの定義
 */
export interface ModelConstructor<C extends object, T extends object> {
    idAttribute: string;
    new (...args: ConstructorParameters<Constructor<C>>): C & ModelAttributes<T>;
}
/**
 * @en {@link Model}'s `EventSource` definition from attributes.
 * @ja 属性から {@link Model} の `EventSource` 定義抽出
 */
export type ModelEventSource<T extends object> = Subscribable<ModelEvent<T>>;
/**
 * @en {@link Model} validate options.
 * @ja {@link Model} 検証オプション
 */
export interface ModelValidateAttributeOptions extends Silenceable {
    extend?: boolean;
}
/**
 * @en {@link Model} attributes argument type.
 * @ja {@link Model} 属性引数の型
 */
export type ModelAttributeInput<T> = Partial<T> & SyncObject;
/**
 * @en {@link Model} attributes setup options.
 * @ja {@link Model} 属性設定時に指定するオプション
 */
export interface ModelSetOptions extends Validable, ModelValidateAttributeOptions {
    syncMethod?: SyncMethods;
}
/**
 * @en {@link Model} construction options.
 * @ja {@link Model} 構築に指定するオプション
 */
export type ModelConstructionOptions = ModelSetOptions & Parseable;
/** re-exports */
export type ModelSyncMethods = SyncMethods;
export type ModelSyncResult<K extends SyncMethods, T extends object = ModelSeed> = SyncResult<K, T>;
export type ModelDataSyncOptions = RestDataSyncOptions;
/**
 * @en {@link Model} fetch options.
 * @ja {@link Model} fetch に指定するオプション
 */
export type ModelFetchOptions = ModelDataSyncOptions & Omit<ModelSetOptions, 'noThrow'> & Parseable;
/**
 * @en {@link Model} save options.
 * @ja {@link Model} save に指定するオプション
 */
export interface ModelSaveOptions extends ModelFetchOptions, Waitable {
    patch?: boolean;
}
/**
 * @en {@link Model} destroy options.
 * @ja {@link Model} destroy に指定するオプション
 */
export type ModelDestroyOptions = ModelDataSyncOptions & Waitable;
/**
 * @en Base class definition for collection that is ordered sets of models.
 * @ja Model の集合を扱う Collection の基底クラス定義.
 *
 * @example <br>
 *
 * ```ts
 * import {
 *     Model,
 *     ModelConstructor,
 *     Collection,
 *     CollectionItemQueryOptions,
 *     CollectionItemQueryResult,
 *     CollectionSeed,
 * } from '@cdp/runtime';
 *
 * // Model schema
 * interface TrackAttribute {
 *   uri: string;
 *   title: string;
 *   artist: string;
 *   album:  string;
 *   releaseDate: Date;
 *   :
 * }
 *
 * // Model definition
 * const TrackBase = Model as ModelConstructor<Model<TrackAttribute>, TrackAttribute>;
 * class Track extends TrackBase {
 *     static idAttribute = 'uri';
 * }
 *
 * // Collection definition
 * class Playlist extends Collection<Track> {
 *     // set target Model constructor
 *     static readonly model = Track;
 *
 *     // @override if need to use custom content provider for fetch.
 *     protected async sync(
 *         options?: CollectionItemQueryOptions<Track>
 *     ): Promise<CollectionItemQueryResult<object>> {
 *         // some specific implementation here.
 *         const items = await customProvider(options);
 *         return {
 *             total: items.length,
 *             items,
 *             options,
 *         } as CollectionItemQueryResult<object>;
 *     }
 *
 *     // @override if need to convert a response into a list of models.
 *     protected parse(response: CollectionSeed[]): TrackAttribute[] {
 *         return response.map(seed => {
 *             const date = seed.releaseDate;
 *             seed.releaseDate = new Date(date);
 *             return seed;
 *         }) as TrackAttribute[];
 *      }
 * }
 *
 * let seeds: TrackAttribute[];
 *
 * const playlist = new Playlist(seeds, {
 *     // default query options
 *     queryOptions: {
 *         sortKeys: [
 *             { name: 'title', order: SortOrder.DESC, type: 'string' },
 *         ],
 *     }
 * });
 *
 * await playlist.requery();
 *
 * for (const track of playlist) {
 *     console.log(JSON.stringify(track.toJSON()));
 * }
 * ```
 */
export declare abstract class Collection<TModel extends object = any, TEvent extends CollectionEvent<TModel> = CollectionEvent<TModel>, TKey extends Keys<TModel> = Keys<TModel>> extends EventSource<TEvent> implements Iterable<TModel> {
    /**
     * @en Model constructor. <br>
     *     The constructor is used internally by this {@link Collection} class for `TModel` construction.
     * @ja Model コンストラクタ <br>
     *     {@link Collection} クラスが `TModel` を構築するために使用する
     */
    static readonly model?: Class;
    /**
     * constructor
     *
     * @param seeds
     *  - `en` given the seed of model array.
     *  - `ja` Model 要素の配列を指定
     * @param options
     *  - `en` construction options.
     *  - `ja` 構築オプション
     */
    constructor(seeds?: TModel[] | CollectionSeed[], options?: CollectionConstructionOptions<TModel, TKey>);
    /**
     * @ja Initialize query info
     * @ja クエリ情報の初期化
     */
    protected initQueryInfo(): void;
    /**
     * @en Released all instances and event listener under the management.
     * @ja 管理対象を破棄
     *
     * @param options
     *  - `en` options (reserved).
     *  - `ja` オプション (予約)
     */
    release(options?: CollectionOperationOptions): this;
    /**
     * @ja Clear cache instance method
     * @ja キャッシュの破棄
     */
    protected clearCache(): void;
    /**
     * @en Get content ID.
     * @ja コンテント ID を取得
     */
    get id(): string;
    /**
     * @en Get models.
     * @ja Model アクセス
     */
    get models(): readonly TModel[];
    /**
     * @en number of models.
     * @ja 内包する Model 数
     */
    get length(): number;
    /**
     * @en Check applied after-filter.
     * @ja 絞り込み用フィルタが適用されているかを判定
     */
    get filtered(): boolean;
    /**
     * @en {@link CollectionQueryInfo} instance
     * @ja {@link CollectionQueryInfo} を格納するインスタンス
     */
    protected get _queryInfo(): CollectionQueryInfo<TModel, TKey>;
    /**
     * @en {@link CollectionQueryInfo} instance
     * @ja {@link CollectionQueryInfo} を格納するインスタンス
     */
    protected set _queryInfo(val: CollectionQueryInfo<TModel, TKey>);
    /**
     * @en Get creating options.
     * @ja 構築時のオプションを取得
     */
    protected get _options(): CollectionConstructionOptions<TModel, TKey>;
    /**
     * @en Get default provider.
     * @ja 既定のプロバイダを取得
     */
    protected get _provider(): CollectionItemProvider<TModel, TKey>;
    /**
     * @en Get default parse behaviour.
     * @ja 既定の parse 動作を取得
     */
    protected get _defaultParse(): boolean | undefined;
    /**
     * @en Get default query options.
     * @ja 既定のクエリオプションを取得
     */
    protected get _defaultQueryOptions(): CollectionItemQueryOptions<TModel, TKey>;
    /**
     * @en Get last query options.
     * @ja 最後のクエリオプションを取得
     */
    protected get _lastQueryOptions(): CollectionItemQueryOptions<TModel, TKey>;
    /**
     * @en Access to sort comparators.
     * @ja ソート用比較関数へのアクセス
     */
    protected get _comparators(): SortCallback<TModel>[];
    /**
     * @en Access to query-filter.
     * @ja クエリ用フィルタ関数へのアクセス
     */
    protected get _queryFilter(): FilterCallback<TModel> | undefined;
    /**
     * @en Access to after-filter.
     * @ja 絞り込み用フィルタ関数へのアクセス
     */
    protected get _afterFilter(): FilterCallback<TModel> | undefined;
    /**
     * @en Get a model from a collection, specified by an `id`, a `cid`, or by passing in a model instance.
     * @ja `id`, `cid` およびインスタンスから Model を特定
     *
     * @param seed
     *  - `en` `id`, a `cid`, or by passing in a model instance
     *  - `ja`  `id`, `cid` およびインスタンス
     */
    get(seed: string | object | undefined): TModel | undefined;
    /**
     * @en Returns `true` if the model is in the collection by an `id`, a `cid`, or by passing in a model instance.
     * @ja `id`, `cid` およびインスタンスから Model を所有しているか判定
     *
     * @param seed
     *  - `en` `id`, a `cid`, or by passing in a model instance
     *  - `ja`  `id`, `cid` およびインスタンス
     */
    has(seed: string | object | undefined): boolean;
    /**
     * @en Return a copy of the model's `attributes` object.
     * @ja Model 属性値のコピーを返却
     */
    toJSON(): object[];
    /**
     * @es Clone this instance.
     * @ja インスタンスの複製を返却
     *
     * @override
     */
    clone(): this;
    /**
     * @en Force a collection to re-sort itself.
     * @ja Collection 要素の再ソート
     *
     * @param options
     *  - `en` sort options.
     *  - `ja` ソートオプション
     */
    sort(options?: CollectionReSortOptions<TModel, TKey>): this;
    /**
     * @en Apply after-filter to collection itself.
     * @ja 絞り込み用フィルタの適用
     *
     * @param callback
     *  - `en` filter callback.
     *  - `ja` フィルタコールバック関数
     * @param options
     *  - `en` Silenceable options.
     *  - `ja` Silenceable オプション
     */
    filter(callback: FilterCallback<TModel> | undefined, options?: Silenceable): this;
    /**
     * @en Apply after-filter to collection itself.
     * @ja 絞り込み用フィルタの適用
     *
     * @param options
     *  - `en` after-filter options.
     *  - `ja` 絞り込みオプション
     */
    filter(options: CollectionAfterFilterOptions<TModel>): this;
    /**
     * @en Get the model at the given index. If negative value is given, the target will be found from the last index.
     * @ja インデックス指定による Model へのアクセス. 負値の場合は末尾検索を実行
     *
     * @param index
     *  - `en` A zero-based integer indicating which element to retrieve. <br>
     *         If negative index is counted from the end of the matched set.
     *  - `ja` 0 base のインデックスを指定 <br>
     *         負値が指定された場合, 末尾からのインデックスとして解釈される
     */
    at(index: number): TModel;
    /**
     * @en Get the first element of the model.
     * @ja Model の最初の要素を取得
     */
    first(): TModel | undefined;
    /**
     * @en Get the value of `count` elements of the model from the first.
     * @ja Model の先頭から`count` 分の要素を取得
     */
    first(count: number): TModel[];
    /**
     * @en Get the last element of the model.
     * @ja Model の最初の要素を取得
     */
    last(): TModel | undefined;
    /**
     * @en Get the value of `count` elements of the model from the last.
     * @ja Model の先頭から`count` 分の要素を取得
     */
    last(count: number): TModel[];
    /**
     * @en Converts a response into the hash of attributes to be `set` on the collection. The default implementation is just to pass the response along.
     * @ja レスポンスの変換メソッド. 既定では何もしない
     *
     * @override
     */
    protected parse(response: CollectionSeed | CollectionSeed[] | void, options?: CollectionSetOptions): TModel[] | CollectionSeed[] | undefined;
    /**
     * @en The {@link Collection.fetch} method proxy that is compatible with {@link CollectionItemProvider} returns one-shot result.
     * @ja {@link CollectionItemProvider} 互換の単発の {@link Collection.fetch} 結果を返却. 必要に応じてオーバーライド可能.
     *
     * @override
     *
     * @param options
     *  - `en` option object
     *  - `ja` オプション
     */
    protected sync(options?: CollectionItemQueryOptions<TModel, TKey>): Promise<CollectionItemQueryResult<object>>;
    /**
     * @en Fetch the {@link Model} from the server, merging the response with the model's local attributes.
     * @ja {@link Model} 属性のサーバー同期. レスポンスのマージを実行
     *
     * @param options
     *  - `en` fetch options.
     *  - `ja` フェッチオプション
     */
    fetch(options?: CollectionQueryOptions<TModel, TKey>): Promise<object[]>;
    /**
     * @en Execute `fetch()` with last query options.
     * @ja 前回と同条件で `fetch()` を実行
     *
     * @param options
     *  - `en` requery options.
     *  - `ja` リクエリオプション
     */
    requery(options?: CollectionRequeryOptions): Promise<object[]>;
    /**
     * @en 'Smart' update method of the collection with the passed list of models.
     *       - if the model is already in the collection its attributes will be merged.
     *       - if the collection contains any models that aren't present in the list, they'll be removed.
     *       - All of the appropriate `@add`, `@remove`, and `@update` events are fired as this happens.
     * @ja Collection の汎用更新処理
     *       - 追加時にすでに Model が存在するときは、属性をマージ
     *       - 指定リストに存在しない Model は削除
     *       - 適切な `@add`, `@remove`, `@update` イベントを発生
     *
     * @param seed
     *  - `en` Nullish value.
     *  - `ja` Nullish 要素
     * @param options
     *  - `en` set options.
     *  - `ja` 設定オプション
     */
    set(seed: undefined, options?: CollectionSetOptions): void;
    /**
     * @en 'Smart' update method of the collection with the passed list of models.
     *       - if the model is already in the collection its attributes will be merged.
     *       - if the collection contains any models that aren't present in the list, they'll be removed.
     *       - All of the appropriate `@add`, `@remove`, and `@update` events are fired as this happens.
     * @ja Collection の汎用更新処理
     *       - 追加時にすでに Model が存在するときは、属性をマージ
     *       - 指定リストに存在しない Model は削除
     *       - 適切な `@add`, `@remove`, `@update` イベントを発生
     *
     * @param seed
     *  - `en` given the seed of model.
     *  - `ja` Model 要素を指定
     * @param options
     *  - `en` set options.
     *  - `ja` 設定オプション
     */
    set(seed: TModel | UnknownObject, options?: CollectionSetOptions): TModel;
    /**
     * @en 'Smart' update method of the collection with the passed list of models.
     *       - if the model is already in the collection its attributes will be merged.
     *       - if the collection contains any models that aren't present in the list, they'll be removed.
     *       - All of the appropriate `@add`, `@remove`, and `@update` events are fired as this happens.
     * @ja Collection の汎用更新処理
     *       - 追加時にすでに Model が存在するときは、属性をマージ
     *       - 指定リストに存在しない Model は削除
     *       - 適切な `@add`, `@remove`, `@update` イベントを発生
     *
     * @param seeds
     *  - `en` given the seed of model array.
     *  - `ja` Model 要素の配列を指定
     * @param options
     *  - `en` set options.
     *  - `ja` 設定オプション
     */
    set(seeds: (TModel | CollectionSeed)[], options?: CollectionSetOptions): TModel[];
    /**
     * @en Replace a collection with a new list of models (or attribute hashes), triggering a single `reset` event on completion.
     * @ja Collection を新しい Model 一覧で置換. 完了時に `reset` イベントを発行
     *
     * @param seeds
     *  - `en` given the seed of model array.
     *  - `ja` Model 要素の配列を指定
     * @param options
     *  - `en` reset options.
     *  - `ja` リセットオプション
     */
    reset(seeds?: (TModel | CollectionSeed)[], options?: CollectionOperationOptions): TModel[];
    /**
     * @en Add model to the collection.
     * @ja Collection への Model の追加
     *
     * @param seed
     *  - `en` given the seed of model.
     *  - `ja` Model 要素を指定
     * @param options
     *  - `en` add options.
     *  - `ja` 追加オプション
     */
    add(seed: TModel | UnknownObject, options?: CollectionAddOptions): TModel;
    /**
     * @en Add to the collection with the passed list of models.
     * @ja Model リスト指定による Collection への追加
     *
     * @param seeds
     *  - `en` given the seed of model array.
     *  - `ja` Model 要素の配列を指定
     * @param options
     *  - `en` add options.
     *  - `ja` 追加オプション
     */
    add(seeds: (TModel | CollectionSeed)[], options?: CollectionAddOptions): TModel[];
    /**
     * @en Remove a model from the set.
     * @ja Collection から Model を削除
     *
     * @param seed
     *  - `en` given the seed of model.
     *  - `ja` Model 要素を指定
     * @param options
     *  - `en` remove options.
     *  - `ja` 削除オプション
     */
    remove(seed: TModel | UnknownObject, options?: CollectionOperationOptions): TModel;
    /**
     * @en Remove a list of models from the set.
     * @ja Model リスト指定による Collection からの削除
     *
     * @param seeds
     *  - `en` given the seed of model array.
     *  - `ja` Model 要素の配列を指定
     * @param options
     *  - `en` remove options.
     *  - `ja` 削除オプション
     */
    remove(seeds: (TModel | CollectionSeed)[], options?: CollectionOperationOptions): TModel[];
    /**
     * @en Add a model to the end of the collection.
     * @ja 末尾に Model を追加
     *
     * @param seed
     *  - `en` given the seed of model.
     *  - `ja` Model 要素を指定
     * @param options
     *  - `en` add options.
     *  - `ja` 追加オプション
     */
    push(seed: TModel | CollectionSeed, options?: CollectionAddOptions): TModel;
    /**
     * @en Remove a model from the end of the collection.
     * @ja 末尾の Model を削除
     *
     * @param options
     *  - `en` Silenceable options.
     *  - `ja` Silenceable オプション
     */
    pop(options?: Silenceable): TModel | undefined;
    /**
     * @en Add a model to the beginning of the collection.
     * @ja 先頭に Model を追加
     *
     * @param seed
     *  - `en` given the seed of model.
     *  - `ja` Model 要素を指定
     * @param options
     *  - `en` add options.
     *  - `ja` 追加オプション
     */
    unshift(seed: TModel | CollectionSeed, options?: CollectionAddOptions): TModel;
    /**
     * @en Remove a model from the beginning of the collection.
     * @ja 先頭の Model を削除
     *
     * @param options
     *  - `en` Silenceable options.
     *  - `ja` Silenceable オプション
     */
    shift(options?: Silenceable): TModel | undefined;
    /**
     * @en Create a new instance of a model in this collection.
     * @ja 新しい Model インスタンスを作成し, Collection に追加
     *
     * @param attrs
     *  - `en` attributes object.
     *  - `ja` 属性オブジェクトを指定
     * @param options
     *  - `en` model construction options.
     *  - `ja` Model 構築オプション
     */
    create(attrs: object, options?: ModelSaveOptions): TModel | undefined;
    /**
     * @en Iterator of {@link ElementBase} values in the array.
     * @ja 格納している {@link ElementBase} にアクセス可能なイテレータオブジェクトを返却
     */
    [Symbol.iterator](): Iterator<TModel>;
    /**
     * @en Returns an iterable of key(id), value(model) pairs for every entry in the array.
     * @ja key(id), value(model) 配列にアクセス可能なイテレータオブジェクトを返却
     */
    entries(): IterableIterator<[
        string,
        TModel
    ]>;
    /**
     * @en Returns an iterable of keys(id) in the array.
     * @ja key(id) 配列にアクセス可能なイテレータオブジェクトを返却
     */
    keys(): IterableIterator<string>;
    /**
     * @en Returns an iterable of values({@link ElementBase}) in the array.
     * @ja values({@link ElementBase}) 配列にアクセス可能なイテレータオブジェクトを返却
     */
    values(): IterableIterator<TModel>;
}
/**
 * @en Sort order const definitions.
 * @ja ソート順
 */
export declare const enum SortOrder {
    /** `en` no sort <br> `ja` ソートしない */
    NO = 0,
    /** `en` ascending <br> `ja` 昇順 */
    ASC = 1,
    /** `en` descending <br> `ja` 降順 */
    DESC = -1
}
/**
 * @en Callback type for using `sort()` function.
 * @ja `sort()` に指定されるコールバック関数
 */
export type SortCallback<T> = (lhs: T, rhs: T) => number;
/**
 * @en Callback type for using `filter()` function.
 * @ja `filter()` に指定されるコールバック関数
 */
export type FilterCallback<T> = (target: T) => boolean;
/**
 * @en Sort key type definition.
 * @ja ソートキーの型定義
 */
export type SortKeyType = 'string' | 'number' | 'date' | 'boolean';
/**
 * @en Generic sort key interface definition.
 * @ja 汎用のソートキー定義
 */
export interface SortKey<TKey extends string> {
    /**
     * @en Key name.
     * @ja Key 名
     */
    name: TKey;
    /**
     * @en Sort order. (NO / ASC / DESC)
     * @ja 昇順 / 降順
     */
    order: SortOrder;
    /**
     * @en Type of sort target property.
     * @ja ソート対象プロパティの型
     */
    type: SortKeyType;
}
/**
 * @en Dynamic query operator definitions.
 * @ja ダイナミッククエリの演算子定義
 */
export declare const enum DynamicOperator {
    /**
     * @en is equal
     * @ja である
     */
    EQUAL = 0,
    /**
     * @en is not equal
     * @ja でない
     */
    NOT_EQUAL = 1,
    /**
     * @en is greater than
     * @ja より大きい/より長い
     */
    GREATER = 2,
    /**
     * @en is less than
     * @ja より小さい/より短い
     */
    LESS = 3,
    /**
     * @en is greater equal
     * @ja 以上
     */
    GREATER_EQUAL = 4,
    /**
     * @en is less equal
     * @ja 以下
     */
    LESS_EQUAL = 5,
    /**
     * @en is like (included)
     * @ja 含む
     */
    LIKE = 6,
    /**
     * @en is not like (not included)
     * @ja 含まない
     */
    NOT_LIKE = 7,
    /**
     * @en the past within ***. If the day is after the past basis date that calculated from `Date.now()`, it's hit condition.
     * @ja 過去 *** 以内. `Date.now()` を起点として n年過去の年月日を求め, それ以降の日付ならヒット対象
     */
    DATE_LESS_EQUAL = 8,
    /**
     * @en not the past within ***. If the day is before the past basis date that calculated from `Date.now()`, it's hit condition.
     * @ja 過去 *** 以内でない: `Date.now()` を起点として n年過去の年月日を求め, それより前の日付ならヒット対象
     */
    DATE_LESS_NOT_EQUAL = 9,
    /**
     * @en between more than *** to within ***
     * @ja *** 以上 ～ *** 以内
     */
    RANGE = 10
}
/**
 * @en Combination condtion definitions for dynamic query.
 * @ja ダイナミッククエリの複合条件
 */
export declare const enum DynamicCombination {
    /** `en` logical AND <br> `ja` かつ */
    AND = 0,
    /** `en` logical OR <br> `ja` または */
    OR = 1
}
/**
 * @en Dynamic query limit definitions.
 * @ja ダイナミッククエリの上限
 */
export declare const enum DynamicLimit {
    /** `en` item count <br> `ja` アイテム数 */
    COUNT = 0,
    /** `en` prop value sum <br> `ja` プロパティ値の合計値 */
    SUM = 1,
    /** `en` second <br> `ja` 秒 */
    SECOND = 2,
    /** `en` minute <br> `ja` 分 */
    MINUTE = 3,
    /** `en` hour <br> `ja` 時間 */
    HOUR = 4,
    /** `en` day <br> `ja` 日 */
    DAY = 5,
    /** flle size kB */
    KB = 6,
    /** flle size MB */
    MB = 7,
    /** flle size GB */
    GB = 8,
    /** flle size TB */
    TB = 9
}
/**
 * @en Property definitions of dynamic query context.
 * @ja ダイナミッククエリの条件コンテキスト
 */
export interface DynamicOperatorContext<T extends object> {
    operator: DynamicOperator;
    prop: Keys<T>;
    value: T[Keys<T>] | number;
    range?: T[Keys<T>];
    unit?: 'year' | 'month' | 'day';
}
/**
 * @en Limit condition definitions for dynamic query.
 * @ja ダイナミッククエリの上限設定
 */
export interface DynamicLimitCondition<T extends object> {
    unit: DynamicLimit;
    /** when DynamicLimit.COUNT, set `undefined`. */
    prop: Keys<T> | undefined;
    value: number;
    /** loose limit */
    excess?: boolean;
}
/**
 * @en Dynamic query condition seed interface.
 * @ja ダイナミッククエリの条件
 */
export interface DynamicConditionSeed<TItem extends object, TKey extends Keys<TItem> = Keys<TItem>> {
    /**
     * @en filter condition
     * @ja フィルタ条件
     */
    operators: DynamicOperatorContext<TItem>[];
    /**
     * @en combination condition
     * @ja 複合条件
     */
    combination?: DynamicCombination;
    /**
     * @en keys of using SUM
     * @ja SUM に使用する Key
     */
    sumKeys?: Keys<TItem>[];
    /**
     * @en limitation
     * @ja 上限
     */
    limit?: DynamicLimitCondition<TItem>;
    /**
     * @en random or not
     * @ja ランダム検索
     */
    random?: boolean;
    /**
     * @en Sort key properties. <br>
     *     An end of element is given priority to.
     * @ja ソートキー指定 <br>
     *     配列の末尾ほど優先される
     *
     * @example <br>
     *  valid value: keys[0], keys[1], keys[2]
     *      first sort key : keys[2]
     *      second sort key: keys[1]
     *      third sort key : keys[0]
     */
    sortKeys?: SortKey<TKey>[];
}
/**
 * @en {@link Collection} sort options.
 * @ja {@link Collection} の sort に使用するオプション
 */
export interface CollectionSortOptions<TItem extends object, TKey extends Keys<TItem> = Keys<TItem>> {
    /**
     * @en Sort key properties. <br>
     *     An end of element is given priority to.
     * @ja ソートキー指定 <br>
     *     配列の末尾ほど優先される
     *
     * @example <br>
     *  valid value: keys[0], keys[1], keys[2]
     *      first sort key : keys[2]
     *      second sort key: keys[1]
     *      third sort key : keys[0]
     */
    sortKeys?: SortKey<TKey>[];
    /**
     * @en Sort comparator functions <br>
     *     When sorting more in control, it's designated. <br>
     *     When this property given, {@link CollectionSortOptions.sortKeys} is ignored.
     * @ja 比較関数指定 <br>
     *     より自由度の高いソートを行うときに指定 <br>
     *     このプロパティが指定されるとき, {@link CollectionSortOptions.sortKeys} は無視される
     */
    comparators?: SortCallback<TItem>[];
}
/**
 * @en {@link Collection} filter options.
 * @ja {@link Collection} の filter に使用するオプション
 */
export interface CollectionFilterOptions<TItem extends object> {
    /**
     * @en filter function.
     * @ja フィルタ関数を指定
     */
    filter?: FilterCallback<TItem>;
}
/**
 * @en Base option interface for {@link Collection.fetch | Collection.fetch}().
 * @ja {@link Collection.fetch | Collection.fetch}() に使用する基底オプション
 */
export interface CollectionFetchOptions<TItem extends object> extends Cancelable {
    /**
     * @en Query start index. default: 0
     * @ja 取得開始 Index を指定 default: 0
     */
    index?: number;
    /**
     * @en The limit number of acquisition items per one query.
     * @ja 1回の query で制限する 取得コンテンツ数
     */
    limit?: number;
    /**
     * @en If given `true`, the system calls `fetch()` continuously until all items. default: false
     * @ja 自動全取得する場合は true default: false
     */
    auto?: boolean;
    /**
     * @en Progress callback function.
     * @ja 進捗コールバック
     */
    progress?: CollectionFetchProgress<TItem>;
}
/**
 * @en Argument value type for {@link CollectionFetchProgress}.
 * @ja {@link CollectionFetchProgress} に渡される引数
 */
export type CollectionItemQueryResult<TItem extends object, TSumKey extends Keys<TItem> = never> = {
    total: number;
    items: TItem[];
    options?: CollectionItemQueryOptions<TItem>;
} & Pick<TItem, TSumKey>;
/**
 * @en Progress callback function type by using {@link CollectionFetchOptions.auto | CollectionFetchOptions.auto}. <br>
 *     最終進捗 の items は `Promise.resolve`() に渡るものと同等
 * @ja {@link CollectionFetchOptions.auto | CollectionFetchOptions.auto} が指定された場合に使用する進捗取得用コールバック関数 <br>
 *     最終進捗 の items は `Promise.resolve`() に渡るものと同等
 */
export type CollectionFetchProgress<TItem extends object> = (progress: CollectionItemQueryResult<TItem>) => void;
/**
 * @en Standard query options for `queryItems()`.
 * @ja `queryItems()` の標準のクエリオプション
 */
export interface CollectionItemQueryOptions<TItem extends object, TKey extends Keys<TItem> = Keys<TItem>> extends CollectionSortOptions<TItem, TKey>, CollectionFilterOptions<TItem>, CollectionFetchOptions<TItem> {
    /**
     * @en Dynamic query condition.
     * @ja ダイナミッククエリの条件
     */
    condition?: DynamicConditionSeed<TItem, TKey>;
    /**
     * @en If given `true`, {@link Collection.fetch | Collection.fetch}() doesn't use sorting and filtering from {@link CollectionQueryInfo} cached.
     * @ja {@link CollectionQueryInfo} にキャッシュされたソート/フィルターが不要な時に指定
     */
    noSearch?: boolean;
    /**
     * @en If given `true`, {@link Collection.fetch | Collection.fetch}() doesn't cache result.
     * @ja 明示的に cache しない場合に true
     */
    noCache?: boolean;
}
/**
 * @en Query information interface.
 * @ja クエリ情報を格納するインターフェイス
 */
export interface CollectionQueryInfo<TItem extends object, TKey extends Keys<TItem> = Keys<TItem>> {
    sortKeys: SortKey<TKey>[];
    comparators: SortCallback<TItem>[];
    filter?: FilterCallback<TItem>;
    cache?: CollectionItemQueryResult<TItem>;
}
/**
 * @en {@link Collection} items provider function type.
 * @ja {@link Collection} の Item を供給する関数の型
 */
export type CollectionItemProvider<TItem extends object, TKey extends Keys<TItem> = Keys<TItem>> = (options?: CollectionItemQueryOptions<TItem, TKey>) => Promise<CollectionItemQueryResult<TItem>>;
/**
 * @en {@link Collection} construction options.
 * @ja {@link Collection} 構築に指定するオプション
 */
export interface CollectionConstructionOptions<T extends object, K extends Keys<T> = Keys<T>> extends Silenceable {
    /** custom model provider */
    provider?: CollectionItemProvider<T, K>;
    /** default parse behaviour */
    parse?: boolean;
    /** default model construction options */
    modelOptions?: ModelConstructionOptions;
    /** default query options */
    queryOptions?: CollectionItemQueryOptions<T>;
}
/**
 * @en Base options for collection operation.
 * @ja Collection 操作の基底オプション定義
 */
export type CollectionOperationOptions = Silenceable & Parseable;
/**
 * @en Add item to {@link Collection} options.
 * @ja {@link Collection} への追加オプション
 */
export interface CollectionAddOptions extends CollectionOperationOptions {
    at?: number;
    merge?: boolean;
    sort?: boolean;
}
/**
 * @en {@link Collection} setup options.
 * @ja {@link Collection} 設定オプション
 */
export interface CollectionSetOptions extends CollectionAddOptions {
    add?: boolean;
    remove?: boolean;
    merge?: boolean;
}
/**
 * @en {@link Collection} re-sort options.
 * @ja {@link Collection} 再ソートオプション
 */
export type CollectionReSortOptions<TItem extends object, TKey extends Keys<TItem> = Keys<TItem>> = Validable & CollectionSortOptions<TItem, TKey> & CollectionOperationOptions;
/**
 * @en {@link Collection} after-filter options.
 * @ja {@link Collection} 絞り込みフィルタオプション
 */
export type CollectionAfterFilterOptions<TItem extends object> = CollectionFilterOptions<TItem> & Silenceable;
/**
 * @en {@link Collection} update options.
 * @ja {@link Collection} 更新時のオプション
 */
export type CollectionUpdateOptions<TItem extends object> = ModelSaveOptions & CollectionSetOptions & {
    index?: number;
    changes: {
        added: TItem[];
        removed: TItem[];
        merged: TItem[];
    };
};
/** re-exports */
export type CollectionDataSyncOptions = RestDataSyncOptions;
/**
 * @en {@link Collection.fetch | Collection.fetch}() options.
 * @ja {@link Collection.fetch | Collection.fetch}() のオプション
 */
export interface CollectionQueryOptions<TItem extends object, TKey extends Keys<TItem> = Keys<TItem>> extends CollectionItemQueryOptions<TItem, TKey>, CollectionSetOptions {
    /**
     * @en If given `true`, {@link Collection.fetch | Collection.fetch}() calls {@link Collection.reset | Collection.reset}() instead of {@link Collection.add | Collection.add}().
     * @ja {@link Collection.fetch | Collection.fetch}() 内で明示的に {@link Collection.reset | Collection.reset}() メソッドを呼ぶ場合に true
     */
    reset?: boolean;
    /**
     * @en If given `true`, {@link Collection.fetch | Collection.fetch}() calls {@link Collection.sort | Collection.sort}().
     * @ja {@link Collection.fetch | Collection.fetch}() 内で {@link Collection.sort | Collection.sort} を実行する場合 true
     */
    sort?: boolean;
}
/**
 * @en {@link Collection.requery | Collection.requery}() options.
 * @ja {@link Collection.requery | Collection.requery}() のオプション
 */
export type CollectionRequeryOptions = Silenceable & Cancelable;
/**
 * @en Model attribute change event definition.
 * @ja Model 属性変更イベント定義
 */
export type CollectionModelAttributeChangeEvent<T extends object> = {
    [K in ChangedAttributeEvent<T>]: K extends `@change:${string}` ? [
        T,
        Collection<T>,
        CollectionOperationOptions
    ] : never;
};
/**
 * @en Default {@link Collection} seed type.
 * @ja 既定の {@link Collection} シードデータ型
 */
export type CollectionSeed = AnyObject;
/**
 * @en Default {@link Collection} event definition.
 * @ja 既定の {@link Collection} イベント定義
 */
export type CollectionEvent<TItem extends object> = EventAll & SyncEvent<Collection<TItem>> & CollectionModelAttributeChangeEvent<TItem> & {
    /**
     * @en when a model is added to a collection.
     * @ja Model が Collection に追加されたときに発行
     *
     * @args [model, collection, options]
     */
    '@add': [
        TItem,
        Collection<TItem>,
        CollectionSetOptions
    ];
    /**
     * @en when a model is removed from a collection.
     * @ja Model が Collection から削除されたときに発行
     *
     * @args [model, collection, options]
     */
    '@remove': [
        TItem,
        Collection<TItem>,
        CollectionSetOptions
    ];
    /**
     * @en notified when some attribute changed.
     * @ja 属性が変更されたときに発行
     *
     * @args [model, collection, options]
     */
    '@change': [
        TItem,
        Collection<TItem>,
        CollectionOperationOptions
    ];
    /**
     * @en single event triggered after any number of models have been added, removed or changed in a collection.
     * @ja Collection 内の Model の追加・削除・変化時に1回発行
     *
     * @args [collection, options]
     */
    '@update': [
        Collection<TItem>,
        CollectionUpdateOptions<TItem>
    ];
    /**
     * @en when the collection's entire contents have been reset.
     * @ja Collection が置き換えられたときに発行
     *
     * @args [collection, options]
     */
    '@reset': [
        Collection<TItem>,
        CollectionSetOptions & {
            previous: TItem[];
        }
    ];
    /**
     * @en when the collection has been re-sorted.
     * @ja Collection が再ソートされたときに発行
     *
     * @args [collection, options]
     */
    '@sort': [
        Collection<TItem>,
        CollectionReSortOptions<TItem>
    ];
    /**
     * @en when the collection has been re-sorted.
     * @ja Collection が再ソートされたときに発行
     *
     * @args [collection, options]
     */
    '@filter': [
        Collection<TItem>,
        CollectionAfterFilterOptions<TItem>
    ];
    /**
     * @en notified when a collection has been successfully synced with the server.
     * @ja サーバー同期に成功したときに発行
     *
     * @args [collection, seeds, options]
     */
    '@sync': [
        Collection<TItem>,
        CollectionSeed[],
        CollectionDataSyncOptions
    ];
    /**
     * @en notified when a model is destroyed.
     * @ja Model が破棄されたときに発行
     *
     * @args [model, collection, options]
     */
    '@destroy': [
        TItem,
        Collection<TItem>,
        ModelDestroyOptions
    ];
    /**
     * @en notified when setup model failed.
     * @ja Model 設定に失敗したときに発行
     *
     * @args [model, collection, errorInfo, options]
     */
    '@invalid': [
        TItem,
        Collection<TItem>,
        Result,
        CollectionOperationOptions
    ];
    /**
     * @en notified when a collection's request to the server has failed.
     * @ja サーバーリクエストに失敗したときに発行
     *
     * @args [model, collection, errorInfo, options]
     */
    '@error': [
        TItem | undefined,
        Collection<TItem>,
        Error,
        CollectionDataSyncOptions
    ];
};
/**
 * @en Base options for editing list operation.
 * @ja 編集可能リスト用基底オプション
 */
export type ListEditOptions = Silenceable & Cancelable;
/**
 * @en Editable list changed information.
 * @ja 編集可能リスト用変更情報
 */
export interface ListChanged<T> {
    /**
     * @en change type
     * @ja 変更タイプ
     */
    readonly type: 'add' | 'remove' | 'reorder';
    /**
     * @en change range of index
     * @ja 変更が発生した要素の範囲 index
     */
    readonly range?: {
        from: number;
        to: number;
    };
    /**
     * @en changed index detail
     * @ja 変更情報 index
     */
    readonly list: ArrayChangeRecord<T>[];
    /**
     * @en inserted-to information (not available when element was removed)
     * @ja 追加先 (削除時には 取得不可)
     */
    readonly insertedTo?: number;
}
/**
 * @en `Intl.Collator` factory function type definition.
 * @ja `Intl.Collator` を返却する関数型定義
 */
export type CollatorProvider = () => Intl.Collator;
/**
 * @ja 既定の Intl.Collator を設定
 *
 * @param newProvider
 *  - `en` new {@link CollatorProvider} object. if `undefined` passed, only returns the current object.
 *  - `ja` 新しい {@link CollatorProvider} オブジェクトを指定. `undefined` が渡される場合は現在設定されているオブジェクトの返却のみ行う
 * @returns
 *  - `en` old {@link CollatorProvider} object.
 *  - `ja` 設定されていた {@link CollatorProvider} オブジェクト
 */
export declare function defaultCollatorProvider(newProvider?: CollatorProvider): CollatorProvider;
/**
 * @en Get string comparator function.
 * @ja 文字列比較用関数を取得
 *
 * @param prop
 *  - `en` property name
 *  - `ja` プロパティ名を指定
 * @param order
 *  - `en` sort order code
 *  - `ja` ソート順を指定
 */
export declare function getStringComparator<T, K extends string = string>(prop: K, order: SortOrder): SortCallback<T>;
/**
 * @en Get date comparator function.
 * @ja 日時比較用関数を取得
 *
 * @param prop
 *  - `en` property name
 *  - `ja` プロパティ名を指定
 * @param order
 *  - `en` sort order code
 *  - `ja` ソート順を指定
 */
export declare function getDateComparator<T, K extends string = string>(prop: K, order: SortOrder): SortCallback<T>;
/**
 * @en Get generic comparator function by comparative operator.
 * @ja 比較演算子を用いた汎用比較関数の取得
 *
 * @param prop
 *  - `en` property name
 *  - `ja` プロパティ名を指定
 * @param order
 *  - `en` sort order code
 *  - `ja` ソート順を指定
 */
export declare function getGenericComparator<T, K extends string = string>(prop: K, order: SortOrder): SortCallback<T>;
/**
 * @en Get boolean comparator function.
 * @ja 真偽値比較用関数を取得
 */
export declare const getBooleanComparator: typeof getGenericComparator;
/**
 * @en Get numeric comparator function.
 * @ja 数値比較用関数を取得
 */
export declare const getNumberComparator: typeof getGenericComparator;
/**
 * @en Convert to comparator from {@link SortKey}.
 * @ja {@link SortKey} を comparator に変換
 */
export declare function toComparator<T, K extends string = string>(sortKey: SortKey<K>): SortCallback<T>;
/**
 * @en Convert to comparator array from {@link SortKey} array.
 * @ja {@link SortKey} 配列を comparator 配列に変換
 */
export declare function convertSortKeys<T, K extends string = string>(sortKeys: SortKey<K>[]): SortCallback<T>[];
/**
 * @en Cursor position constant.
 * @ja カーソル位置定数
 */
export declare const enum CursorPos {
    OUT_OF_RANGE = -1,
    CURRENT = -2
}
/**
 * @en Seek expression function type.
 * @ja シーク式関数定義
 */
export type SeekExp<T> = (value: T, index?: number, obj?: T[]) => boolean;
/**
 * @en The class provides cursor interface for Array. <br>
 *     It is different from Iterator interface of es2015, and that provides interface which is similar to DB recordset's one.
 * @ja Array 用カーソル I/F を提供するクラス <br>
 *     es2015 の Iterator I/F とは異なり、DB recordset オブジェクトライクな走査 I/F を提供する
 */
export declare class ArrayCursor<T = any> {
    /**
     * constructor
     *
     * @param array
     *  - `en` target array
     *  - `ja` 走査対象の配列を指定
     * @param initialIndex
     *  - `en` initial index. default: 0
     *  - `ja` 初期化する index を指定 default: 0
     */
    constructor(array: T[], initialIndex?: number);
    /**
     * @en Reset target array.
     * @ja 対象の再設定
     *
     * @param array
     *  - `en` target array. default: empty array.
     *  - `ja` 走査対象の配列を指定.   default: 空配列
     * @param initialIndex
     *  - `en` initial index. default: CURSOR.OUT_OF_RANGE
     *  - `ja` 初期化する index を指定 default: CURSOR.OUT_OF_RANGE
     */
    reset(array?: T[], initialIndex?: number): ArrayCursor<T>;
    /**
     * @en Access to current element.
     * @ja 現在の要素にアクセス
     */
    get current(): T | undefined;
    /**
     * @en Get current index.
     * @ja 現在指し示している index を取得
     */
    get index(): number;
    /**
     * @en Get target array length.
     * @ja 走査対象の要素数を取得
     */
    get length(): number;
    /**
     * @en Judge BOF or not.
     * @ja 要素外の先頭か判定
     */
    get isBOF(): boolean;
    /**
     * @en Judge EOF or not.
     * @ja 要素外の末尾か判定
     */
    get isEOF(): boolean;
    /**
     * @en Access to raw array instance.
     * @ja 走査対象にアクセス
     */
    get array(): T[];
    /**
     * @en Move to first element position.
     * @ja 先頭要素へ移動
     */
    moveFirst(): ArrayCursor<T>;
    /**
     * @en Move to last element position.
     * @ja 末尾要素へ移動
     */
    moveLast(): ArrayCursor<T>;
    /**
     * @en Move to next element position.
     * @ja カーソルを次へ移動
     */
    moveNext(): ArrayCursor<T>;
    /**
     * @en Move to previous element position.
     * @ja カーソルを前へ移動
     */
    movePrevious(): ArrayCursor<T>;
    /**
     * @en Seek by passed criteria. <br>
     *     If the operation failed, the cursor position set to EOF.
     * @ja 指定条件でシーク <br>
     *     シークに失敗した場合は EOF 状態になる
     *
     * @param criteria
     *  - `en` index or seek expression
     *  - `ja` index / 条件式を指定
     */
    seek(criteria: number | SeekExp<T>): ArrayCursor<T>;
}
/**
 * @en Clear all array elements.
 * @ja 配列の全削除
 *
 * @param target
 *  - `en` target array
 *  - `ja` 対象配列
 * @param token
 *  - `en` {@link CancelToken} reference. (enable `undefined`)
 *  - `ja` {@link CancelToken} を指定 (undefined 可)
 * @returns
 *  - `en` Changed information
 *  - `ja` 変更情報
 */
export declare function clearArray<T>(target: ObservableArray<T> | T[], token?: CancelToken): Promise<ArrayChangeRecord<T>[]>;
/**
 * @en Append source elements to the end of array.
 * @ja 配列の末尾に追加
 *
 * @param target
 *  - `en` target array
 *  - `ja` 対象配列
 * @param src
 *  - `en` source elements
 *  - `ja` 追加元要素
 * @param token
 *  - `en` {@link CancelToken} reference. (enable `undefined`)
 *  - `ja` {@link CancelToken} を指定 (undefined 可)
 * @returns
 *  - `en` Changed information
 *  - `ja` 変更情報
 */
export declare function appendArray<T>(target: ObservableArray<T> | T[], src: T[], token?: CancelToken): Promise<ArrayChangeRecord<T>[]>;
/**
 * @en Insert source elements to specified index of array.
 * @ja 指定した位置に挿入
 *
 * @param target
 *  - `en` target array
 *  - `ja` 対象配列
 * @param index
 *  - `ja` target array position index
 *  - `ja` 追加先のインデックス
 * @param src
 *  - `en` source elements
 *  - `ja` 追加元要素
 * @param token
 *  - `en` {@link CancelToken} reference. (enable `undefined`)
 *  - `ja` {@link CancelToken} を指定 (undefined 可)
 * @returns
 *  - `en` Changed information
 *  - `ja` 変更情報
 */
export declare function insertArray<T>(target: ObservableArray<T> | T[], index: number, src: T[], token?: CancelToken): Promise<ArrayChangeRecord<T>[]>;
/**
 * @en Reorder array elements position.
 * @ja 項目の位置を変更
 *
 * @param target
 *  - `en` target array
 *  - `ja` 対象配列
 * @param index
 *  - `ja` target array position index
 *  - `ja` 追加先のインデックス
 * @param orders
 *  - `en` edit order index array
 *  - `ja` インデックス配列
 * @param token
 *  - `en` {@link CancelToken} reference. (enable `undefined`)
 *  - `ja` {@link CancelToken} を指定 (undefined 可)
 * @returns
 *  - `en` Changed information
 *  - `ja` 変更情報
 */
export declare function reorderArray<T>(target: ObservableArray<T> | T[], index: number, orders: number[], token?: CancelToken): Promise<ArrayChangeRecord<T>[]>;
/**
 * @en Remove array elements.
 * @ja 項目の削除
 *
 * @param target
 *  - `en` target array
 *  - `ja` 対象配列
 * @param orders
 *  - `en` removed order index array
 *  - `ja` インデックス配列
 * @param token
 *  - `en` {@link CancelToken} reference. (enable `undefined`)
 *  - `ja` {@link CancelToken} を指定 (undefined 可)
 * @returns
 *  - `en` Changed information
 *  - `ja` 変更情報
 */
export declare function removeArray<T>(target: ObservableArray<T> | T[], orders: number[], token?: CancelToken): Promise<ArrayChangeRecord<T>[]>;
/**
 * @en Dynamic query condition manager class.
 * @ja ダイナミッククエリ状態管理クラス
 */
export declare class DynamicCondition<TItem extends object, TKey extends Keys<TItem> = Keys<TItem>> implements DynamicConditionSeed<TItem, TKey> {
    private _operators;
    private _combination;
    private _sumKeys;
    private _limit?;
    private _random;
    private _sortKeys;
    /**
     * constructor
     *
     * @param seeds
     *  - `en` {@link DynamicConditionSeed} instance
     *  - `ja` {@link DynamicConditionSeed} インスタンス
     */
    constructor(seeds?: DynamicConditionSeed<TItem, TKey>);
    get operators(): DynamicOperatorContext<TItem>[];
    set operators(values: DynamicOperatorContext<TItem>[]);
    get sumKeys(): (Keys<TItem>)[];
    set sumKeys(values: (Keys<TItem>)[]);
    get combination(): DynamicCombination;
    set combination(value: DynamicCombination);
    get limit(): DynamicLimitCondition<TItem> | undefined;
    set limit(value: DynamicLimitCondition<TItem> | undefined);
    get random(): boolean;
    set random(value: boolean);
    get sortKeys(): SortKey<TKey>[];
    set sortKeys(values: SortKey<TKey>[]);
    /**
     * @en Get comparator functions.
     * @ja 比較関数取得
     */
    get comparators(): SortCallback<TItem>[];
    /**
     * @en Get synthesis filter function.
     * @ja 合成済みフィルタ関数取得
     */
    get filter(): FilterCallback<TItem>;
}
/**
 * @en Apply `filter` and `sort key` to the `items` from {@link queryItems}() result.
 * @ja {@link queryItems}() した `items` に対して `filter` と `sort key` を適用
 */
export declare function searchItems<TItem>(items: TItem[], filter?: FilterCallback<TItem> | null, ...comparators: SortCallback<TItem>[]): TItem[];
/**
 * @en Fix the target items by {@link DynamicCondition}.
 * @ja {@link DynamicCondition} に従い対象を整形
 *
 * @param items
 *  - `en` target items (destructive)
 *  - `ja` 対象のアイテム (破壊的)
 * @param condition
 *  - `en` condition object
 *  - `ja` 条件オブジェクト
 */
export declare function conditionalFix<TItem extends object, TKey extends Keys<TItem> = Keys<TItem>>(items: TItem[], condition: DynamicCondition<TItem, TKey>): CollectionItemQueryResult<TItem>;
/**
 * @en Low level function for {@link Collection} query items.
 * @ja {@link Collection} Item をクエリする低レベル関数
 *
 * @param queryInfo
 *  - `en` query information
 *  - `ja` クエリ情報
 * @param provider
 *  - `en` provider function
 *  - `ja` プロバイダ関数
 * @param options
 *  - `en` query options
 *  - `ja` クエリオプション
 */
export declare function queryItems<TItem extends object, TKey extends Keys<TItem>>(queryInfo: CollectionQueryInfo<TItem, TKey>, provider: CollectionItemProvider<TItem, TKey>, options?: CollectionItemQueryOptions<TItem, TKey>): Promise<TItem[]>;
/**
 * @en Edited collection type definition.
 * @ja 被編集 Collection の型定義
 */
export type CollectionEditee<M extends object> = Collection<M, any, any>;
/**
 * @en Clear all elements of {@link Collection}.
 * @ja {@link Collection} 要素の全削除
 *
 * @param collection
 *  - `en` target {@link Collection}
 *  - `ja` 対象 {@link Collection}
 * @param options
 *  - `en` {@link CollectionEditOptions} reference.
 *  - `ja` {@link CollectionEditOptions} を指定
 * @returns
 *  - `en` Changed information
 *  - `ja` 変更情報
 */
export declare function clearCollection<T extends object>(collection: CollectionEditee<T>, options?: ListEditOptions): Promise<ListChanged<T>>;
/**
 * @en Append source elements to the end of {@link Collection}.
 * @ja {@link Collection} の末尾に追加
 *
 * @param collection
 *  - `en` target {@link Collection}
 *  - `ja` 対象 {@link Collection}
 * @param src
 *  - `en` source elements
 *  - `ja` 追加元要素
 * @param options
 *  - `en` {@link CollectionEditOptions} reference.
 *  - `ja` {@link CollectionEditOptions} を指定
 * @returns
 *  - `en` Changed information
 *  - `ja` 変更情報
 */
export declare function appendCollection<T extends object>(collection: CollectionEditee<T>, src: T[], options?: ListEditOptions): Promise<ListChanged<T>>;
/**
 * @en Insert source elements to specified index of {@link Collection}.
 * @ja {@link Collection} の指定した位置に挿入
 *
 * @param collection
 *  - `en` target {@link Collection}
 *  - `ja` 対象 {@link Collection}
 * @param index
 *  - `ja` target array position index
 *  - `ja` 追加先のインデックス
 * @param src
 *  - `en` source elements
 *  - `ja` 追加元要素
 * @param options
 *  - `en` {@link CollectionEditOptions} reference.
 *  - `ja` {@link CollectionEditOptions} を指定
 * @returns
 *  - `en` Changed information
 *  - `ja` 変更情報
 */
export declare function insertCollection<T extends object>(collection: CollectionEditee<T>, index: number, src: T[], options?: ListEditOptions): Promise<ListChanged<T>>;
/**
 * @en Reorder {@link Collection} elements position.
 * @ja {@link Collection} 項目の位置を変更
 *
 * @param collection
 *  - `en` target {@link Collection}
 *  - `ja` 対象 {@link Collection}
 * @param index
 *  - `ja` target array position index
 *  - `ja` 追加先のインデックス
 * @param orders
 *  - `en` edit order index array
 *  - `ja` インデックス配列
 * @param options
 *  - `en` {@link CollectionEditOptions} reference.
 *  - `ja` {@link CollectionEditOptions} を指定
 * @returns
 *  - `en` Changed information
 *  - `ja` 変更情報
 */
export declare function reorderCollection<T extends object>(collection: CollectionEditee<T>, index: number, orders: number[], options?: ListEditOptions): Promise<ListChanged<T>>;
/**
 * @en Remove {@link Collection} elements.
 * @ja {@link Collection} 項目の削除
 *
 * @param collection
 *  - `en` target {@link Collection}
 *  - `ja` 対象 {@link Collection}
 * @param orders
 *  - `en` removed order index array
 *  - `ja` インデックス配列
 * @param options
 *  - `en` {@link CollectionEditOptions} reference.
 *  - `ja` {@link CollectionEditOptions} を指定
 * @returns
 *  - `en` Changed information
 *  - `ja` 変更情報
 */
export declare function removeCollection<T extends object>(collection: CollectionEditee<T>, orders: number[], options?: ListEditOptions): Promise<ListChanged<T>>;
/**
 * @en Compiled JavaScript template interface
 * @ja コンパイル済みテンプレート格納インターフェイス
 */
export interface CompiledTemplate {
    /**
     * @en Source template string
     * @ja テンプレート文字列
     */
    source: string;
    /**
     * @en Get {@link TemplateResult} that applied given parameter(s).
     * @ja パラメータを適用し {@link TemplateResult} へ変換
     *
     * @param view
     *  - `en` template parameters for source.
     *  - `ja` テンプレートパラメータ
     */
    (view?: PlainObject): TemplateResult | SVGTemplateResult;
}
/**
 * @en {@link TemplateBridge} compile options
 * @ja {@link TemplateBridge} コンパイルオプション
 */
export interface TemplateBridgeCompileOptions {
    transformer?: TemplateTransformer;
}
/**
 * @en Template bridge for other template engine source.
 * @ja 他のテンプレートエンジンの入力を変換するテンプレートブリッジクラス
 */
export declare class TemplateBridge {
    /**
     * @en Get {@link CompiledTemplate} from template source.
     * @ja テンプレート文字列から {@link CompiledTemplate} を取得
     *
     * @param template
     *  - `en` template source string / template element
     *  - `ja` テンプレート文字列 / テンプレートエレメント
     * @param options
     *  - `en` compile options
     *  - `ja` コンパイルオプション
     */
    static compile(template: HTMLTemplateElement | string, options?: TemplateBridgeCompileOptions): CompiledTemplate;
    /**
     * @en Update default transformer object.
     * @ja 既定の変換オブジェクトの更新
     *
     * @param newTransformer
     *  - `en` new transformer object.
     *  - `ja` 新しい変換オブジェクトを指定.
     * @returns
     *  - `en` old transformer object.
     *  - `ja` 以前の変換オブジェクトを返却
     */
    static setTransformer(newTransformer: TemplateTransformer): TemplateTransformer;
    /**
     * @en Get built-in transformer name list.
     * @ja 組み込みの変換オブジェクトの名称一覧を取得
     *
     * @returns
     *  - `en` name list.
     *  - `ja` 名称一覧を返却
     */
    static get builtins(): string[];
    /**
     * @en Get built-in transformer object.
     * @ja 組み込みの変換オブジェクトを取得
     *
     * @param name
     *  - `en` transformer object name.
     *  - `ja` 変換オブジェクトの名前を指定.
     * @returns
     *  - `en` transformer object.
     *  - `ja` 変換オブジェクトを返却
     */
    static getBuitinTransformer(name: string): TemplateTransformer | undefined;
}
/**
 * @en Template query type list.
 * @ja テンプレート取得時に指定可能な型一覧
 */
export interface TemplateQueryTypeList {
    engine: JST;
    bridge: CompiledTemplate;
}
/**
 * @en Template query type definitions.
 * @ja テンプレート取得時に指定可能な型指定子
 */
export type TemplateQueryTypes = keyof TemplateQueryTypeList;
/**
 * @en Template query options.
 * @ja テンプレート取得オプション
 */
export interface TemplateQueryOptions<T extends TemplateQueryTypes> extends LoadTemplateOptions, TemplateCompileOptions, TemplateBridgeCompileOptions {
    /**
     * `engine` / 'bridge'
     */
    type?: T;
    /**
     * @en template load callback. `bridge` mode allows localization here.
     * @ja テンプレート読み込みコールバック. `bridge` モードではここでローカライズが可能
     */
    callback?: (src: string | HTMLTemplateElement) => string | HTMLTemplateElement | Promise<string | HTMLTemplateElement>;
}
/**
 * @en Get compiled JavaScript template.
 * @ja コンパイル済み JavaScript テンプレート取得
 *
 * @param selector
 *  - `en` The selector string of DOM.
 *  - `ja` DOM セレクタ文字列
 * @param options
 *  - `en` query options
 *  - `ja` クエリオプション
 */
export declare function getTemplate<T extends TemplateQueryTypes = 'engine'>(selector: string, options?: TemplateQueryOptions<T>): Promise<TemplateQueryTypeList[T]>;
export interface IHookState<H = unknown> {
    host: H;
    update: VoidFunction;
}
export type NewHookState<T> = T | ((previousState?: T) => T);
export type HookStateUpdater<T> = (value: NewHookState<T>) => void;
export type HookReducer<S, A> = (state: S, action: A) => S;
export interface IHookContext<T = unknown> {
    provide: (value: T, callback?: (value: T) => DirectiveResult) => DirectiveResult;
    consume: (callback: (value: T) => DirectiveResult | void) => DirectiveResult | void;
    readonly defaultValue: T | undefined;
}
/**
 * @en Base abstract class for Custom Hook Class.
 * @ja カスタムフッククラスの基底抽象クラス
 */
export declare abstract class Hook<P extends unknown[] = unknown[], R = unknown, H = unknown> {
    id: number;
    state: IHookState<H>;
    constructor(id: number, state: IHookState<H>);
    abstract update(...args: P): R;
    teardown?(): void;
}
/**
 * @en Interface definition for custom hooks.
 * @ja カスタムフックのインターフェイス定義
 */
export type CustomHook<P extends unknown[] = unknown[], R = unknown, H = unknown> = new (id: number, state: IHookState<H>, ...args: P) => Hook<P, R, H>;
/**
 * @en Factory function for creating custom hooks.
 * @ja カスタムフック作成用ファクトリ関数
 *
 * @example <br>
 *
 * ```ts
 * import { IHookStateContext, Hook, makeHook } from '@cdp/runtime';
 *
 * export const useMemo = makeHook(class <T> extends Hook {
 *     value: T;
 *     values: unknown[];
 *
 *     constructor(id: number, state: State, fn: () => T, values: unknown[]) {
 *         super(id, state);
 *         this.value = fn();
 *         this.values = values;
 *     }
 *
 *     update(fn: () => T, values: unknown[]): T {
 *         if (this.hasChanged(values)) {
 *             this.values = values;
 *             this.value = fn();
 *         }
 *         return this.value;
 *     }
 *
 *     hasChanged(values: unknown[] = []): boolean {
 *         return values.some((value, i) => this.values[i] !== value);
 *     }
 * });
 * ```
 */
export declare const makeHook: <P extends unknown[], R, H = unknown>(Hook: CustomHook<P, R, H>) => (...args: P) => R;
/**
 * @en Provides functionality parity with the React hooks concept.
 * @ja React hooks コンセプトと同等の機能を提供
 *
 * @example <br>
 *
 * ```ts
 * import { html, render, hooks } from '@cdp/runtime';
 * const { useState } = hooks;
 *
 * // function component
 * function App() {
 *     const [count, setCount] = useState(0);
 *     return html`
 *         <p>Count: ${ count }</p>
 *         <button class='state-plus' @click=${() => setCount(prevCount => prevCount! + 1)}>➕</button>
 *     `;
 * }
 *
 * // render with hooks
 * render(hooks(App), document.body);
 * ```
 */
export interface Hooks {
    /**
     * @en Provides functionality parity with the React hooks concept. <br>
     *     Add Hooks feature to template literal syntax.
     * @ja React hooks コンセプトと同等の機能を提供 <br>
     *     テンプレートリテラル構文に Hooks 機能を付加
     *
     * @example <br>
     *
     * ```ts
     * import { html, render, hooks } from '@cdp/runtime';
     * const { useState } = hooks;
     *
     * // function component
     * function App() {
     *     const [count, setCount] = useState(0);
     *     return html`
     *         <p>Count: ${ count }</p>
     *         <button class='state-plus' @click=${() => setCount(prevCount => prevCount! + 1)}>➕</button>
     *     `;
     * }
     *
     * // enabling hooks
     * render(hooks(App), document.body);
     * ```
     *
     * @param renderer
     *  - `en` A function object that returns a template literal syntax
     *  - `ja` テンプレートリテラル構文を返却する関数オブジェクト
     * @param args
     *  - `en` Arguments passed template literal syntax
     *  - `ja` テンプレートリテラル構文にわたる引数
     */
    (renderer: UnknownFunction, ...args: unknown[]): unknown;
    /**
     * @en Add Hooks feature to template literal syntax. (specify a DOM disconnect detection element)
     * @ja テンプレートリテラル構文に Hooks 機能を付加 (DOM 切断検知要素を指定)
     *
     * @example <br>
     *
     * ```ts
     * const el = document.getElementById('some-page');
     * // enabling hooks with root element
     * render(hooks.with(el, App), document.body);
     * ```
     *
     * @param elRoot
     *  - `en` Root element used for DOM disconnection detection. If `null` passed, `document` is specified
     *  - `ja` DOM 切断検知に使用するルート要素. `null` が渡ると `document` が指定される
     * @param renderer
     *  - `en` A function object that returns a template literal syntax
     *  - `ja` テンプレートリテラル構文を返却する関数オブジェクト
     * @param args
     *  - `en` Arguments passed template literal syntax
     *  - `ja` テンプレートリテラル構文にわたる引数
     */
    with: (elRoot: Node | null, renderer: UnknownFunction, ...args: unknown[]) => unknown;
    /**
     * @en Return a stateful value and a function to update it.
     * @ja ステートフルな値と、それを更新するための関数を返却
     *
     * @param initialState
     *  - `en` The value you want the state to be initially.
     *  - `ja` 状態の初期化値
     * @returns
     *  - `en` returns an array with exactly two values. [`currentState`, `updateFunction`]
     *  - `ja` 2つの値を持つ配列を返却 [`currentState`, `updateFunction`]
     */
    useState: <T>(initialState?: T) => readonly [
        T extends ((...args: unknown[]) => infer R) ? R : T,
        HookStateUpdater<T extends ((...args: unknown[]) => infer S) ? S : T>
    ];
    /**
     * @en Accepts a function that contains imperative, possibly effectful code.
     * @ja 副作用を有する可能性のある命令型のコードの適用
     *
     * @param effect
     *  - `en` callback function that runs each time dependencies change
     *  - `ja` 依存関係が変更されるたびに実行されるコールバック関数
     * @param dependencies
     *  - `en` list of dependencies to the effect
     *  - `ja` 副作用発火のトリガーとなる依存関係のリスト
     */
    useEffect: (effect: () => void, dependencies?: unknown[]) => void;
    /**
     * @en Accepts a function that contains imperative, possibly effectful code. <br>
     *     Unlike {@link Hooks.useEffect} , it is executed before the component is rendered and the new element is displayed on the screen.
     * @ja 副作用を有する可能性のある命令型のコードの適用 <br>
     *     {@link Hooks.useEffect} と異なり, コンポーネントがレンダリングされて新しい要素が画面に表示される前に実行される。
     *
     * @param effect
     *  - `en` callback function that runs each time dependencies change
     *  - `ja` 依存関係が変更されるたびに実行されるコールバック関数
     * @param dependencies
     *  - `en` list of dependencies to the effect
     *  - `ja` 副作用発火のトリガーとなる依存関係のリスト
     */
    useLayoutEffect: (effect: () => void, dependencies?: unknown[]) => void;
    /**
     * @en Used to reduce component re-rendering. <br>
     *     Cache the return value of the function and return the cached value when called with the same arguments.
     * @ja コンポーネントの再レンダリングを抑えるために使用 <br>
     *     関数の戻り値をキャッシュし、同じ引数で呼び出された場合にキャッシュされた値を返却
     *
     * @param fn
     *  - `en` A function that returns a value
     *  - `ja` 値を返す関数
     * @param values
     *  - `en` An array of values that are used as arguments for `fn`
     *  - `ja` `fn` の引数として使用される値の配列
     */
    useMemo: <T>(fn: () => T, values: unknown[]) => T;
    /**
     * @en Lets you reference a value that’s not needed for rendering. <br>
     *     Mainly available for accessing DOM nodes.
     * @ja レンダリングに不要な値を参照可能にする<br>
     *     主に DOM ノードへのアクセスに利用可能
     *
     * @param initialValue
     *  - `en` The initial value of the reference
     *  - `ja` 参照の初期値
     */
    useRef: <T>(initialValue: T) => {
        current: T;
    };
    /**
     * @en Returns a memoized version of the callback function that only changes if the dependencies change. <br>
     *     Useful for passing callbacks to optimized child components that rely on referential equality.
     * @ja 依存関係が変更された場合にのみ変更されるコールバック関数のメモ化バージョンを返却 <br>
     *     参照等価性に依存する最適化された子コンポーネントにコールバックを渡す場合に役立つ
     *
     * @param fn
     *  - `en` The function to memoize
     *  - `ja` メモ化する関数
     * @param inputs
     *  - `en` An array of inputs to watch for changes
     *  - `ja` 変更を監視する入力の配列
     */
    useCallback: <T extends UnknownFunction>(fn: T, inputs: unknown[]) => T;
    /**
     * @en Hook API for managing state in function components.
     * @ja 関数コンポーネントで状態を管理するための Hook API
     *
     * @param reducer
     *  - `en` A function that takes the current state and an action and returns a new state
     *  - `ja` 現在の状態とアクションを受け取り、新しい状態を返す関数
     * @param initialState
     *  - `en` The initial state of the reducer
     *  - `ja` リデューサーの初期状態を指定
     * @param init
     *  - `en` An optional function that returns the initial state of the reducer
     *  - `ja` リデューサーの初期状態を返すオプションの関数
     */
    useReducer: <S, I, A>(reducer: HookReducer<S, A>, initialState: I, init?: ((_: I) => S) | undefined) => readonly [
        S,
        (action: A) => void
    ];
    /**
     * @en Create a new context object. Context objects are used to share data that is considered 'global'.
     * @ja 新しいコンテキストオブジェクトを作成する。コンテキストオブジェクトは,「グローバル」と考えられるデータを共有するために使用される。
     *
     * @param defaultValue
     *  - `en`: The default value for the context object
     *  - `ja`: コンテキストオブジェクトのデフォルト値
     */
    createContext: <T>(defaultValue?: T) => IHookContext<T>;
    /**
     * @en Returns the current context value for the specified context object.
     * @ja 指定されたコンテキストオブジェクトに対する現在のコンテキスト値を返却
     *
     * @param context
     *  - `en`: the context object returned from {@link Hooks.createContext}
     *  - `ja`: {@link Hooks.createContext} から返されるコンテキストオブジェクト
     */
    useContext: <T>(context: IHookContext<T>) => T;
}
export declare const hooks: Hooks;
/**
 * @en History state object.
 * @ja 履歴状態オブジェクト
 */
export type HistoryState<T = PlainObject> = T & {
    '@id': string;
    '@origin'?: boolean;
};
/**
 * @en The event definition fired in {@link IHistory}.
 * @ja {@link IHistory} 内から発行されるイベント定義
 */
export interface HistoryEvent<T = PlainObject> {
    /** @args [nextState, cancel, promises[]] */
    'changing': [
        HistoryState<T>,
        (reason?: unknown) => void,
        Promise<unknown>[]
    ];
    /** @args [newState, oldState, promises[]] */
    'refresh': [
        HistoryState<T>,
        HistoryState<T> | undefined,
        Promise<unknown>[]
    ];
    /** @args [error] */
    'error': [
        Error
    ];
}
/**
 * @en History state management options
 * @ja 履歴状態管理用オプション
 */
export type HistorySetStateOptions = Silenceable & Cancelable;
/**
 * @en History direction definition
 * @ja 履歴の方向定義
 */
export type HistoryDirection = 'back' | 'forward' | 'none' | 'missing';
/**
 * @en Definition of {@link IHistory.direct | IHistory.direct}() return type.
 * @ja {@link IHistory.direct | IHistory.direct}() の返却する型
 */
export interface HistoryDirectReturnType<T = PlainObject> {
    direction: HistoryDirection;
    delta?: number;
    index?: number;
    state?: HistoryState<T>;
}
/**
 * @en History management interface. This Interface provides the functions similar to the `History API`.
 * @ja 履歴管理インターフェイス. `History API` と類似した機能を提供する.
 */
export interface IHistory<T = PlainObject> extends Subscribable<HistoryEvent<T>> {
    /** history stack length */
    readonly length: number;
    /** current state */
    readonly state: HistoryState<T>;
    /** current id */
    readonly id: string;
    /** current index */
    readonly index: number;
    /** stack pool */
    readonly stack: readonly HistoryState<T>[];
    /** check it can go back in history */
    readonly canBack: boolean;
    /** check it can go forward in history */
    readonly canForward: boolean;
    /** get data by index. */
    at(index: number): HistoryState<T>;
    /**
     * @en To move backward through history.
     * @ja 履歴の前のページに戻る
     *
     * @returns index after move
     */
    back(): Promise<number>;
    /**
     * @en To move forward through history.
     * @ja 履歴の次のページへ進む
     *
     * @returns index after move
     */
    forward(): Promise<number>;
    /**
     * @en To move a specific point in history.
     * @ja 履歴内の特定のポイントへ移動
     *
     * @param delta
     *  - `en` The position to move in the history, relative to the current page. <br>
     *         If omitted or 0 is specified, reload will be performed.
     *  - `ja` 履歴の中を移動したい先の位置で、現在のページからの相対位置 <br>
     *         省略または 0 が指定された場合は, 再読み込みを実行
     * @returns index after move
     */
    go(delta?: number): Promise<number>;
    /**
     * @en To move a specific point in history by stack ID.
     * @ja スタックIDを指定して履歴内の特定のポイントへ移動
     *
     * @param id
     *  - `en` Specified stack ID
     *  - `ja` スタックIDを指定
     * @returns index after move
     */
    traverseTo(id: string): Promise<number>;
    /**
     * @en Register new history.
     * @ja 新規履歴の登録
     *
     * @param id
     *  - `en` Specified stack ID
     *  - `ja` スタックIDを指定
     * @param state
     *  - `en` State object associated with the stack
     *  - `ja` スタック に紐づく状態オブジェクト
     * @param options
     *  - `en` State management options
     *  - `ja` 状態管理用オプションを指定
     */
    push(id: string, state?: T, options?: HistorySetStateOptions): Promise<number>;
    /**
     * @en Replace current history.
     * @ja 現在の履歴の置換
     *
     * @param id
     *  - `en` Specified stack ID
     *  - `ja` スタックIDを指定
     * @param state
     *  - `en` State object associated with the stack
     *  - `ja` スタック に紐づく状態オブジェクト
     * @param options
     *  - `en` State management options
     *  - `ja` 状態管理用オプションを指定
     */
    replace(id: string, state?: T, options?: HistorySetStateOptions): Promise<number>;
    /**
     * @en Clear forward history from current index.
     * @ja 現在の履歴のインデックスより前方の履歴を削除
     */
    clearForward(): Promise<void>;
    /**
     * @en Return closet index by ID.
     * @ja 指定された ID から最も近い index を返却
     *
     * @param id
     *  - `en` Specified stack ID
     *  - `ja` スタックIDを指定
     * @returns
     *  - `en` closest index
     *  - `ja` 最も近いと判定した index
     */
    closest(id: string): number | undefined;
    /**
     * @en Return destination stack information by `start` and `end` ID.
     * @ja 起点, 終点の ID から終点のスタック情報を返却
     *
     * @param toId
     *  - `en` Specified destination stack ID
     *  - `ja` 終点のスタックIDを指定
     * @param fromId
     *  - `en` Specified origin stack ID. If not specified, using current id.
     *  - `ja` 起点のスタックIDを指定. 指定しない場合は、現在のIDを使用
     */
    direct(toId: string, fromId?: string): HistoryDirectReturnType<T>;
}
/**
 * @en {@link createSessionHistory}() options.
 * @ja {@link createSessionHistory}() に渡すオプション
 *
 */
export interface SessionHistoryCreateOptions {
    context?: Window;
    mode?: 'hash' | 'history';
}
/**
 * @en Create browser session history management object.
 * @ja ブラウザセッション管理オブジェクトを構築
 *
 * @param id
 *  - `en` Specified stack ID
 *  - `ja` スタックIDを指定
 * @param state
 *  - `en` State object associated with the stack
 *  - `ja` スタック に紐づく状態オブジェクト
 * @param options
 *  - `en` {@link SessionHistoryCreateOptions} object
 *  - `ja` {@link SessionHistoryCreateOptions} オブジェクト
 */
export declare function createSessionHistory<T = PlainObject>(id?: string, state?: T, options?: SessionHistoryCreateOptions): IHistory<T>;
/**
 * @en Reset browser session history.
 * @ja ブラウザセッション履歴のリセット
 *
 * @param instance
 *  - `en` `SessionHistory` instance
 *  - `ja` `SessionHistory` インスタンスを指定
 */
export declare function resetSessionHistory<T = PlainObject>(instance: IHistory<T>, options?: HistorySetStateOptions): Promise<void>;
/**
 * @en Dispose browser session history management object.
 * @ja ブラウザセッション管理オブジェクトの破棄
 *
 * @param instance
 *  - `en` `SessionHistory` instance
 *  - `ja` `SessionHistory` インスタンスを指定
 */
export declare function disposeSessionHistory<T = PlainObject>(instance: IHistory<T>): void;
/**
 * @en Create memory history management object.
 * @ja メモリ履歴管理オブジェクトを構築
 *
 * @param id
 *  - `en` Specified stack ID
 *  - `ja` スタックIDを指定
 * @param state
 *  - `en` State object associated with the stack
 *  - `ja` スタック に紐づく状態オブジェクト
 */
export declare function createMemoryHistory<T = PlainObject>(id: string, state?: T): IHistory<T>;
/**
 * @en Reset memory history.
 * @ja メモリ履歴のリセット
 *
 * @param instance
 *  - `en` `MemoryHistory` instance
 *  - `ja` `MemoryHistory` インスタンスを指定
 */
export declare function resetMemoryHistory<T = PlainObject>(instance: IHistory<T>, options?: HistorySetStateOptions): Promise<void>;
/**
 * @en Dispose memory history management object.
 * @ja メモリ履歴管理オブジェクトの破棄
 *
 * @param instance
 *  - `en` `MemoryHistory` instance
 *  - `ja` `MemoryHistory` インスタンスを指定
 */
export declare function disposeMemoryHistory<T = PlainObject>(instance: IHistory<T>): void;
/**
 * @en Page transition parameters definition.
 * @ja ページトランジションに指定するパラメータ定義
 */
export interface PageTransitionParams {
    /**
     * @en Custom page transition name
     * @ja カスタムページトランジション名
     */
    transition?: string;
    /**
     * @en If specify true, the transition direction set to the reverse.
     * @ja トランジションを逆方向に指定したい場合にtrueを指定
     */
    reverse?: boolean;
}
/**
 * @en Interface to manage asynchronous processing during router events.
 * @ja ルーターイベント中の非同期処理を管理するインターフェイス
 */
export interface RouteAyncProcess {
    /** Registering an asynchronous process */
    register(promise: Promise<unknown>): void;
}
/**
 * @en Argument given to the router event callback.
 * @ja ルーターイベントに渡される引数
 */
export interface RouteChangeInfo extends Readonly<PageTransitionParams> {
    /** router instance */
    readonly router: Router;
    /** from state */
    readonly from?: Route;
    /** to state */
    readonly to: Route;
    /** navigate history direction */
    readonly direction: HistoryDirection;
    /** client async process */
    readonly asyncProcess: RouteAyncProcess;
    /** process in reload or not */
    readonly reload: boolean;
    /** extension property for user land */
    intent?: unknown;
}
/**
 * @en The event definition fired in {@link Router}.
 * @ja {@link Router} 内から発行されるイベント定義
 */
export interface RouterEvent {
    /**
     * @en Before route change notification. <br>
     *     It is the only timing when you can cancel the route change.
     * @ja ルート変更前通知 <br>
     *     ルート変更をキャンセルできる唯一のタイミング
     * @args [event, cancel]
     */
    'will-change': [
        RouteChangeInfo,
        (reason?: unknown) => void
    ];
    /**
     * @en New DOM content loaded notification.
     * @ja 新しいDOM コンテンツのロード通知
     * @args {@link RouteChangeInfo}
     */
    'loaded': [
        RouteChangeInfo
    ];
    /**
     * @en Next page just inserted to DOM notification.
     * @ja 次のページの DOM 挿入通知
     * @args {@link RouteChangeInfo}
     */
    'mounted': [
        RouteChangeInfo
    ];
    /**
     * @en DOM ready notification on same page instance transition.
     * @ja 同一ページインスタンスの遷移時の DOM 準備完了通知
     * @args {@link RouteChangeInfo}
     */
    'cloned': [
        RouteChangeInfo
    ];
    /**
     * @en Before transition notification.
     * @ja トランジション開始通知
     * @args {@link RouteChangeInfo}
     */
    'before-transition': [
        RouteChangeInfo
    ];
    /**
     * @en After transition notification.
     * @ja トランジション終了通知
     * @args {@link RouteChangeInfo}
     */
    'after-transition': [
        RouteChangeInfo
    ];
    /**
     * @en Previous page just detached from DOM notification.
     * @ja 前のページの DOM 切除通知
     * @args {@link Route}
     */
    'unmounted': [
        Route
    ];
    /**
     * @en Old DOM content unloaded notification.
     * @ja 古い DOM コンテンツの破棄通知
     * @args [Route]
     */
    'unloaded': [
        Route
    ];
    /**
     * @en Route changed notification.
     * @ja ルート変更完了通知
     * @args [event]
     */
    'changed': [
        RouteChangeInfo
    ];
    /**
     * @en Notified when an error is occured.
     * @ja エラーが発生したときに発行
     *
     * @args [error]
     */
    'error': [
        Result
    ];
}
/**
 * @en Page definition to be routed.
 * @ja ルーティング対象のページインターフェイス定義
 */
export interface Page {
    /**
     * @en Route data associated with the page.
     * @ja ページに紐づくルートデータ
     */
    '@route'?: Route;
    /**
     * @en Construction options
     * @ja コンストラクションオプション
     */
    '@options'?: unknown;
    /**
     * @en Triggered when the page's HTMLElement is newly constructed by router.
     * @ja ページの HTMLElement がルーターによって新規に構築されたときに発火
     */
    pageInit?(info: RouteChangeInfo): void | Promise<void>;
    /**
     * @en Triggered immediately after the page's HTMLElement is inserted into the DOM.
     * @ja ページの HTMLElement が DOM に挿入された直後に発火
     */
    pageMounted?(info: RouteChangeInfo): void | Promise<void>;
    /**
     * @en Triggered immediately after the page's HTMLElement is cloned and inserted into the DOM.
     * @ja ページの HTMLElement が複製され DOM に挿入された直後に発火
     */
    pageCloned?(info: RouteChangeInfo): void | Promise<void>;
    /**
     * @en Triggered when the page is ready to be activated after initialization.
     * @ja 初期化後, ページがアクティベート可能な状態になると発火
     */
    pageBeforeEnter?(info: RouteChangeInfo): void | Promise<void>;
    /**
     * @en Triggered when the page is fully displayed.
     * @ja ページが完全に表示されると発火
     */
    pageAfterEnter?(info: RouteChangeInfo): void | Promise<void>;
    /**
     * @en Triggered just before the page goes hidden.
     * @ja ページが非表示に移行する直前に発火
     */
    pageBeforeLeave?(info: RouteChangeInfo): void | Promise<void>;
    /**
     * @en Triggered immediately after the page is hidden.
     * @ja ページが非表示になった直後に発火
     */
    pageAfterLeave?(info: RouteChangeInfo): void | Promise<void>;
    /**
     * @en Triggered immediately after the page's HTMLElement is detached from the DOM.
     * @ja ページの HTMLElement が DOM から切り離された直後に発火
     */
    pageUnmounted?(info: Route): void;
    /**
     * @en Triggered when the page's HTMLElement is destroyed by the router.
     * @ja ページの HTMLElement がルーターによって破棄されたときに発火
     */
    pageRemoved?(info: Route): void;
}
/**
 * @en {@link Page} factory function.
 * @ja {@link Page} 構築関数
 */
export type RouteComponentFactory = (route: Route, options?: unknown) => Page | Promise<Page>;
/**
 * @en Template factory function.
 * @ja テンプレート構築関数
 */
export type RouteContentFactory = () => DOMSelector | string | Promise<DOMSelector | string>;
export type RouteComponentSeed = Constructor<Page> | RouteComponentFactory | Page | string;
export type RouteContentSeed = {
    selector: string;
    url?: string;
} | RouteContentFactory | DOMSelector | string;
/**
 * @en Route parameters interface. It is also a construction option.
 * @ja ルートパラメータ. 構築オプションとしても使用.
 */
export interface RouteParameters {
    /**
     * @en Route path. Dynamic segments are represented using a colon `:`.
     * @ja ルートのパス. 動的セグメントはコロン `:` を使って表される.
     */
    path: string;
    /**
     * @en Array with nested routes.
     * @ja ネストされたルート
     */
    routes?: RouteParameters[];
    /**
     * @en Specify the constructor or built object of the page component. <br>
     *     In case of functional type, {@link Route} instance is passed as an argument.
     * @ja ページコンポーネントのコンストラクタもしくは構築済みオブジェクト <br>
     *     関数型の場合は引数に {@link Route} インスタンスが渡される
     *
     * @reserved `string` type: load pages as a component via Ajax
     */
    component?: RouteComponentSeed;
    /**
     * @en Options passed to the page component constructor. <br>
     *     In case of functional type, it is passed to the second argument.
     * @ja ページコンポーネントのコンストラクタに渡されるオプション <br>
     *     関数型の場合は第2引数に渡される
     */
    componentOptions?: unknown;
    /**
     * @en Creates dynamic page from specified content string.
     * @ja DOM コンテント構築のシードパラメータ
     */
    content?: RouteContentSeed;
    /**
     * @en Specify `URL` to prefetch the DOM content.
     * @ja DOM コンテントを prefetch しておく場合は `URL` を指定
     */
    prefetch?: string;
}
/**
 * @en The type for the route parameter
 * @ja ルートパラメータに指定する型
 */
export type RoutePathParams = Record<string, string | number | boolean | null | undefined>;
/**
 * @en Route context property definition.
 * @ja ルートコンテキストプロパティ定義
 */
export interface Route {
    /**
     * @en Page's URL.
     * @ja ページの URL.
     */
    readonly url: string;
    /**
     * @en Route path. Dynamic segments are represented using a colon `:`.
     * @ja ルートのパス. 動的セグメントはコロン `:` を使って表される.
     */
    readonly path: string;
    /**
     * @en Object with route query. <br>
     *     If the url is `/page/?id=5&foo=bar` then it will contain the following object `{ id: 5, foo: 'bar' }`
     * @ja ルートクエリに含まれたパラメータ <br>
     *     URL が `/page/?id=5&foo=bar`の場合, 次のオブジェクトが含まれる `{ id: 5, foo: 'bar' }`
     */
    readonly query: RoutePathParams;
    /**
     * @en Route params. <br>
     *     If we have matching route with `/page/user/:userId/post/:postId` path and url of the page is `/page/user/55/post/12` then it will be the following object `{ userId: 55, postId: 12 }`
     * @ja ルートパラメータ <br>
     *     `/page/user/:userId/post/:postId` パスと一致するルートがあり, ページの URL が /page/user/55/post/12` の場合, 次のオブジェクトが含まれる `{ userId: 55, postId: 12 }`
     */
    readonly params: RoutePathParams;
    /**
     * @en Router instance
     * @ja ルーターインスタンス
     */
    readonly router: Router;
    /**
     * @en Page main HTML element
     * @ja ページの主要 HTML 要素
     */
    readonly el: HTMLElement;
}
/**
 * @en Global transition settings.
 * @ja グローバルトランジション設定
 */
export interface TransitionSettings {
    /** default transition name */
    default?: string;
    /** reload transition name */
    reload?: string;
    /** custom enter-from css class name */
    'enter-from-class'?: string;
    /** custom enter-active css class name */
    'enter-active-class'?: string;
    /** custom enter-to css class name */
    'enter-to-class'?: string;
    /** custom leave-from css class name */
    'leave-from-class'?: string;
    /** custom leave-active css class name */
    'leave-active-class'?: string;
    /** custom leave-to css class name */
    'leave-to-class'?: string;
}
/**
 * @en Global navigation settings.
 * @ja グローバルトナビゲーション設定
 */
export interface NavigationSettings {
    /** default navigation method */
    method?: 'push' | 'replace';
}
/**
 * @en Router construction option definition.
 * @ja ルーター構築オプション定義
 */
export interface RouterConstructionOptions {
    /**
     * @en Route construction parameters.
     * @ja ルート構築パラメータ
     */
    routes?: RouteParameters[];
    /**
     * @en Specify `true` when executing route detection at construction time. default: `true`
     * @ja 構築時にルート検知実行する場合に `true` を指定. default: `true`
     */
    start?: boolean;
    /**
     * @en Specify the [IHistory] instance or mode to use with the router. The default is to use the `hash` mode in the browser history.
     * @ja ルーターで使用する {@link IHistory} インスタンスまたはモードを指定. 既定は ブラウザ履歴の `hash` モードを使用.
     */
    history?: 'hash' | 'history' | 'memory' | IHistory;
    /**
     * @en Initialization route path. If {@link IHistory} object given to `history` property, this parameter is ignored.
     * @ja 初期ルートパス. `history` に {@link IHistory} が指定された場合は無視される
     */
    initialPath?: string;
    /**
     * @en Read the router element from the passed parent node.
     * @ja 渡された親ノードから ルーターエレメントを読み込む.
     */
    el?: ParentNode & NonElementParentNode | null;
    /**
     * @en Set using `Window` context. When being un-designating, a fixed value of the environment is used.
     * @ja 使用する `Window` コンテキストを指定. 未指定の場合は環境の既定値が使用される.
     */
    window?: Window | null;
    /**
     * @en CSS class prefix to use. default: `cdp`.
     * @ja 使用する CSS クラスプリフィックス. default: `cdp`
     */
    cssPrefix?: string;
    /**
     * @en Common transition settings.
     * @ja 共通トランジション設定
     */
    transition?: TransitionSettings;
    /**
     * @en Common navigation settings.
     * @ja 共通ナビゲーション設定
     */
    navigation?: NavigationSettings;
}
/**
 * @en Interface to specify for page stack operations.
 * @ja ページスタック操作に指定するインターフェイス
 */
export interface PageStack extends PageTransitionParams {
    /**
     * @en Page's URL.
     * @ja ページの URL
     */
    url: string;
    /**
     * @en The route parameter used when registering a new route.
     * @ja 新規ルート登録を行うときに使用するルートパラメータ.
     */
    route?: RouteParameters;
}
/**
 * @en Router's sub-flow parameters.
 * @ja ルーターの sub-flow に指定するパラメータ
 */
export interface RouteSubFlowParams {
    /**
     * @en Specify the page root path that is the base point of sub-flow. <br>
     *     If not specified, the path of the starting point of sub-flow is assigned.
     * @ja sub-flow の基点となるページルートパスを指定 <br>
     *     指定がない場合は sub-flow を開始地点の path がアサインされる。
     */
    base?: string;
    /**
     * @en Specify {@link PageStack} to add from `base` that transitions at the end of sub-flow. If not specified, transition to `base`.
     * @ja sub-flow 終了時に遷移する `base` からの追加 {@link PageStack} を指定。指定がない場合は、`base` に遷移する。
     */
    additinalStacks?: PageStack[];
}
/**
 * @en Route navigation options definition.
 * @ja ルートナビゲーションオプション定義
 */
export interface RouteNavigationOptions extends PageTransitionParams {
    /**
     * @en Route query params. <br>
     *     If the url is `/page/?id=5&foo=bar` then it will contain the following object `{ id: 5, foo: 'bar' }`
     * @ja ルートクエリパラメータ <br>
     *     URL が `/page/?id=5&foo=bar`の場合, 次のオブジェクトを指定 `{ id: 5, foo: 'bar' }`
     */
    query?: RoutePathParams;
    /**
     * @en Route params. <br>
     *     If we have matching route with `/page/user/:userId/post/:postId` path and url of the page is `/page/user/55/post/12` then it will be the following object `{ userId: 55, postId: 12 }`
     * @ja ルートパラメータ <br>
     *     `/page/user/:userId/post/:postId` パスと一致するルートがあり, ページの URL が /page/user/55/post/12` の場合, 次のオブジェクトを指定 `{ userId: 55, postId: 12 }`
     */
    params?: RoutePathParams;
    /**
     * @en Extension property for user land
     * @ja ユーザー定義可能な拡張プロパティ
     */
    intent?: unknown;
    /**
     * @en Methods of {@link IHistory} to use when navigating.
     * @ja ナビゲーション時に使用する {@link IHistory} のメソッド
     */
    method?: 'push' | 'replace';
}
/**
 * @en Router refresh level.
 * @ja ルーター更新レベル
 */
export declare const enum RouterRefreshLevel {
    RELOAD = 1,
    DOM_CLEAR = 2
}
/**
 * @en Router common interface.
 * @ja ルーター共通インターフェイス
 */
export interface Router extends Subscribable<RouterEvent> {
    /**
     * @en Router's view HTML element
     * @ja ルーターのビュー HTML 要素
     */
    readonly el: HTMLElement;
    /**
     * @en Object with current route data
     * @ja 現在のルートデータを持つオブジェクト
     */
    readonly currentRoute: Route;
    /**
     * @en Check state is in sub-flow
     * @ja sub-flow 中であるか判定
     */
    readonly isInSubFlow: boolean;
    /**
     * @en Check it can go back in history
     * @ja 履歴を戻るが可能か判定
     */
    readonly canBack: boolean;
    /**
     * @en Check it can go forward in history
     * @ja 履歴を進むが可能か判定
     */
    readonly canForward: boolean;
    /**
     * @en Route registration.
     * @jp ルートの登録
     *
     * @param routes
     *  - `en` Specify {@link RouteParameters}
     *  - `ja` {@link RouteParameters} を指定
     * @param refersh
     *  - `en` Specify `true` to reload after registration. default: `false`
     *  - `ja` 登録後, 再読み込みを行う場合は `true` を指定. default: `false`
     */
    register(routes: RouteParameters | RouteParameters[], refersh?: boolean): Promise<this>;
    /**
     * @en Navigate to new page.
     * @ja 新たなページに移動
     *
     * @param to
     *  - `en` Set a navigate destination (url / path)
     *  - `ja` ナビゲート先の設定（url / path）
     * @param options
     *  - `en` Specify {@link RouteNavigationOptions}
     *  - `ja` {@link RouteNavigationOptions} を指定
     */
    navigate(to: string, options?: RouteNavigationOptions): Promise<this>;
    /**
     * @en Add page stack starting from the current history.
     * @ja 現在の履歴を起点にページスタックを追加
     *
     * @param stack
     *  - `en` Specify {@link PageStack} object / object array
     *  - `ja` {@link PageStack} オブジェクト / オブジェクト配列を指定
     * @param noNavigate
     *  - `en` false(`default`): After stack registration, page transition to the last stack / true: Only perform stack registration and do not page transition.
     *  - `ja` false(`default`): スタック登録後, 最後のスタックに対してページ遷移する / true: スタック登録のみ行いページ遷移しない.
     */
    pushPageStack(stack: PageStack | PageStack[], noNavigate?: boolean): Promise<this>;
    /**
     * @en To move backward through history.
     * @ja 履歴の前のページに戻る
     */
    back(): Promise<this>;
    /**
     * @en To move forward through history.
     * @ja 履歴の次のページへ進む
     */
    forward(): Promise<this>;
    /**
     * @en To move a specific point in history.
     * @ja 履歴内の特定のポイントを移動
     *
     * @param delta
     *  - `en` The position to move in the history, relative to the current page. <br>
     *         If omitted or 0 is specified, reload will be performed.
     *  - `ja` 履歴の中を移動したい先の位置で、現在のページからの相対位置 <br>
     *         省略または 0 が指定された場合は, 再読み込みを実行
     */
    go(delta?: number): Promise<this>;
    /**
     * @en To move a specific point in history by stack ID.
     * @ja スタックIDを指定して履歴内の特定のポイントへ移動
     *
     * @param id
     *  - `en` Specified stack ID
     *  - `ja` スタックIDを指定
     */
    traverseTo(id: string): Promise<this>;
    /**
     * @en Begin sub-flow transaction. <br>
     *     Syntactic sugar for `navigate ()`.
     * @ja sub-flow トランザクションの開始 <br>
     *     `navigate()` の糖衣構文
     *
     * @param to
     *  - `en` Set a navigate destination (url / path)
     *  - `ja` ナビゲート先の設定（url / path）
     * @param params
     *  - `en` Specify {@link RouteSubFlowParam}
     *  - `ja` {@link RouteSubFlowParam} を指定
     * @param options
     *  - `en` Specify {@link RouteSubFlowParams}
     *  - `ja` {@link RouteSubFlowParams} を指定
     */
    beginSubFlow(to: string, subflow?: RouteSubFlowParams, options?: RouteNavigationOptions): Promise<this>;
    /**
     * @en Commit sub-flow transaction.
     * @ja sub-flow トランザクションの終了
     *
     * @param params
     *  - `en` Specify {@link PageTransitionParams}. default: { reverse: false }
     *  - `ja` {@link PageTransitionParams} を指定. default: { reverse: false }
     */
    commitSubFlow(params?: PageTransitionParams): Promise<this>;
    /**
     * @en Cancel sub-flow transaction.
     * @ja sub-flow トランザクションのキャンセル
     *
     * @param params
     *  - `en` Specify {@link PageTransitionParams}. default: { reverse: true }
     *  - `ja` {@link PageTransitionParams} を指定. default: { reverse: true }
     */
    cancelSubFlow(params?: PageTransitionParams): Promise<this>;
    /**
     * @en Set common transition settnigs.
     * @ja 共通トランジション設定
     *
     * @param newSettings
     *  - `en` new settings object. get current value without specification.
     *  - `ja` 新規の設定オブジェクト. 指定なしで現在の値を取得
     * @returns
     *  - `en` previous settings object
     *  - `ja` 以前の設定オブジェクト
     */
    transitionSettings(newSettings?: TransitionSettings): TransitionSettings;
    /**
     * @en Set common navigation settnigs.
     * @ja 共通ナビゲーション設定
     *
     * @param newSettings
     *  - `en` new settings object. get current value without specification
     *  - `ja` 新規の設定オブジェクト. 指定なしで現在の値を取得
     * @returns
     *  - `en` previous settings object
     *  - `ja` 以前の設定オブジェクト
     */
    navigationSettings(newSettings?: NavigationSettings): NavigationSettings;
    /**
     * @en Refresh router (specify update level).
     * @ja ルーターの更新(更新レベルの指定)
     */
    refresh(level?: RouterRefreshLevel): Promise<this>;
}
/**
 * @en Create {@link Router} object.
 * @ja {@link Router} オブジェクトを構築
 *
 * @param selector
 *  - `en` An object or the selector string which becomes origin of {@link DOM}.
 *  - `ja` {@link DOM} のもとになるインスタンスまたはセレクタ文字列
 * @param options
 *  - `en` {@link RouterConstructionOptions} object
 *  - `ja` {@link RouterConstructionOptions} オブジェクト
 */
export declare function createRouter(selector: DOMSelector<string | HTMLElement>, options?: RouterConstructionOptions): Router;
/**
 * @en `orientation` identifier
 * @ja `orientation` 識別子
 */
export declare const enum Orientation {
    PORTRAIT = 'portrait',
    LANDSCAPE = 'landscape'
}
/**
 * @en The event definition fired in {@link AppContext}.
 * @ja {@link AppContext} 内から発行されるイベント定義
 */
export interface AppContextEvent {
    /**
     * @en Application ready notification.
     * @ja アプリケーション準備完了通知
     * @args [context]
     */
    'ready': [
        AppContext
    ];
    /**
     * @en Hardware back button press notification.
     * @ja ハードウェアバックボタンの押下通知
     * @args [Event]
     */
    'backbutton': [
        Event
    ];
    /**
     * @en Device orientation change notification.
     * @ja デバイスオリエンテーション変更通知
     * https://developer.mozilla.org/ja/docs/Web/API/Window/orientationchange_event
     * @args [Orientaion, angle]
     */
    'orientationchange': [
        Orientation,
        number
    ];
    /**
     * @en Application langugate change notification.
     * @ja アプリケーション言語変更通知
     * @args [language, i18n.TFunction]
     */
    'languagechange': [
        string,
        i18n.TFunction
    ];
}
/**
 * @en {@link AppContext} create options.
 * @ja {@link AppContext} 構築オプション
 */
export interface AppContextOptions extends RouterConstructionOptions {
    /**
     * @en An object or the selector string which becomes origin of {@link DOM} for main router.
     * @ja メインルーターの {@link DOM} のもとになるインスタンスまたはセレクタ文字列
     * @default `#app`
     */
    main?: DOMSelector<string | HTMLElement>;
    /**
     * @en An object or the selector string which becomes origin of {@link DOM} assigned to the splash screen. <br>
     *     It will be removed just before appliaction ready.
     * @ja スプラッシュスクリーンに割り当てられている {@link DOM} のもとになるインスタンスまたはセレクタ文字列 <br>
     *     準備完了直前に削除される
     */
    splash?: DOMSelector<string | HTMLElement>;
    /**
     * @en Localization module options.
     * @ja ローカライズモジュールオプション
     */
    i18n?: I18NOptions;
    /**
     * @en Custom stand-by function for application ready state.
     * @ja アプリケーション準備完了のための待ち受け関数
     */
    waitForReady?: Promise<unknown> | ((context: AppContext) => Promise<unknown>);
    /**
     * @en Custom `document` event for application ready state.
     * @ja アプリケーション準備完了のためのカスタム `document` イベント
     */
    documentEventReady?: string;
    /**
     * @en Custom `document` event for hardware back button. default: `backbutton`
     * @ja ハードウェアバックボタンのためのカスタム `document` イベント. 既定値 `backbutton`
     */
    documentEventBackButton?: string;
}
/**
 * @en Application context interface
 * @ja アプリケーションコンテキスト
 */
export interface AppContext extends Subscribable<AppContextEvent> {
    /**
     * @en main router interface
     * @ja メインルーター
     */
    readonly router: Router;
    /**
     * @en `Promise` for ready state.
     * @ja 準備完了確認用 `Promise` オブジェクト
     */
    readonly ready: Promise<void>;
    /**
     * @en Current active page instance.
     * @ja 現在アクティブなページインスタンス
     */
    readonly activePage: Page;
    /**
     * @en Current {@link Orientation} id.
     * @ja 現在の {@link Orientation} を取得
     */
    readonly orientation: Orientation;
    /**
     * @en User-definable extended property.
     * @ja ユーザー定義可能な拡張プロパティ
     */
    extension: unknown;
    /**
     * @en Changes the language.
     * @ja 言語の切り替え
     *
     * @param lng
     *  - `en` locale string ex: `en`, `en-US`
     *  - `ja` ロケール文字 ex: `en`, `en-US`
     * @param options
     *  - `en` error behaviour
     *  - `ja` エラー時の振る舞いを指定
     */
    changeLanguage(lng: string, options?: I18NDetectErrorBehaviour): Promise<i18n.TFunction>;
}
/**
 * @en Route parameters for page registration. Need to describe `path`, `content`.
 * @ja ページ登録用ルートパラメータ. `path`, `content` の記述が必要
 */
export type PageRouteParameters = Required<Pick<RouteParameters, 'content'>> & RouteParameters;
/**
 * @en Pre-register concrete {@link Page} class. Registered with the main router when instantiating {@link AppContext}. <br>
 *     If constructor needs arguments, `options.componentOptions` is available.
 * @ja Page 具象化クラスの事前登録. {@link AppContext} のインスタンス化時にメインルーターに登録される. <br>
 *     constructor を指定する引数がある場合は, `options.componentOptions` を利用可能
 *
 * @example <br>
 *
 * ```ts
 * import {
 *     Page,
 *     Router,
 *     AppContext,
 *     registerPage,
 * } from '@cdp/runtime';
 *
 * const pageFactory = (router: Router, ...args: any[]): Page => {
 *   :
 * };
 *
 * // pre-registration
 * registerPage({
 *     path: 'page-path',
 *     conponent: pageFactory,
 *     content: '#page-id'
 * });
 *
 * // initial access
 * const app = AppContext({ main: '#app' });
 * :
 * ```
 *
 * @param path
 *  - `en` route path
 *  - `ja` ルートのパス
 * @param component
 *  - `en` specify the constructor or built object of the page component
 *  - `ja` ページコンポーネントのコンストラクタもしくは構築済みオブジェクト
 * @param options
 *  - `en` route parameters
 *  - `ja` ルートパラメータ
 */
export declare const registerPage: (params: PageRouteParameters) => void;
/**
 * @en Application context access
 * @ja アプリケーションコンテキスト取得
 *
 * @example <br>
 *
 * ```ts
 * import { AppContext } from '@cdp/runtime';
 * ```
 *
 * - initial access
 *
 * ```ts
 * const app = AppContext({
 *     main: '#app',
 *     routes: [
 *         { path: '/' },
 *         { path: '/one' },
 *         { path: '/two' }
 *     ],
 * });
 * :
 * ```
 *
 * - from the second time onwards
 *
 * ```ts
 * const app = AppContext();
 * :
 * ```
 *
 * @param options
 *  - `en` init options
 *  - `ja` 初期化オプション
 */
export declare const AppContext: (options?: AppContextOptions) => AppContext;
/**
 * @en Base class definition of {@link View} that can be specified in as {@link Page} of {@link Router}.
 * @ja {@link Router} の {@link Page} に指定可能な {@link View} の基底クラス定義
 */
export declare abstract class PageView<TElement extends Element = HTMLElement, TEvent extends object = object> extends View<TElement, TEvent> implements Page {
    /**
     * constructor
     *
     * @param route
     *  - `en` route context
     *  - `ja` ルートコンテキスト
     * @param options
     *  - `en` {@link View} construction options.
     *  - `ja` {@link View} 構築オプション
     */
    constructor(route?: Route, options?: ViewConstructionOptions<TElement>);
    /**
     * @en Check the page is active.
     * @ja ページがアクティブであるか判定
     */
    get active(): boolean;
    /**
     * @en Route data associated with the page (public).
     * @ja ページに紐づくルートデータ (公開用)
     */
    get ['@route'](): Route | undefined;
    /**
     * @en {@link Router} instance
     * @ja {@link Router} インスタンス
     */
    protected get _route(): Route | undefined;
    /**
     * @en {@link Router} instance
     * @ja {@link Router} インスタンス
     */
    protected get _router(): Router | undefined;
    /** @override */
    render(...args: unknown[]): any;
    /**
     * @override
     * @en Triggered when the page's HTMLElement is newly constructed by router.
     * @ja ページの HTMLElement がルーターによって新規に構築されたときに発火
     */
    protected onPageInit(thisPage: Route): void | Promise<void>;
    /**
     * @override
     * @en Triggered immediately after the page's HTMLElement is inserted into the DOM.
     * @ja ページの HTMLElement が DOM に挿入された直後に発火
     */
    protected onPageMounted(thisPage: Route): void | Promise<void>;
    /**
     * @override
     * @en Triggered immediately after the page's HTMLElement is cloned and inserted into the DOM.
     * @ja ページの HTMLElement が複製され DOM に挿入された直後に発火
     */
    protected onPageCloned(thisPage: Route, prevPage: Route): void | Promise<void>;
    /**
     * @override
     * @en Triggered when the page is ready to be activated after initialization.
     * @ja 初期化後, ページがアクティベート可能な状態になると発火
     */
    protected onPageBeforeEnter(thisPage: Route, prevPage: Route | undefined, direction: HistoryDirection, intent?: unknown): void | Promise<void>;
    /**
     * @override
     * @en Triggered when the page is fully displayed.
     * @ja ページが完全に表示されると発火
     */
    protected onPageAfterEnter(thisPage: Route, prevPage: Route | undefined, direction: HistoryDirection, intent?: unknown): void | Promise<void>;
    /**
     * @override
     * @en Triggered just before the page goes hidden.
     * @ja ページが非表示に移行する直前に発火
     */
    protected onPageBeforeLeave(thisPage: Route, nextPage: Route, direction: HistoryDirection, intent?: unknown): void | Promise<void>;
    /**
     * @override
     * @en Triggered immediately after the page is hidden.
     * @ja ページが非表示になった直後に発火
     */
    protected onPageAfterLeave(thisPage: Route, nextPage: Route, direction: HistoryDirection, intent?: unknown): void | Promise<void>;
    /**
     * @override
     * @en Triggered immediately after the page's HTMLElement is detached from the DOM.
     * @ja ページの HTMLElement が DOM から切り離された直後に発火
     */
    protected onPageUnmounted(thisPage: Route): void;
    /**
     * @override
     * @en Triggered when the page's HTMLElement is destroyed by the router.
     * @ja ページの HTMLElement がルーターによって破棄されたときに発火
     */
    protected onPageRemoved(thisPage: Route): void;
}
declare namespace i18n {
    /**
     * @en {@link AjaxBackend} options interface.
     * @ja {@link AjaxBackend} のオプションインターフェイス
     */
    interface AjaxBackendOptions extends AjaxRequestOptions {
        /** load path resolver */
        loadPath?: string | ((languages: string[], namespaces: string[]) => string);
    }
    /**
     * @en {@link DomLocalizer} options interface.
     * @ja {@link DomLocalizer} のオプションインターフェイス
     */
    interface DomLocalizerOptions {
        /** selector for translating elements */
        selectorAttr?: string;
        /** data-() attribute to grab target element to translate (if different than itself) */
        targetAttr?: string;
        /** data-() attribute that contains options, will load/set if useOptionsAttr = true */
        optionsAttr?: string;
        /** see optionsAttr */
        useOptionsAttr?: boolean;
        /** parses default values from content ele.val or ele.text */
        parseDefaultValueFromContent?: boolean;
        /** `append` and `prepend` wrapper tag name */
        customTagName?: string | false;
    }
}export interface DOMPlugin {
    /**
     * @en Localize DOM method.
     * @ja DOM のローカライズ
     *
     * @param options
     *  - `en` `i18n.t()` function options
     *  - `ja` `i18n.t()` に渡すオプションを指定
     */
    localize(options?: i18n.TOptions): this;
}
declare namespace CDP_DECLARE {
    /**
     * @en Extends error code definitions.
     * @ja 拡張エラーコード定義
     */
    enum RESULT_CODE {
        I18N_DECLARE = 9007199254740991,
        ERROR_I18N_CORE_LAYER
    }
}
declare namespace CDP_DECLARE {
    /**
     * @en Extends error code definitions.
     * @ja 拡張エラーコード定義
     */
    enum RESULT_CODE {
        MVC_SYNC_DECLARE = 9007199254740991,
        ERROR_MVC_INVALID_SYNC_PARAMS,
        ERROR_MVC_INVALID_SYNC_STORAGE_ENTRY,
        ERROR_MVC_INVALID_SYNC_STORAGE_DATA_NOT_FOUND
    }
}
declare namespace CDP_DECLARE {
    /**
     * @en Extends error code definitions.
     * @ja 拡張エラーコード定義
     */
    enum RESULT_CODE {
        MVC_MODEL_DECLARE = 9007199254740991,
        ERROR_MVC_INVALID_DATA
    }
}
declare namespace CDP_DECLARE {
    /**
     * @en Extends error code definitions.
     * @ja 拡張エラーコード定義
     */
    enum RESULT_CODE {
        MVC_COLLECTION_DECLARE = 9007199254740991,
        ERROR_MVC_INVALID_ACCESS,
        ERROR_MVC_INVALID_COMPARATORS,
        ERROR_MVC_EDIT_PERMISSION_DENIED
    }
}
declare namespace CDP_DECLARE {
    /**
     * @en Extends error code definitions.
     * @ja 拡張エラーコード定義
     */
    enum RESULT_CODE {
        MVC_ROUTER_DECLARE = 9007199254740991,
        ERROR_MVC_ROUTER_ELEMENT_NOT_FOUND,
        ERROR_MVC_ROUTER_ROUTE_CANNOT_BE_RESOLVED,
        ERROR_MVC_ROUTER_NAVIGATE_FAILED,
        ERROR_MVC_ROUTER_INVALID_SUBFLOW_BASE_URL,
        ERROR_MVC_ROUTER_BUSY
    }
}
declare namespace CDP_DECLARE {
    /**
     * @en Extends error code definitions.
     * @ja 拡張エラーコード定義
     */
    enum RESULT_CODE {
        APP_DECLARE = 9007199254740991,
        ERROR_APP_CONTEXT_NEED_TO_BE_INITIALIZED
    }
}
