/*!
 * @cdp/inline-worker 0.9.20
 *   inline web worker utility module
 */

import { safe, isFunction, isString, className } from '@cdp/core-utils';
import { CancelToken } from '@cdp/promise';

/** @internal */ const URL = safe(globalThis.URL);
/** @internal */ const Worker = safe(globalThis.Worker);
/** @internal */ const Blob = safe(globalThis.Blob);
/** @internal */
function createWorkerContext(src) {
    if (!(isFunction(src) || isString(src))) {
        throw new TypeError(`${className(src)} is not a function or string.`);
    }
    return URL.createObjectURL(new Blob([isFunction(src) ? `(${src.toString()})(self);` : src], { type: 'application/javascript' }));
}
/**
 * @en Specified `Worker` class which doesn't require a script file.
 * @ja スクリプトファイルを必要としない `Worker` クラス
 */
class InlineWorker extends Worker {
    /** @internal */
    _context;
    /**
     * constructor
     *
     * @param src
     *  - `en` source function or script body.
     *  - `ja` 実行関数またはスクリプト実体
     * @param options
     *  - `en` worker options.
     *  - `ja` Worker オプション
     */
    constructor(src, options) {
        const context = createWorkerContext(src);
        super(context, options);
        this._context = context;
    }
    ///////////////////////////////////////////////////////////////////////
    // override: Worker
    /**
     * @en For BLOB release. When calling `close ()` in the Worker, call this method as well.
     * @ja BLOB 解放用. Worker 内で `close()` を呼ぶ場合, 本メソッドもコールすること.
     */
    terminate() {
        super.terminate();
        URL.revokeObjectURL(this._context);
    }
}

/**
 * @en Ensure execution in worker thread.
 * @ja ワーカースレッド内で実行を保証
 *
 * @example <br>
 *
 * ```ts
 * const exec = (arg1: number, arg2: string) => {
 *    // this scope is worker scope. you cannot use closure access.
 *    const param = {...};
 *    const method = (p) => {...};
 *    // you can access arguments from options.
 *    console.log(arg1); // '1'
 *    console.log(arg2); // 'test'
 *    :
 *    return method(param);
 * };
 *
 * const arg1 = 1;
 * const arg2 = 'test';
 * const result = await thread(exec, { args: [arg1, arg2] });
 * ```
 *
 * @param executor
 *  - `en` implement as function scope.
 *  - `ja` 関数スコープとして実装
 * @param options
 *  - `en` thread options
 *  - `ja` スレッドオプション
 */
function thread(executor, options) {
    const { cancel: originalToken, args } = Object.assign({ args: [] }, options);
    // already cancel
    if (originalToken?.requested) {
        throw originalToken.reason;
    }
    const exec = `(self => {
        self.addEventListener('message', async ({ data }) => {
            try {
                const result = await (${executor.toString()})(...data);
                self.postMessage(result);
            } catch (e) {
                setTimeout(function() { throw e; });
            }
        });
    })(self);`;
    const worker = new InlineWorker(exec, options);
    const abort = () => worker.terminate();
    originalToken?.register(abort);
    const { token } = CancelToken.source(originalToken);
    const promise = new Promise((resolve, reject) => {
        worker.onerror = ev => {
            ev.preventDefault();
            reject(ev);
            worker.terminate();
        };
        worker.onmessage = ev => {
            resolve(ev.data);
            worker.terminate();
        };
    }, token);
    worker.postMessage(args);
    return promise;
}

export { InlineWorker, thread };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5saW5lLXdvcmtlci5tanMiLCJzb3VyY2VzIjpbImluaW5lLXdvcmtlci50cyIsInRocmVhZC50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xuICAgIGlzRnVuY3Rpb24sXG4gICAgaXNTdHJpbmcsXG4gICAgY2xhc3NOYW1lLFxuICAgIHNhZmUsXG59IGZyb20gJ0BjZHAvY29yZS11dGlscyc7XG5cbi8qKlxuICogQGVuIHtAbGluayBJbmxpbmVXb3JrZXJ9IHNvdXJjZSB0eXBlIGRlZmluaXRpb24uXG4gKiBAamEge0BsaW5rIElubGluZVdvcmtlcn0g44Gr5oyH5a6a5Y+v6IO944Gq44K944O844K55Z6L5a6a576pXG4gKi9cbmV4cG9ydCB0eXBlIElubGllbldvcmtlclNvdXJjZSA9ICgoc2VsZjogV29ya2VyKSA9PiB1bmtub3duKSB8IHN0cmluZztcblxuLyoqIEBpbnRlcm5hbCAqLyBjb25zdCBVUkwgICAgPSBzYWZlKGdsb2JhbFRoaXMuVVJMKTtcbi8qKiBAaW50ZXJuYWwgKi8gY29uc3QgV29ya2VyID0gc2FmZShnbG9iYWxUaGlzLldvcmtlcik7XG4vKiogQGludGVybmFsICovIGNvbnN0IEJsb2IgICA9IHNhZmUoZ2xvYmFsVGhpcy5CbG9iKTtcblxuLyoqIEBpbnRlcm5hbCAqL1xuZnVuY3Rpb24gY3JlYXRlV29ya2VyQ29udGV4dChzcmM6IElubGllbldvcmtlclNvdXJjZSk6IHN0cmluZyB7XG4gICAgaWYgKCEoaXNGdW5jdGlvbihzcmMpIHx8IGlzU3RyaW5nKHNyYykpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7Y2xhc3NOYW1lKHNyYyl9IGlzIG5vdCBhIGZ1bmN0aW9uIG9yIHN0cmluZy5gKTtcbiAgICB9XG4gICAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW2lzRnVuY3Rpb24oc3JjKSA/IGAoJHtzcmMudG9TdHJpbmcoKX0pKHNlbGYpO2AgOiBzcmNdLCB7IHR5cGU6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JyB9KSk7XG59XG5cbi8qKlxuICogQGVuIFNwZWNpZmllZCBgV29ya2VyYCBjbGFzcyB3aGljaCBkb2Vzbid0IHJlcXVpcmUgYSBzY3JpcHQgZmlsZS5cbiAqIEBqYSDjgrnjgq/jg6rjg5fjg4jjg5XjgqHjgqTjg6vjgpLlv4XopoHjgajjgZfjgarjgYQgYFdvcmtlcmAg44Kv44Op44K5XG4gKi9cbmV4cG9ydCBjbGFzcyBJbmxpbmVXb3JrZXIgZXh0ZW5kcyBXb3JrZXIge1xuICAgIC8qKiBAaW50ZXJuYWwgKi9cbiAgICBwcml2YXRlIF9jb250ZXh0OiBzdHJpbmc7XG5cbiAgICAvKipcbiAgICAgKiBjb25zdHJ1Y3RvclxuICAgICAqXG4gICAgICogQHBhcmFtIHNyY1xuICAgICAqICAtIGBlbmAgc291cmNlIGZ1bmN0aW9uIG9yIHNjcmlwdCBib2R5LlxuICAgICAqICAtIGBqYWAg5a6f6KGM6Zai5pWw44G+44Gf44Gv44K544Kv44Oq44OX44OI5a6f5L2TXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKiAgLSBgZW5gIHdvcmtlciBvcHRpb25zLlxuICAgICAqICAtIGBqYWAgV29ya2VyIOOCquODl+OCt+ODp+ODs1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNyYzogSW5saWVuV29ya2VyU291cmNlLCBvcHRpb25zPzogV29ya2VyT3B0aW9ucykge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gY3JlYXRlV29ya2VyQ29udGV4dChzcmMpO1xuICAgICAgICBzdXBlcihjb250ZXh0LCBvcHRpb25zKTtcbiAgICAgICAgdGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG4gICAgfVxuXG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gb3ZlcnJpZGU6IFdvcmtlclxuXG4gICAgLyoqXG4gICAgICogQGVuIEZvciBCTE9CIHJlbGVhc2UuIFdoZW4gY2FsbGluZyBgY2xvc2UgKClgIGluIHRoZSBXb3JrZXIsIGNhbGwgdGhpcyBtZXRob2QgYXMgd2VsbC5cbiAgICAgKiBAamEgQkxPQiDop6PmlL7nlKguIFdvcmtlciDlhoXjgacgYGNsb3NlKClgIOOCkuWRvOOBtuWgtOWQiCwg5pys44Oh44K944OD44OJ44KC44Kz44O844Or44GZ44KL44GT44GoLlxuICAgICAqL1xuICAgIHRlcm1pbmF0ZSgpOiB2b2lkIHtcbiAgICAgICAgc3VwZXIudGVybWluYXRlKCk7XG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwodGhpcy5fY29udGV4dCk7XG4gICAgfVxufVxuIiwiaW1wb3J0IHR5cGUgeyBVbmtub3duRnVuY3Rpb24gfSBmcm9tICdAY2RwL2NvcmUtdXRpbHMnO1xuaW1wb3J0IHsgdHlwZSBDYW5jZWxhYmxlLCBDYW5jZWxUb2tlbiB9IGZyb20gJ0BjZHAvcHJvbWlzZSc7XG5pbXBvcnQgeyBJbmxpbmVXb3JrZXIgfSBmcm9tICcuL2luaW5lLXdvcmtlcic7XG5cbi8qKlxuICogQGVuIFRocmVhZCBvcHRpb25zXG4gKiBAZW4g44K544Os44OD44OJ44Kq44OX44K344On44OzXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgVGhyZWFkT3B0aW9uczxUIGV4dGVuZHMgVW5rbm93bkZ1bmN0aW9uPiBleHRlbmRzIENhbmNlbGFibGUsIFdvcmtlck9wdGlvbnMge1xuICAgIGFyZ3M/OiBQYXJhbWV0ZXJzPFQ+O1xufVxuXG4vKipcbiAqIEBlbiBFbnN1cmUgZXhlY3V0aW9uIGluIHdvcmtlciB0aHJlYWQuXG4gKiBAamEg44Ov44O844Kr44O844K544Os44OD44OJ5YaF44Gn5a6f6KGM44KS5L+d6Ki8XG4gKlxuICogQGV4YW1wbGUgPGJyPlxuICpcbiAqIGBgYHRzXG4gKiBjb25zdCBleGVjID0gKGFyZzE6IG51bWJlciwgYXJnMjogc3RyaW5nKSA9PiB7XG4gKiAgICAvLyB0aGlzIHNjb3BlIGlzIHdvcmtlciBzY29wZS4geW91IGNhbm5vdCB1c2UgY2xvc3VyZSBhY2Nlc3MuXG4gKiAgICBjb25zdCBwYXJhbSA9IHsuLi59O1xuICogICAgY29uc3QgbWV0aG9kID0gKHApID0+IHsuLi59O1xuICogICAgLy8geW91IGNhbiBhY2Nlc3MgYXJndW1lbnRzIGZyb20gb3B0aW9ucy5cbiAqICAgIGNvbnNvbGUubG9nKGFyZzEpOyAvLyAnMSdcbiAqICAgIGNvbnNvbGUubG9nKGFyZzIpOyAvLyAndGVzdCdcbiAqICAgIDpcbiAqICAgIHJldHVybiBtZXRob2QocGFyYW0pO1xuICogfTtcbiAqXG4gKiBjb25zdCBhcmcxID0gMTtcbiAqIGNvbnN0IGFyZzIgPSAndGVzdCc7XG4gKiBjb25zdCByZXN1bHQgPSBhd2FpdCB0aHJlYWQoZXhlYywgeyBhcmdzOiBbYXJnMSwgYXJnMl0gfSk7XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0gZXhlY3V0b3JcbiAqICAtIGBlbmAgaW1wbGVtZW50IGFzIGZ1bmN0aW9uIHNjb3BlLlxuICogIC0gYGphYCDplqLmlbDjgrnjgrPjg7zjg5fjgajjgZfjgablrp/oo4VcbiAqIEBwYXJhbSBvcHRpb25zXG4gKiAgLSBgZW5gIHRocmVhZCBvcHRpb25zXG4gKiAgLSBgamFgIOOCueODrOODg+ODieOCquODl+OCt+ODp+ODs1xuICovXG5leHBvcnQgZnVuY3Rpb24gdGhyZWFkPFQsIFU+KGV4ZWN1dG9yOiAoLi4uYXJnczogVVtdKSA9PiBUIHwgUHJvbWlzZTxUPiwgb3B0aW9ucz86IFRocmVhZE9wdGlvbnM8dHlwZW9mIGV4ZWN1dG9yPik6IFByb21pc2U8VD4ge1xuICAgIGNvbnN0IHsgY2FuY2VsOiBvcmlnaW5hbFRva2VuLCBhcmdzIH0gPSBPYmplY3QuYXNzaWduKHsgYXJnczogW10gfSwgb3B0aW9ucyk7XG5cbiAgICAvLyBhbHJlYWR5IGNhbmNlbFxuICAgIGlmIChvcmlnaW5hbFRva2VuPy5yZXF1ZXN0ZWQpIHtcbiAgICAgICAgdGhyb3cgb3JpZ2luYWxUb2tlbi5yZWFzb247XG4gICAgfVxuXG4gICAgY29uc3QgZXhlYyA9IGAoc2VsZiA9PiB7XG4gICAgICAgIHNlbGYuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIGFzeW5jICh7IGRhdGEgfSkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCAoJHtleGVjdXRvci50b1N0cmluZygpfSkoLi4uZGF0YSk7XG4gICAgICAgICAgICAgICAgc2VsZi5wb3N0TWVzc2FnZShyZXN1bHQpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IHRocm93IGU7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KShzZWxmKTtgO1xuXG4gICAgY29uc3Qgd29ya2VyID0gbmV3IElubGluZVdvcmtlcihleGVjLCBvcHRpb25zKTtcblxuICAgIGNvbnN0IGFib3J0ID0gKCk6IHZvaWQgPT4gd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgIG9yaWdpbmFsVG9rZW4/LnJlZ2lzdGVyKGFib3J0KTtcbiAgICBjb25zdCB7IHRva2VuIH0gPSBDYW5jZWxUb2tlbi5zb3VyY2Uob3JpZ2luYWxUb2tlbiEpO1xuXG4gICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgd29ya2VyLm9uZXJyb3IgPSBldiA9PiB7XG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgcmVqZWN0KGV2KTtcbiAgICAgICAgICAgIHdvcmtlci50ZXJtaW5hdGUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgd29ya2VyLm9ubWVzc2FnZSA9IGV2ID0+IHtcbiAgICAgICAgICAgIHJlc29sdmUoZXYuZGF0YSk7XG4gICAgICAgICAgICB3b3JrZXIudGVybWluYXRlKCk7XG4gICAgICAgIH07XG4gICAgfSwgdG9rZW4pO1xuXG4gICAgd29ya2VyLnBvc3RNZXNzYWdlKGFyZ3MpO1xuXG4gICAgcmV0dXJuIHByb21pc2UgYXMgUHJvbWlzZTxUPjtcbn1cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7OztBQWFBLGlCQUFpQixNQUFNLEdBQUcsR0FBTSxJQUFJLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQztBQUNwRCxpQkFBaUIsTUFBTSxNQUFNLEdBQUcsSUFBSSxDQUFDLFVBQVUsQ0FBQyxNQUFNLENBQUM7QUFDdkQsaUJBQWlCLE1BQU0sSUFBSSxHQUFLLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDO0FBRXJEO0FBQ0EsU0FBUyxtQkFBbUIsQ0FBQyxHQUF1QixFQUFBO0FBQ2hELElBQUEsSUFBSSxFQUFFLFVBQVUsQ0FBQyxHQUFHLENBQUMsSUFBSSxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRTtRQUNyQyxNQUFNLElBQUksU0FBUyxDQUFDLENBQUEsRUFBRyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUEsNkJBQUEsQ0FBK0IsQ0FBQztJQUN6RTtBQUNBLElBQUEsT0FBTyxHQUFHLENBQUMsZUFBZSxDQUFDLElBQUksSUFBSSxDQUFDLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUEsQ0FBQSxFQUFJLEdBQUcsQ0FBQyxRQUFRLEVBQUUsQ0FBQSxRQUFBLENBQVUsR0FBRyxHQUFHLENBQUMsRUFBRSxFQUFFLElBQUksRUFBRSx3QkFBd0IsRUFBRSxDQUFDLENBQUM7QUFDcEk7QUFFQTs7O0FBR0c7QUFDRyxNQUFPLFlBQWEsU0FBUSxNQUFNLENBQUE7O0FBRTVCLElBQUEsUUFBUTtBQUVoQjs7Ozs7Ozs7O0FBU0c7SUFDSCxXQUFBLENBQVksR0FBdUIsRUFBRSxPQUF1QixFQUFBO0FBQ3hELFFBQUEsTUFBTSxPQUFPLEdBQUcsbUJBQW1CLENBQUMsR0FBRyxDQUFDO0FBQ3hDLFFBQUEsS0FBSyxDQUFDLE9BQU8sRUFBRSxPQUFPLENBQUM7QUFDdkIsUUFBQSxJQUFJLENBQUMsUUFBUSxHQUFHLE9BQU87SUFDM0I7OztBQUtBOzs7QUFHRztJQUNILFNBQVMsR0FBQTtRQUNMLEtBQUssQ0FBQyxTQUFTLEVBQUU7QUFDakIsUUFBQSxHQUFHLENBQUMsZUFBZSxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7SUFDdEM7QUFDSDs7QUNoREQ7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBNkJHO0FBQ0csU0FBVSxNQUFNLENBQU8sUUFBMEMsRUFBRSxPQUF3QyxFQUFBO0lBQzdHLE1BQU0sRUFBRSxNQUFNLEVBQUUsYUFBYSxFQUFFLElBQUksRUFBRSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxJQUFJLEVBQUUsRUFBRSxFQUFFLEVBQUUsT0FBTyxDQUFDOztBQUc1RSxJQUFBLElBQUksYUFBYSxFQUFFLFNBQVMsRUFBRTtRQUMxQixNQUFNLGFBQWEsQ0FBQyxNQUFNO0lBQzlCO0FBRUEsSUFBQSxNQUFNLElBQUksR0FBRyxDQUFBOzs7d0NBR3VCLFFBQVEsQ0FBQyxRQUFRLEVBQUUsQ0FBQTs7Ozs7O2NBTTdDO0lBRVYsTUFBTSxNQUFNLEdBQUcsSUFBSSxZQUFZLENBQUMsSUFBSSxFQUFFLE9BQU8sQ0FBQztJQUU5QyxNQUFNLEtBQUssR0FBRyxNQUFZLE1BQU0sQ0FBQyxTQUFTLEVBQUU7QUFDNUMsSUFBQSxhQUFhLEVBQUUsUUFBUSxDQUFDLEtBQUssQ0FBQztJQUM5QixNQUFNLEVBQUUsS0FBSyxFQUFFLEdBQUcsV0FBVyxDQUFDLE1BQU0sQ0FBQyxhQUFjLENBQUM7SUFFcEQsTUFBTSxPQUFPLEdBQUcsSUFBSSxPQUFPLENBQUMsQ0FBQyxPQUFPLEVBQUUsTUFBTSxLQUFJO0FBQzVDLFFBQUEsTUFBTSxDQUFDLE9BQU8sR0FBRyxFQUFFLElBQUc7WUFDbEIsRUFBRSxDQUFDLGNBQWMsRUFBRTtZQUNuQixNQUFNLENBQUMsRUFBRSxDQUFDO1lBQ1YsTUFBTSxDQUFDLFNBQVMsRUFBRTtBQUN0QixRQUFBLENBQUM7QUFDRCxRQUFBLE1BQU0sQ0FBQyxTQUFTLEdBQUcsRUFBRSxJQUFHO0FBQ3BCLFlBQUEsT0FBTyxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUM7WUFDaEIsTUFBTSxDQUFDLFNBQVMsRUFBRTtBQUN0QixRQUFBLENBQUM7SUFDTCxDQUFDLEVBQUUsS0FBSyxDQUFDO0FBRVQsSUFBQSxNQUFNLENBQUMsV0FBVyxDQUFDLElBQUksQ0FBQztBQUV4QixJQUFBLE9BQU8sT0FBcUI7QUFDaEM7Ozs7Iiwic291cmNlUm9vdCI6ImNkcDovLy9AY2RwL2lubGluZS13b3JrZXIvIn0=